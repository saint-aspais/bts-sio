{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BTS SIO 1\u00e8re ann\u00e9e Learning Site","title":"Home"},{"location":"#welcome-to-bts-sio-1ere-annee-learning-site","text":"","title":"Welcome to BTS SIO 1\u00e8re ann\u00e9e Learning Site"},{"location":"bts-sio-1/python/boucles/","text":"Boucles et comparaisons Boucles for Principe En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3 Fonction range() Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps ! Nommage de la variable d'it\u00e9ration Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]: It\u00e9ration sur les indices Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Comparaisons Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus. Boucles while Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles et comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-et-comparaisons","text":"","title":"Boucles et comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-for","text":"","title":"Boucles for"},{"location":"bts-sio-1/python/boucles/#principe","text":"En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3","title":"Principe"},{"location":"bts-sio-1/python/boucles/#fonction-range","text":"Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps !","title":"Fonction range()"},{"location":"bts-sio-1/python/boucles/#nommage-de-la-variable-diteration","text":"Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]:","title":"Nommage de la variable d'it\u00e9ration"},{"location":"bts-sio-1/python/boucles/#iteration-sur-les-indices","text":"Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris","title":"It\u00e9ration sur les indices"},{"location":"bts-sio-1/python/boucles/#comparaisons","text":"Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus.","title":"Comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-while","text":"Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles while"},{"location":"bts-sio-1/python/chaines/","text":"Plus sur les cha\u00eenes de caract\u00e8res Cha\u00eenes de caract\u00e8res et listes Les cha\u00eenes de caract\u00e8res peuvent \u00eatre consid\u00e9r\u00e9es comme des listes (de caract\u00e8res) un peu particuli\u00e8res : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux 'girafe tigre' >>> len ( animaux ) 12 >>> animaux [ 3 ] 'a' Nous pouvons donc utiliser certaines propri\u00e9t\u00e9s des listes comme les tranches : 1 2 3 4 5 6 7 8 9 >>> animaux = \"girafe tigre\" >>> animaux [ 0 : 4 ] 'gira' >>> animaux [ 9 :] 'gre' >>> animaux [: - 2 ] 'girafe tig' >>> animaux [ 1 : - 2 : 2 ] 'iaetg' Mais a contrario des listes, les cha\u00eenes de caract\u00e8res pr\u00e9sentent toutefois une diff\u00e9rence notable, ce sont des listes non modifiables. Une fois une cha\u00eene de caract\u00e8res d\u00e9finie, vous ne pouvez plus modifier un de ses \u00e9l\u00e9ments. Le cas \u00e9ch\u00e9ant, Python renvoie un message d'erreur : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux [ 4 ] 'f' >>> animaux [ 4 ] = \"F\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Par cons\u00e9quent, si vous voulez modifier une cha\u00eene de caract\u00e8res, vous devez en construire une nouvelle. Pour cela, n'oubliez pas que les op\u00e9rateurs de concat\u00e9nation (+) et de duplication ( * ) (introduits dans le chapitre 2 Variables) peuvent vous aider. Vous pouvez \u00e9galement g\u00e9n\u00e9rer une liste, qui elle est modifiable, puis revenir \u00e0 une cha\u00eene de caract\u00e8res (voir plus bas). Caract\u00e8res sp\u00e9ciaux Il existe certains caract\u00e8res sp\u00e9ciaux comme \\n que nous avons d\u00e9j\u00e0 vu (pour le retour \u00e0 la ligne). Le caract\u00e8re \\t produit une tabulation. Si vous voulez \u00e9crire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus avec les guillemets de d\u00e9claration de la cha\u00eene de caract\u00e8res, vous pouvez utiliser \\' ou \\\". 1 2 3 4 5 >>> print ( \"Un retour \u00e0 la ligne \\n puis une tabulation \\t puis un guillemet \\\" \" ) Un retour \u00e0 la ligne puis une tabulation puis un guillemet \" >>> print ( 'J \\' affiche un guillemet simple' ) J 'affiche un guillemet simple Vous pouvez aussi utiliser astucieusement des guillemets doubles ou simples pour d\u00e9clarer votre cha\u00eene de caract\u00e8res : 1 2 3 4 >>> print ( \"Un brin d'ADN\" ) Un brin d 'ADN >>> print ( 'Python est un \"super\" langage de programmation' ) Python est un \"super\" langage de programmation Quand on souhaite \u00e9crire un texte sur plusieurs lignes, il est tr\u00e8s commode d'utiliser les guillemets triples qui conservent le formatage (notamment les retours \u00e0 la ligne) : 1 2 3 4 5 6 7 8 9 >>> x = \"\"\"souris ... chat ... abeille\"\"\" >>> x 'souris \\n chat \\n abeille' >>> print ( x ) souris chat abeille Attention, les caract\u00e8res sp\u00e9ciaux n'apparaissent int\u00e9rpr\u00e9t\u00e9s que lorsqu'ils sont utilis\u00e9s avec la fonction print(). Par exemple, le \\n n'apparait comme un saut de ligne que lorsqu'il est dans une cha\u00eene de caract\u00e8res pass\u00e9e \u00e0 la fonction print() : 1 2 3 4 5 >>> \"bla \\n bla\" 'bla \\n bla' >>> print ( \"bla \\n bla\" ) bla bla Pr\u00e9fixe de cha\u00eene de caract\u00e8res Nous avons vu au chapitre 3 la notion de f-string. Il s'agit d'un m\u00e9canisme pour formater du texte au sein d'une cha\u00eene de caract\u00e8res. Par exemple : 1 2 3 >>> var = \"f-string\" >>> f \"voici une belle { var } \" 'voici une belle f-string' Que signifie le f que l'on accole aux guillements de la cha\u00eene de caract\u00e8res ? Celui-ci est appel\u00e9 \u00ab pr\u00e9fixe de cha\u00eene de caract\u00e8res \u00bb ou stringprefix. Remarque Un stringprefix modifie la mani\u00e8re dont Python va interpr\u00e9ter la dite string. Celui-ci doit \u00eatre syst\u00e9matiquement \u00ab coll\u00e9 \u00bb \u00e0 la cha\u00eene de caract\u00e8res, c'est-\u00e0-dire pas d'espace entre les deux. Il existe diff\u00e9rents stringprefixes en Python, nous vous montrons ici les deux qui nous apparaissent les plus importants. 1 Le pr\u00e9fixe r mis pour raw string qui force la non-interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux : 1 2 3 4 5 6 7 8 9 10 11 >>> s = \"Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne Et l\u00e0 une autre ligne >>> s = r \"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\\\ nEt l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne \\ nEt l\u00e0 une autre ligne L'ajout du r va forcer Python \u00e0 ne pas interpr\u00e9ter le \\n comme un retour \u00e0 la ligne, mais comme un backslash litt\u00e9ral suivi d'un n. Quand on demande \u00e0 l'interpr\u00e9teur d'afficher cette cha\u00eene de caract\u00e8res, celui-ci met deux backslashes pour signifier qu'il s'agit d'un backslash litt\u00e9ral (le premier \u00e9chappe le second). Finalement, l'utilisation de la syntaxe r\"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" renvoie une cha\u00eene de caract\u00e8res normale, puisqu'on voit ensuite que le r \u00e0 disparu lorsqu'on demande \u00e0 Python d'afficher le contenu de la variable s. Comme dans var = 2 + 2, d'abord Python \u00e9value 2 + 2 et c'est ce r\u00e9sultat qui est affect\u00e9 \u00e0 la variable var. Enfin, on notera que seule l'utilisation du print() m\u00e8ne \u00e0 l'interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux comme \\n, comme expliqu\u00e9 dans la rubrique pr\u00e9c\u00e9dente. Les caract\u00e8res sp\u00e9ciaux non interpr\u00e9t\u00e9s dans les raw strings sont de mani\u00e8re g\u00e9n\u00e9rale tout ce dont le backslash modifie la signification, par exemple un \\n, un \\t, etc. 1 Le pr\u00e9fixe f mis pour formatted string qui met en place l'\u00e9criture formatt\u00e9e comme vue au chapitre 3 Affichage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animal = \"renard\" >>> animal2 = \"poulain\" >>> s = f \"Le { animal } est un animal gentil \\n Le { animal2 } aussi\" >>> s 'Le renard est un animal gentil \\n Le poulain aussi' >>> print ( s ) Le renard est un animal gentil Le poulain aussi >>> s = \"Le {animal} est un animal gentil \\n Le {animal2} aussi\" >>> s 'Le {animal} est un animal gentil \\n Le {animal2} aussi' >>> print ( s ) Le { animal } est un animal gentil Le { animal2 } aussi La f-string remplace le contenu des variables situ\u00e9es entre les accolades et interpr\u00e8te le \\n comme un retour \u00e0 la ligne. Pour rappel, consultez le chapitre 3 si vous souhaitez plus de d\u00e9tails sur le fonctionnement des f-strings. Conseils Il existe de nombreux autres d\u00e9tails concernant les pr\u00e9fixes qui vont au del\u00e0 de ce cours. Pour en savoir plus, vous pouvez consulter la documentations officielle. 10.5 M\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res Voici quelques m\u00e9thodes sp\u00e9cifiques aux objets de type str : 1 2 3 4 5 6 7 >>> x = \"girafe\" >>> x . upper () 'GIRAFE' >>> x 'girafe' >>> 'TIGRE' . lower () 'tigre' Les m\u00e9thodes .lower() et .upper() renvoient un texte en minuscule et en majuscule respectivement. On remarque que l'utilisation de ces m\u00e9thodes n'alt\u00e8re pas la cha\u00eene de caract\u00e8res de d\u00e9part mais renvoie une cha\u00eene de caract\u00e8res transform\u00e9e. Pour mettre en majuscule la premi\u00e8re lettre seulement, vous pouvez faire : 1 2 >>> x [ 0 ] . upper () + x [ 1 :] 'Girafe' ou plus simplement utiliser la m\u00e9thode ad\u00e9quate : 1 2 >>> x . capitalize () 'Girafe' Il existe une m\u00e9thode associ\u00e9e aux cha\u00eenes de caract\u00e8res qui est particuli\u00e8rement pratique, la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split () [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> for animal in animaux . split (): ... print ( animal ) ... girafe tigre singe souris La m\u00e9thode .split() d\u00e9coupe une cha\u00eene de caract\u00e8res en plusieurs \u00e9l\u00e9ments appel\u00e9s champs, en utilisant comme s\u00e9parateur n'importe quelle combinaison \u00ab d'espace(s) blanc(s) \u00bb. D\u00e9finition Un espace blanc (whitespace en anglais) correspond aux caract\u00e8res qui sont invisibles \u00e0 l'\u0153il, mais qui occupent de l'espace dans un texte. Les espaces blancs les plus classiques sont l'espace, la tabulation et le retour \u00e0 la ligne. Il est possible de modifier le s\u00e9parateur de champs, par exemple : 1 2 3 >>> animaux = \"girafe:tigre:singe::souris\" >>> animaux . split ( \":\" ) [ 'girafe' , 'tigre' , 'singe' , '' , 'souris' ] Attention, dans cet exemple, le s\u00e9parateur est un seul caract\u00e8res \u00ab : \u00bb (et non pas une combinaison de un ou plusieurs :) conduisant ainsi \u00e0 une cha\u00eene vide entre singe et souris. Il est \u00e9galement int\u00e9ressant d'indiquer \u00e0 .split() le nombre de fois qu'on souhaite d\u00e9couper la cha\u00eene de caract\u00e8res avec l'argument maxsplit : 1 2 3 4 5 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split ( maxsplit = 1 ) [ 'girafe' , 'tigre singe souris' ] >>> animaux . split ( maxsplit = 2 ) [ 'girafe' , 'tigre' , 'singe souris' ] La m\u00e9thode .find(), quant \u00e0 elle, recherche une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 8 9 >>> animal = \"girafe\" >>> animal . find ( \"i\" ) 1 >>> animal . find ( \"afe\" ) 3 >>> animal . find ( \"z\" ) - 1 >>> animal . find ( \"tig\" ) - 1 Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9, alors l'indice du d\u00e9but de l'\u00e9l\u00e9ment dans la cha\u00eene de caract\u00e8res est renvoy\u00e9. Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9, alors la valeur -1 est renvoy\u00e9e. Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9 plusieurs fois, seul l'indice de la premi\u00e8re occurrence est renvoy\u00e9 : 1 2 3 >>> animaux = \"girafe tigre\" >>> animaux . find ( \"i\" ) 1 On trouve aussi la m\u00e9thode .replace() qui substitue une cha\u00eene de caract\u00e8res par une autre : 1 2 3 4 5 >>> animaux = \"girafe tigre\" >>> animaux . replace ( \"tigre\" , \"singe\" ) 'girafe singe' >>> animaux . replace ( \"i\" , \"o\" ) 'gorafe togre' La m\u00e9thode .count() compte le nombre d\u2019occurrences d'une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux . count ( \"i\" ) 2 >>> animaux . count ( \"z\" ) 0 >>> animaux . count ( \"tigre\" ) 1 La m\u00e9thode .startswith() v\u00e9rifie si une cha\u00eene de caract\u00e8res commence par une autre cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> chaine = \"Bonjour monsieur le capitaine !\" >>> chaine . startswith ( \"Bonjour\" ) True >>> chaine . startswith ( \"Au revoir\" ) False Cette m\u00e9thode est particuli\u00e8rement utile lorsqu'on lit un fichier et que l'on veut r\u00e9cup\u00e9rer certaines lignes commen\u00e7ant par un mot-cl\u00e9. Par exemple dans un fichier PDB, les lignes contenant les coordonn\u00e9es des atomes commencent par le mot-cl\u00e9 ATOM. Enfin, la m\u00e9thode .strip() permet de \u00ab nettoyer les bords \u00bb d'une cha\u00eene de caract\u00e8res : 1 2 3 >>> chaine = \" Comment enlever les espaces au d\u00e9but et \u00e0 la fin ? \" >>> chaine . strip () 'Comment enlever les espaces au d\u00e9but et \u00e0 la fin ?' La m\u00e9thode .strip() enl\u00e8ve les espaces situ\u00e9s sur les bords de la cha\u00eene de caract\u00e8re mais pas ceux situ\u00e9s entre des caract\u00e8res visibles. En r\u00e9alit\u00e9, cette m\u00e9thode enl\u00e8ve n'importe quel combinaison \u00ab d'espace(s) blanc(s) \u00bb sur les bords, par exemple : 1 2 3 >>> chaine = \" \\t fonctionne avec les tabulations et les retours \u00e0 la ligne \\n \" >>> chaine . strip () 'fonctionne avec les tabulations et les retours \u00e0 la ligne' La m\u00e9thode .strip() est tr\u00e8s pratique quand on lit un fichier et qu'on veut se d\u00e9barrasser des retours \u00e0 la ligne. Extraction de valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res Une t\u00e2che courante en Python est de lire une cha\u00eene de caract\u00e8res (provenant par exemple d'un fichier), d'extraire des valeurs de cette cha\u00eene de caract\u00e8res pour ensuite les manipuler. On consid\u00e8re par exemple la cha\u00eene de caract\u00e8res val : 1 >>> val = \"3.4 17.2 atom\" On souhaite extraire les valeurs 3.4 et 17.2 pour ensuite les additionner. Dans un premier temps, on d\u00e9coupe la cha\u00eene de caract\u00e8res avec la m\u00e9thode .split() : 1 2 3 >>> val2 = val . split () >>> val2 [ '3.4' , '17.2' , 'atom' ] On obtient alors une liste de cha\u00eenes de caract\u00e8res. On transforme ensuite les deux premiers \u00e9l\u00e9ments de cette liste en floats (avec la fonction float()) pour pouvoir les additionner : 1 2 >>> float ( val2 [ 0 ]) + float ( val2 [ 1 ]) 20.599999999999998 Remarque Retenez bien l'utilisation des instructions pr\u00e9c\u00e9dentes pour extraire des valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res. Elles sont r\u00e9guli\u00e8rement employ\u00e9es pour analyser des donn\u00e9es extraites d'un fichier. 10.7 Conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res On a vu dans le chapitre 2 Variables la conversion d'un type simple (entier, float et cha\u00eene de caract\u00e8res) en un autre avec les fonctions int(), float() et str(). La conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res est particuli\u00e8re puisqu'elle fait appelle \u00e0 la m\u00e9thode .join(). 1 2 3 4 5 6 7 8 9 >>> seq = [ \"A\" , \"T\" , \"G\" , \"A\" , \"T\" ] >>> seq [ 'A' , 'T' , 'G' , 'A' , 'T' ] >>> \"-\" . join ( seq ) 'A-T-G-A-T' >>> \" \" . join ( seq ) 'A T G A T' >>> \"\" . join ( seq ) 'ATGAT' Les \u00e9l\u00e9ments de la liste initiale sont concat\u00e9n\u00e9s les uns \u00e0 la suite des autres et intercal\u00e9s par un s\u00e9parateur qui peut \u00eatre n'importe quelle cha\u00eene de caract\u00e8res. Ici, on a utilis\u00e9 un tiret, un espace et rien (une cha\u00eene de caract\u00e8res vide). Attention, la m\u00e9thode .join() ne s'applique qu'\u00e0 une liste de cha\u00eenes de caract\u00e8res. 1 2 3 4 5 >>> maliste = [ \"A\" , 5 , \"G\" ] >>> \" \" . join ( maliste ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : sequence item 1 : expected string , int found On esp\u00e8re qu'apr\u00e8s ce petit tour d'horizon vous serez convaincu de la richesse des m\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res. Pour avoir une liste exhaustive de l'ensemble des m\u00e9thodes associ\u00e9es \u00e0 une variable particuli\u00e8re, vous pouvez utiliser la fonction dir(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >>> animaux = \"girafe tigre\" >>> dir ( animaux ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '_ _getitem__ ', ' __getnewargs__ ', ' __gt__ ', ' __hash__ ', ' __init__ ', ' _ _init_subclass__ ', ' __iter__ ', ' __le__ ', ' __len__ ', ' __lt__ ', ' __mo d__ ', ' __mul__ ', ' __ne__ ', ' __new__ ', ' __reduce__ ', ' __reduce_ex__ ' , '__repr__' , '__rmod__' , '__rmul__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , 'capitalize' , 'casefold' , 'center' , 'count' , 'encode' , 'endswith' , 'expandtabs' , 'find' , 'format' , 'for mat_map ', ' index ', ' isalnum ', ' isalpha ', ' isdecimal ', ' isdigit ', ' i sidentifier ', ' islower ', ' isnumeric ', ' isprintable ', ' isspace ', ' is title ', ' isupper ', ' join ', ' ljust ', ' lower ', ' lstrip ', ' maketrans ', 'partition' , 'replace' , 'rfind' , 'rindex' , 'rjust' , 'rpartition' , 'rsplit' , 'rstrip' , 'split' , 'splitlines' , 'startswith' , 'strip' , 'swapcase' , 'title' , 'translate' , 'upper' , 'zfill' ] Pour l'instant, vous pouvez ignorer les m\u00e9thodes qui commencent et qui se terminent par deux tirets bas (underscores) __ . Vous pouvez \u00e9galement acc\u00e9der \u00e0 l'aide et \u00e0 la documentation d'une m\u00e9thode particuli\u00e8re avec help(), par exemple pour la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 11 >>> help ( animaux . split ) Help on built - in function split : split ( ... ) S . split ([ sep [, maxsplit ]]) -> list of strings Return a list of the words in the string S , using sep as the delimiter string . If maxsplit is given , at most maxsplit splits are done . If sep is not specified or is None , any whitespace string is a separator . ( END ) Attention \u00e0 ne pas mettre les parenth\u00e8ses \u00e0 la suite du nom de la m\u00e9thode. L'instruction correcte est help(animaux.split) et non pas help(animaux.split()).","title":"Plus sur les cha\u00eenes de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#plus-sur-les-chaines-de-caracteres","text":"","title":"Plus sur les cha\u00eenes de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#chaines-de-caracteres-et-listes","text":"Les cha\u00eenes de caract\u00e8res peuvent \u00eatre consid\u00e9r\u00e9es comme des listes (de caract\u00e8res) un peu particuli\u00e8res : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux 'girafe tigre' >>> len ( animaux ) 12 >>> animaux [ 3 ] 'a' Nous pouvons donc utiliser certaines propri\u00e9t\u00e9s des listes comme les tranches : 1 2 3 4 5 6 7 8 9 >>> animaux = \"girafe tigre\" >>> animaux [ 0 : 4 ] 'gira' >>> animaux [ 9 :] 'gre' >>> animaux [: - 2 ] 'girafe tig' >>> animaux [ 1 : - 2 : 2 ] 'iaetg' Mais a contrario des listes, les cha\u00eenes de caract\u00e8res pr\u00e9sentent toutefois une diff\u00e9rence notable, ce sont des listes non modifiables. Une fois une cha\u00eene de caract\u00e8res d\u00e9finie, vous ne pouvez plus modifier un de ses \u00e9l\u00e9ments. Le cas \u00e9ch\u00e9ant, Python renvoie un message d'erreur : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux [ 4 ] 'f' >>> animaux [ 4 ] = \"F\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Par cons\u00e9quent, si vous voulez modifier une cha\u00eene de caract\u00e8res, vous devez en construire une nouvelle. Pour cela, n'oubliez pas que les op\u00e9rateurs de concat\u00e9nation (+) et de duplication ( * ) (introduits dans le chapitre 2 Variables) peuvent vous aider. Vous pouvez \u00e9galement g\u00e9n\u00e9rer une liste, qui elle est modifiable, puis revenir \u00e0 une cha\u00eene de caract\u00e8res (voir plus bas).","title":"Cha\u00eenes de caract\u00e8res et listes"},{"location":"bts-sio-1/python/chaines/#caracteres-speciaux","text":"Il existe certains caract\u00e8res sp\u00e9ciaux comme \\n que nous avons d\u00e9j\u00e0 vu (pour le retour \u00e0 la ligne). Le caract\u00e8re \\t produit une tabulation. Si vous voulez \u00e9crire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus avec les guillemets de d\u00e9claration de la cha\u00eene de caract\u00e8res, vous pouvez utiliser \\' ou \\\". 1 2 3 4 5 >>> print ( \"Un retour \u00e0 la ligne \\n puis une tabulation \\t puis un guillemet \\\" \" ) Un retour \u00e0 la ligne puis une tabulation puis un guillemet \" >>> print ( 'J \\' affiche un guillemet simple' ) J 'affiche un guillemet simple Vous pouvez aussi utiliser astucieusement des guillemets doubles ou simples pour d\u00e9clarer votre cha\u00eene de caract\u00e8res : 1 2 3 4 >>> print ( \"Un brin d'ADN\" ) Un brin d 'ADN >>> print ( 'Python est un \"super\" langage de programmation' ) Python est un \"super\" langage de programmation Quand on souhaite \u00e9crire un texte sur plusieurs lignes, il est tr\u00e8s commode d'utiliser les guillemets triples qui conservent le formatage (notamment les retours \u00e0 la ligne) : 1 2 3 4 5 6 7 8 9 >>> x = \"\"\"souris ... chat ... abeille\"\"\" >>> x 'souris \\n chat \\n abeille' >>> print ( x ) souris chat abeille Attention, les caract\u00e8res sp\u00e9ciaux n'apparaissent int\u00e9rpr\u00e9t\u00e9s que lorsqu'ils sont utilis\u00e9s avec la fonction print(). Par exemple, le \\n n'apparait comme un saut de ligne que lorsqu'il est dans une cha\u00eene de caract\u00e8res pass\u00e9e \u00e0 la fonction print() : 1 2 3 4 5 >>> \"bla \\n bla\" 'bla \\n bla' >>> print ( \"bla \\n bla\" ) bla bla","title":"Caract\u00e8res sp\u00e9ciaux"},{"location":"bts-sio-1/python/chaines/#prefixe-de-chaine-de-caracteres","text":"Nous avons vu au chapitre 3 la notion de f-string. Il s'agit d'un m\u00e9canisme pour formater du texte au sein d'une cha\u00eene de caract\u00e8res. Par exemple : 1 2 3 >>> var = \"f-string\" >>> f \"voici une belle { var } \" 'voici une belle f-string' Que signifie le f que l'on accole aux guillements de la cha\u00eene de caract\u00e8res ? Celui-ci est appel\u00e9 \u00ab pr\u00e9fixe de cha\u00eene de caract\u00e8res \u00bb ou stringprefix. Remarque Un stringprefix modifie la mani\u00e8re dont Python va interpr\u00e9ter la dite string. Celui-ci doit \u00eatre syst\u00e9matiquement \u00ab coll\u00e9 \u00bb \u00e0 la cha\u00eene de caract\u00e8res, c'est-\u00e0-dire pas d'espace entre les deux. Il existe diff\u00e9rents stringprefixes en Python, nous vous montrons ici les deux qui nous apparaissent les plus importants. 1 Le pr\u00e9fixe r mis pour raw string qui force la non-interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux : 1 2 3 4 5 6 7 8 9 10 11 >>> s = \"Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne Et l\u00e0 une autre ligne >>> s = r \"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\\\ nEt l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne \\ nEt l\u00e0 une autre ligne L'ajout du r va forcer Python \u00e0 ne pas interpr\u00e9ter le \\n comme un retour \u00e0 la ligne, mais comme un backslash litt\u00e9ral suivi d'un n. Quand on demande \u00e0 l'interpr\u00e9teur d'afficher cette cha\u00eene de caract\u00e8res, celui-ci met deux backslashes pour signifier qu'il s'agit d'un backslash litt\u00e9ral (le premier \u00e9chappe le second). Finalement, l'utilisation de la syntaxe r\"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" renvoie une cha\u00eene de caract\u00e8res normale, puisqu'on voit ensuite que le r \u00e0 disparu lorsqu'on demande \u00e0 Python d'afficher le contenu de la variable s. Comme dans var = 2 + 2, d'abord Python \u00e9value 2 + 2 et c'est ce r\u00e9sultat qui est affect\u00e9 \u00e0 la variable var. Enfin, on notera que seule l'utilisation du print() m\u00e8ne \u00e0 l'interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux comme \\n, comme expliqu\u00e9 dans la rubrique pr\u00e9c\u00e9dente. Les caract\u00e8res sp\u00e9ciaux non interpr\u00e9t\u00e9s dans les raw strings sont de mani\u00e8re g\u00e9n\u00e9rale tout ce dont le backslash modifie la signification, par exemple un \\n, un \\t, etc. 1 Le pr\u00e9fixe f mis pour formatted string qui met en place l'\u00e9criture formatt\u00e9e comme vue au chapitre 3 Affichage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animal = \"renard\" >>> animal2 = \"poulain\" >>> s = f \"Le { animal } est un animal gentil \\n Le { animal2 } aussi\" >>> s 'Le renard est un animal gentil \\n Le poulain aussi' >>> print ( s ) Le renard est un animal gentil Le poulain aussi >>> s = \"Le {animal} est un animal gentil \\n Le {animal2} aussi\" >>> s 'Le {animal} est un animal gentil \\n Le {animal2} aussi' >>> print ( s ) Le { animal } est un animal gentil Le { animal2 } aussi La f-string remplace le contenu des variables situ\u00e9es entre les accolades et interpr\u00e8te le \\n comme un retour \u00e0 la ligne. Pour rappel, consultez le chapitre 3 si vous souhaitez plus de d\u00e9tails sur le fonctionnement des f-strings. Conseils Il existe de nombreux autres d\u00e9tails concernant les pr\u00e9fixes qui vont au del\u00e0 de ce cours. Pour en savoir plus, vous pouvez consulter la documentations officielle. 10.5 M\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res Voici quelques m\u00e9thodes sp\u00e9cifiques aux objets de type str : 1 2 3 4 5 6 7 >>> x = \"girafe\" >>> x . upper () 'GIRAFE' >>> x 'girafe' >>> 'TIGRE' . lower () 'tigre' Les m\u00e9thodes .lower() et .upper() renvoient un texte en minuscule et en majuscule respectivement. On remarque que l'utilisation de ces m\u00e9thodes n'alt\u00e8re pas la cha\u00eene de caract\u00e8res de d\u00e9part mais renvoie une cha\u00eene de caract\u00e8res transform\u00e9e. Pour mettre en majuscule la premi\u00e8re lettre seulement, vous pouvez faire : 1 2 >>> x [ 0 ] . upper () + x [ 1 :] 'Girafe' ou plus simplement utiliser la m\u00e9thode ad\u00e9quate : 1 2 >>> x . capitalize () 'Girafe' Il existe une m\u00e9thode associ\u00e9e aux cha\u00eenes de caract\u00e8res qui est particuli\u00e8rement pratique, la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split () [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> for animal in animaux . split (): ... print ( animal ) ... girafe tigre singe souris La m\u00e9thode .split() d\u00e9coupe une cha\u00eene de caract\u00e8res en plusieurs \u00e9l\u00e9ments appel\u00e9s champs, en utilisant comme s\u00e9parateur n'importe quelle combinaison \u00ab d'espace(s) blanc(s) \u00bb. D\u00e9finition Un espace blanc (whitespace en anglais) correspond aux caract\u00e8res qui sont invisibles \u00e0 l'\u0153il, mais qui occupent de l'espace dans un texte. Les espaces blancs les plus classiques sont l'espace, la tabulation et le retour \u00e0 la ligne. Il est possible de modifier le s\u00e9parateur de champs, par exemple : 1 2 3 >>> animaux = \"girafe:tigre:singe::souris\" >>> animaux . split ( \":\" ) [ 'girafe' , 'tigre' , 'singe' , '' , 'souris' ] Attention, dans cet exemple, le s\u00e9parateur est un seul caract\u00e8res \u00ab : \u00bb (et non pas une combinaison de un ou plusieurs :) conduisant ainsi \u00e0 une cha\u00eene vide entre singe et souris. Il est \u00e9galement int\u00e9ressant d'indiquer \u00e0 .split() le nombre de fois qu'on souhaite d\u00e9couper la cha\u00eene de caract\u00e8res avec l'argument maxsplit : 1 2 3 4 5 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split ( maxsplit = 1 ) [ 'girafe' , 'tigre singe souris' ] >>> animaux . split ( maxsplit = 2 ) [ 'girafe' , 'tigre' , 'singe souris' ] La m\u00e9thode .find(), quant \u00e0 elle, recherche une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 8 9 >>> animal = \"girafe\" >>> animal . find ( \"i\" ) 1 >>> animal . find ( \"afe\" ) 3 >>> animal . find ( \"z\" ) - 1 >>> animal . find ( \"tig\" ) - 1 Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9, alors l'indice du d\u00e9but de l'\u00e9l\u00e9ment dans la cha\u00eene de caract\u00e8res est renvoy\u00e9. Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9, alors la valeur -1 est renvoy\u00e9e. Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9 plusieurs fois, seul l'indice de la premi\u00e8re occurrence est renvoy\u00e9 : 1 2 3 >>> animaux = \"girafe tigre\" >>> animaux . find ( \"i\" ) 1 On trouve aussi la m\u00e9thode .replace() qui substitue une cha\u00eene de caract\u00e8res par une autre : 1 2 3 4 5 >>> animaux = \"girafe tigre\" >>> animaux . replace ( \"tigre\" , \"singe\" ) 'girafe singe' >>> animaux . replace ( \"i\" , \"o\" ) 'gorafe togre' La m\u00e9thode .count() compte le nombre d\u2019occurrences d'une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux . count ( \"i\" ) 2 >>> animaux . count ( \"z\" ) 0 >>> animaux . count ( \"tigre\" ) 1 La m\u00e9thode .startswith() v\u00e9rifie si une cha\u00eene de caract\u00e8res commence par une autre cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> chaine = \"Bonjour monsieur le capitaine !\" >>> chaine . startswith ( \"Bonjour\" ) True >>> chaine . startswith ( \"Au revoir\" ) False Cette m\u00e9thode est particuli\u00e8rement utile lorsqu'on lit un fichier et que l'on veut r\u00e9cup\u00e9rer certaines lignes commen\u00e7ant par un mot-cl\u00e9. Par exemple dans un fichier PDB, les lignes contenant les coordonn\u00e9es des atomes commencent par le mot-cl\u00e9 ATOM. Enfin, la m\u00e9thode .strip() permet de \u00ab nettoyer les bords \u00bb d'une cha\u00eene de caract\u00e8res : 1 2 3 >>> chaine = \" Comment enlever les espaces au d\u00e9but et \u00e0 la fin ? \" >>> chaine . strip () 'Comment enlever les espaces au d\u00e9but et \u00e0 la fin ?' La m\u00e9thode .strip() enl\u00e8ve les espaces situ\u00e9s sur les bords de la cha\u00eene de caract\u00e8re mais pas ceux situ\u00e9s entre des caract\u00e8res visibles. En r\u00e9alit\u00e9, cette m\u00e9thode enl\u00e8ve n'importe quel combinaison \u00ab d'espace(s) blanc(s) \u00bb sur les bords, par exemple : 1 2 3 >>> chaine = \" \\t fonctionne avec les tabulations et les retours \u00e0 la ligne \\n \" >>> chaine . strip () 'fonctionne avec les tabulations et les retours \u00e0 la ligne' La m\u00e9thode .strip() est tr\u00e8s pratique quand on lit un fichier et qu'on veut se d\u00e9barrasser des retours \u00e0 la ligne.","title":"Pr\u00e9fixe de cha\u00eene de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#extraction-de-valeurs-numeriques-dune-chaine-de-caracteres","text":"Une t\u00e2che courante en Python est de lire une cha\u00eene de caract\u00e8res (provenant par exemple d'un fichier), d'extraire des valeurs de cette cha\u00eene de caract\u00e8res pour ensuite les manipuler. On consid\u00e8re par exemple la cha\u00eene de caract\u00e8res val : 1 >>> val = \"3.4 17.2 atom\" On souhaite extraire les valeurs 3.4 et 17.2 pour ensuite les additionner. Dans un premier temps, on d\u00e9coupe la cha\u00eene de caract\u00e8res avec la m\u00e9thode .split() : 1 2 3 >>> val2 = val . split () >>> val2 [ '3.4' , '17.2' , 'atom' ] On obtient alors une liste de cha\u00eenes de caract\u00e8res. On transforme ensuite les deux premiers \u00e9l\u00e9ments de cette liste en floats (avec la fonction float()) pour pouvoir les additionner : 1 2 >>> float ( val2 [ 0 ]) + float ( val2 [ 1 ]) 20.599999999999998 Remarque Retenez bien l'utilisation des instructions pr\u00e9c\u00e9dentes pour extraire des valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res. Elles sont r\u00e9guli\u00e8rement employ\u00e9es pour analyser des donn\u00e9es extraites d'un fichier. 10.7 Conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res On a vu dans le chapitre 2 Variables la conversion d'un type simple (entier, float et cha\u00eene de caract\u00e8res) en un autre avec les fonctions int(), float() et str(). La conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res est particuli\u00e8re puisqu'elle fait appelle \u00e0 la m\u00e9thode .join(). 1 2 3 4 5 6 7 8 9 >>> seq = [ \"A\" , \"T\" , \"G\" , \"A\" , \"T\" ] >>> seq [ 'A' , 'T' , 'G' , 'A' , 'T' ] >>> \"-\" . join ( seq ) 'A-T-G-A-T' >>> \" \" . join ( seq ) 'A T G A T' >>> \"\" . join ( seq ) 'ATGAT' Les \u00e9l\u00e9ments de la liste initiale sont concat\u00e9n\u00e9s les uns \u00e0 la suite des autres et intercal\u00e9s par un s\u00e9parateur qui peut \u00eatre n'importe quelle cha\u00eene de caract\u00e8res. Ici, on a utilis\u00e9 un tiret, un espace et rien (une cha\u00eene de caract\u00e8res vide). Attention, la m\u00e9thode .join() ne s'applique qu'\u00e0 une liste de cha\u00eenes de caract\u00e8res. 1 2 3 4 5 >>> maliste = [ \"A\" , 5 , \"G\" ] >>> \" \" . join ( maliste ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : sequence item 1 : expected string , int found On esp\u00e8re qu'apr\u00e8s ce petit tour d'horizon vous serez convaincu de la richesse des m\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res. Pour avoir une liste exhaustive de l'ensemble des m\u00e9thodes associ\u00e9es \u00e0 une variable particuli\u00e8re, vous pouvez utiliser la fonction dir(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >>> animaux = \"girafe tigre\" >>> dir ( animaux ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '_ _getitem__ ', ' __getnewargs__ ', ' __gt__ ', ' __hash__ ', ' __init__ ', ' _ _init_subclass__ ', ' __iter__ ', ' __le__ ', ' __len__ ', ' __lt__ ', ' __mo d__ ', ' __mul__ ', ' __ne__ ', ' __new__ ', ' __reduce__ ', ' __reduce_ex__ ' , '__repr__' , '__rmod__' , '__rmul__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , 'capitalize' , 'casefold' , 'center' , 'count' , 'encode' , 'endswith' , 'expandtabs' , 'find' , 'format' , 'for mat_map ', ' index ', ' isalnum ', ' isalpha ', ' isdecimal ', ' isdigit ', ' i sidentifier ', ' islower ', ' isnumeric ', ' isprintable ', ' isspace ', ' is title ', ' isupper ', ' join ', ' ljust ', ' lower ', ' lstrip ', ' maketrans ', 'partition' , 'replace' , 'rfind' , 'rindex' , 'rjust' , 'rpartition' , 'rsplit' , 'rstrip' , 'split' , 'splitlines' , 'startswith' , 'strip' , 'swapcase' , 'title' , 'translate' , 'upper' , 'zfill' ] Pour l'instant, vous pouvez ignorer les m\u00e9thodes qui commencent et qui se terminent par deux tirets bas (underscores) __ . Vous pouvez \u00e9galement acc\u00e9der \u00e0 l'aide et \u00e0 la documentation d'une m\u00e9thode particuli\u00e8re avec help(), par exemple pour la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 11 >>> help ( animaux . split ) Help on built - in function split : split ( ... ) S . split ([ sep [, maxsplit ]]) -> list of strings Return a list of the words in the string S , using sep as the delimiter string . If maxsplit is given , at most maxsplit splits are done . If sep is not specified or is None , any whitespace string is a separator . ( END ) Attention \u00e0 ne pas mettre les parenth\u00e8ses \u00e0 la suite du nom de la m\u00e9thode. L'instruction correcte est help(animaux.split) et non pas help(animaux.split()).","title":"Extraction de valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res"},{"location":"bts-sio-1/python/collections/","text":"Dictionnaires, tuples et sets Jusqu'\u00e0 maintenant nous avons vu et manipul\u00e9 le type d'objet s\u00e9quentiel le plus classique : les listes. On se rappelle qu'elles sont modifiables, ordonn\u00e9es et it\u00e9rables. Dans ce chapitre nous allons voir trois nouveaux types d'objet s\u00e9quentiel avec des propri\u00e9t\u00e9s diff\u00e9rentes : les dictionnaires, les tuples et les sets. Remarque Les objets s\u00e9quentiels peuvent \u00eatre aussi appel\u00e9s parfois containers. Dictionnaires D\u00e9finition Les dictionnaires se r\u00e9v\u00e8lent tr\u00e8s pratiques lorsque vous devez manipuler des structures complexes \u00e0 d\u00e9crire et que les listes pr\u00e9sentent leurs limites. Les dictionnaires sont des collections non ordonn\u00e9es d'objets, c'est-\u00e0-dire qu'il n'y a pas de notion d'ordre (i.e. pas d'indice). On acc\u00e8de aux valeurs d'un dictionnaire par des cl\u00e9s. Ceci semble un peu confus ? Regardez l'exemple suivant : 1 2 3 4 5 6 >>> ani1 = {} >>> ani1 [ \"nom\" ] = \"girafe\" >>> ani1 [ \"taille\" ] = 5.0 >>> ani1 [ \"poids\" ] = 1100 >>> ani1 { 'nom' : 'girafe' , 'taille' : 5.0 , 'poids' : 1100 } En premier, on d\u00e9finit un dictionnaire vide avec les accolades {} (tout comme on peut le faire pour les listes avec []). Ensuite, on remplit le dictionnaire avec diff\u00e9rentes cl\u00e9s (\"nom\", \"taille\", \"poids\") auxquelles on affecte des valeurs (\"girafe\", 5.0, 1100). Vous pouvez mettre autant de cl\u00e9s que vous voulez dans un dictionnaire (tout comme vous pouvez ajouter autant d'\u00e9l\u00e9ments que vous voulez dans une liste). Remarque Un dictionnaire est affich\u00e9 sans ordre particulier. On peut aussi initialiser toutes les cl\u00e9s et les valeurs d'un dictionnaire en une seule op\u00e9ration : 1 >>> ani2 = { \"nom\" : \"singe\" , \"poids\" : 70 , \"taille\" : 1.75 } Mais rien ne nous emp\u00eache d'ajouter une cl\u00e9 et une valeur suppl\u00e9mentaire : 1 >>> ani2 [ \"age\" ] = 15 Pour r\u00e9cup\u00e9rer la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e, il suffit d'utiliser la syntaxe suivante dictionnaire[\"cle\"]. Par exemple : 1 2 >>> ani1 [ \"taille\" ] 5.0 Remarque Toutes les cl\u00e9s de dictionnaire utilis\u00e9es jusqu'\u00e0 pr\u00e9sent \u00e9taient des cha\u00eenes de caract\u00e8res. Rien n'emp\u00eache d'utiliser d'autres types d'objets comme des entiers (voire m\u00eame des tuples, cf. rubrique suivante), cela peut parfois s'av\u00e9rer tr\u00e8s utile. N\u00e9anmoins, nous vous conseillons, autant que possible, d'utiliser syst\u00e9matiquement des cha\u00eenes de caract\u00e8res pour vos cl\u00e9s de dictionnaire. Apr\u00e8s ce premier tour d'horizon, on voit tout de suite l'avantage des dictionnaires. Pouvoir retrouver des \u00e9l\u00e9ments par des noms (cl\u00e9s) plut\u00f4t que par des indices. Les humains retiennent mieux les noms que les chiffres. Ainsi, l'usage des dictionnaires rend en g\u00e9n\u00e9ral le code plus lisible. Par exemple, si nous souhaitions stocker les coordonn\u00e9es (x,y,z) d'un point dans l'espace : coors = [0, 1, 2] pour la version liste, coors = {\"x\": 0, \"y\": 1, \"z\": 2} pour la version dictionnaire. Un lecteur comprendra tout de suite que coors[\"z\"] contient la coordonn\u00e9e z , ce sera moins intuitif avec coors[2]. It\u00e9ration sur les cl\u00e9s pour obtenir les valeurs Il est possible d'obtenir toutes les valeurs d'un dictionnaire \u00e0 partir de ses cl\u00e9s : 1 2 3 4 5 6 7 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> for key in ani2 : ... print ( key , ani2 [ key ]) ... poids 70 nom singe taille 1.75 M\u00e9thodes .keys(), .values() et .items() Les m\u00e9thodes .keys() et .values() renvoient, comme vous pouvez vous en doutez, les cl\u00e9s et les valeurs d'un dictionnaire : 1 2 3 4 >>> ani2 . keys () dict_keys ([ 'poids' , 'nom' , 'taille' ]) >>> ani2 . values () dict_values ([ 70 , 'singe' , 1.75 ]) Les mentions dict_keys et dict_values indiquent que nous avons \u00e0 faire \u00e0 des objets un peu particuliers. Ils ne sont pas indexables (on ne peut pas retrouver un \u00e9l\u00e9ment par indice, par exemple dico.keys()[0] renverra une erreur). Si besoin, nous pouvons les transformer en liste avec la fonction list() : 1 2 3 4 >>> ani2 . values () dict_values ([ 'singe' , 70 , 1.75 ]) >>> list ( ani2 . values ()) [ 'singe' , 70 , 1.75 ] Toutefois, ce sont des objets \u00ab it\u00e9rables \u00bb, donc utilisables dans une boucle. Enfin, il existe la m\u00e9thode .items() qui renvoie un nouvel objet dict_items : 1 2 3 >>> dico = { 0 : \"t\" , 1 : \"o\" , 2 : \"t\" , 3 : \"o\" } >>> dico . items () dict_items ([( 0 , 't' ), ( 1 , 'o' ), ( 2 , 't' ), ( 3 , 'o' )]) Celui-ci n'est pas indexable (on ne peut pas retrouver un \u00e9l\u00e9ment par un indice) mais il est it\u00e9rable : 1 2 3 4 5 6 7 8 9 10 11 >>> dico . items ()[ 2 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'dict_items' object is not subscriptable >>> for key , val in dico . items (): ... print ( key , val ) ... 0 t 1 o 2 t 3 o Notez la syntaxe particuli\u00e8re qui ressemble \u00e0 la fonction enumerate() vue au chapitre 5 Boucles et comparaisons. On it\u00e8re \u00e0 la fois sur key et sur val. On verra plus bas que cela peut-\u00eatre utile pour construire des dictionnaires de compr\u00e9hension. Existence d'une cl\u00e9 Pour v\u00e9rifier si une cl\u00e9 existe dans un dictionnaire, on peut utiliser le test d\u2019appartenance avec l'instruction in qui renvoie un bool\u00e9en : 1 2 3 4 5 6 7 8 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> if \"poids\" in ani2 : ... print ( \"La cl\u00e9 'poids' existe pour ani2\" ) ... La cl\u00e9 'poids' existe pour ani2 >>> if \"age\" in ani2 : ... print ( \"La cl\u00e9 'age' existe pour ani2\" ) ... Dans le second test (lignes 5 \u00e0 7), le message n'est pas affich\u00e9 car la cl\u00e9 age n'est pas pr\u00e9sente dans le dictionnaire ani2. M\u00e9thode .get() La m\u00e9thode .get() extrait la valeur associ\u00e9e \u00e0 une cl\u00e9 mais ne renvoie pas d'erreur si la cl\u00e9 n'existe pas : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> ani2 . get ( \"nom\" ) 'singe' >>> ani2 . get ( \"age\" ) >>> Ici la valeur associ\u00e9e \u00e0 la cl\u00e9 nom est singe mais la cl\u00e9 age n'existe pas. On peut \u00e9galement indiquer \u00e0 .get() une valeur par d\u00e9faut si la cl\u00e9 n'existe pas : 1 2 >>> ani2 . get ( \"age\" , 42 ) 42 Tri par cl\u00e9s On peut utiliser la fonction sorted() vue pr\u00e9c\u00e9demment avec les listes pour trier un dictionnaire par ses cl\u00e9s : 1 2 3 >>> ani2 = { 'nom' : 'singe' , 'taille' : 1.75 , 'poids' : 70 } >>> sorted ( ani2 ) [ 'nom' , 'poids' , 'taille' ] Les cl\u00e9s sont tri\u00e9es ici par ordre alphab\u00e9tique. Tri par valeurs Pour trier un dictionnaire par ses valeurs, il faut utiliser la fonction sorted avec l'argument key : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get ) [ 'b' , 'a' , 'c' ] L'argument key=dico.get indique explicitement qu'il faut r\u00e9aliser le tri par les valeurs du dictionnaire. On retrouve la m\u00e9thode .get() vue plus haut, mais sans les parenth\u00e8ses (key=dico.get mais pas key=dico.get()). Attention, ce sont les cl\u00e9s du dictionnaires qui sont renvoy\u00e9es, pas les valeurs. Ces cl\u00e9s sont cependant renvoy\u00e9es dans un ordre qui permet d'obtenir les cl\u00e9s tri\u00e9es par ordre croissant : 1 2 3 4 5 6 7 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> for key in sorted ( dico , key = dico . get ): ... print ( key , dico [ key ]) ... b 5 a 15 c 20 Enfin, l'argument reverse=True fonctionne \u00e9galement : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get , reverse = True ) [ 'c' , 'a' , 'b' ] Remarque Lorsqu'on trie un dictionnaire par ses valeurs, il faut \u00eatre s\u00fbr que cela soit possible. Ce n'est, par exemple, pas le cas pour le dictionnaire ani2 car les valeurs sont des valeurs num\u00e9riques et une cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> sorted ( ani2 , key = ani2 . get ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' On obtient ici une erreur car Python ne sait pas comparer une cha\u00eene de caract\u00e8res (singe) avec des valeurs num\u00e9riques (70 et 1.75). Cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs Les fonctions min() et max(), que vous avez d\u00e9j\u00e0 manipul\u00e9es dans les chapitres pr\u00e9c\u00e9dents, acceptent \u00e9galement l'argument key=. On peut ainsi obtenir la cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs d'un dictionnaire : 1 2 3 4 5 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> max ( dico , key = dico . get ) 'c' >>> min ( dico , key = dico . get ) 'b' Liste de dictionnaires En cr\u00e9ant une liste de dictionnaires qui poss\u00e8dent les m\u00eames cl\u00e9s, on obtient une structure qui ressemble \u00e0 une base de donn\u00e9es : 1 2 3 4 5 6 7 8 9 10 >>> animaux = [ ani1 , ani2 ] >>> animaux [{ 'nom' : 'girafe' , 'poids' : 1100 , 'taille' : 5.0 }, { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 }] >>> >>> for ani in animaux : ... print ( ani [ \"nom\" ]) ... girafe singe Vous constatez ainsi que les dictionnaires permettent de g\u00e9rer des structures complexes de mani\u00e8re plus explicite que les listes. Fonction dict() Conseil Pour les d\u00e9butants vous pouvez sauter cette rubrique. La fonction dict() va convertir l'argument qui lui est pass\u00e9 en dictionnaire. Il s'agit donc d'une fonction de casting comme int(), str(), etc. Toutefois, l'argument qui lui est pass\u00e9 doit avoir une forme particuli\u00e8re : un objet s\u00e9quentiel contenant d'autres objets s\u00e9quentiels de 2 \u00e9l\u00e9ments. Par exemple, une liste de listes de 2 \u00e9l\u00e9ments : 1 2 3 >>> liste_animaux = [[ \"girafe\" , 2 ], [ \"singe\" , 3 ]] >>> dict ( liste_animaux ) { 'girafe' : 2 , 'singe' : 3 } Ou un tuple de tuples de 2 \u00e9l\u00e9ments (cf. rubrique suivante pour la d\u00e9finition d'un tuple), ou encore une combinaison liste / tuple : 1 2 3 4 5 6 >>> tuple_animaux = (( \"girafe\" , 2 ), ( \"singe\" , 3 )) >>> dict ( tuple_animaux ) { 'girafe' : 2 , 'singe' : 3 } >>> >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 )]) { 'girafe' : 2 , 'singe' : 3 } Si un des sous-\u00e9l\u00e9ments a plus de 2 \u00e9l\u00e9ments (ou moins), Python renvoie une erreur : 1 2 3 4 >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 , 4 )]) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : dictionary update sequence element #1 has length 3; 2 is required Tuples D\u00e9finition Les tuples (\u00ab n-uplets \u00bb en fran\u00e7ais) correspondent aux listes \u00e0 la diff\u00e9rence qu'ils sont non modifiables. On a vu dans le chapitre 11 Plus sur les listes que les listes pouvaient \u00eatre modifi\u00e9es par r\u00e9f\u00e9rences, notamment lors de la copie de listes. Les tuples s'affranchissent de ce probl\u00e8me puisqu'ils sont non modifiables. Pratiquement, ils utilisent les parenth\u00e8ses au lieu des crochets : 1 2 3 4 5 6 7 8 9 10 11 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x [ 2 ] 3 >>> x [ 0 : 2 ] ( 1 , 2 ) >>> x [ 2 ] = 15 Traceback ( innermost last ): File \"<stdin>\" , line 1 , in ? TypeError : object doesn 't support item assignment L'affectation et l'indi\u00e7age fonctionnent comme avec les listes. Mais si on essaie de modifier un des \u00e9l\u00e9ments du tuple, Python renvoie un message d'erreur. Si vous voulez ajouter un \u00e9l\u00e9ment (ou le modifier), vous devez cr\u00e9er un autre tuple : 1 2 3 >>> x = ( 1 , 2 , 3 ) >>> x + ( 2 ,) ( 1 , 2 , 3 , 2 ) Remarque Pour utiliser un tuple d'un seul \u00e9l\u00e9ment, vous devez utiliser une syntaxe avec une virgule (element,), ceci pour \u00e9viter une ambigu\u00eft\u00e9 avec une simple expression. Autre particularit\u00e9 des tuples, il est possible d'en cr\u00e9er de nouveaux sans les parenth\u00e8ses, d\u00e8s lors que ceci ne pose pas d'ambigu\u00eft\u00e9 avec une autre expression : 1 2 3 4 5 6 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x = 1 , 2 , 3 >>> x ( 1 , 2 , 3 ) Toutefois, nous vous conseillons d'utiliser syst\u00e9matiquement les parenth\u00e8ses afin d'\u00e9viter les confusions. Enfin, on peut utiliser la fonction tuple(sequence) qui fonctionne exactement comme la fonction list(), c'est-\u00e0-dire qu'elle prend en argument un objet s\u00e9quentiel et renvoie le tuple correspondant (op\u00e9ration de casting) : 1 2 3 4 >>> tuple ([ 1 , 2 , 3 ]) ( 1 , 2 , 3 ) >>> tuple ( \"ATGCCGCGAT\" ) ( 'A' , 'T' , 'G' , 'C' , 'C' , 'G' , 'C' , 'G' , 'A' , 'T' ) Remarque Les listes, les dictionnaires et les tuples sont des objets qui peuvent contenir des collections d'autres objets. On peut donc construire des listes qui contiennent des dictionnaires, des tuples ou d'autres listes, mais aussi des dictionnaires contenant des tuples, des listes, etc. It\u00e9rations sur plusieurs valeurs \u00e0 la fois Pratiquement, nous avons d\u00e9j\u00e0 crois\u00e9 les tuples avec la fonction enumerate() dans le chapitre 5 Boucles et comparaisons. Cette derni\u00e8re permettait d'it\u00e9rer en m\u00eame temps sur les indices et les \u00e9l\u00e9ments d'une liste : 1 2 3 4 5 6 7 8 9 10 11 12 >>> for i , elt in enumerate ([ 75 , - 75 , 0 ]): ... print ( i , elt ) ... 0 75 1 - 75 2 0 >>> for obj in enumerate ([ 75 , - 75 , 0 ]): ... print ( obj , type ( obj )) ... ( 0 , 75 ) < class ' tuple '> ( 1 , - 75 ) < class ' tuple '> ( 2 , 0 ) < class ' tuple '> En fin de compte, la fonction enumerate() it\u00e8re sur une s\u00e9rie de tuples. Pouvoir s\u00e9parer i et elt dans la boucle est possible du fait que Python autorise l'affectation multiple du style i, elt = 0, 75 (cf. rubrique suivante). Dans le m\u00eame ordre d'id\u00e9e, nous avons vu \u00e0 la rubrique pr\u00e9c\u00e9dente la m\u00e9thode .dict_items() qui permettait d'it\u00e9rer sur des couples cl\u00e9 / valeur d'un dictionnaire : 1 2 3 4 5 6 7 8 9 10 11 >>> dico = { \"pinson\" : 2 , \"merle\" : 3 } >>> for key , val in dico . items (): ... print ( key , val ) ... pinson 2 merle 3 >>> for obj in dico . items (): ... print ( obj , type ( obj )) ... ( 'pinson' , 2 ) < class ' tuple '> ( 'merle' , 3 ) < class ' tuple '> On voit que cette m\u00e9thode .dict_items() it\u00e8re comme enumerate() sur une s\u00e9rie de tuples. Sur la m\u00eame base, on peut finalement it\u00e9rer sur 3 valeurs en m\u00eame temps \u00e0 partir d'une liste de tuples de 3 \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 9 >>> liste = [( i , i + 1 , i + 2 ) for i in range ( 5 , 8 )] >>> liste [( 5 , 6 , 7 ), ( 6 , 7 , 8 ), ( 7 , 8 , 9 )] >>> for x , y , z in liste : ... print ( x , y , z ) ... 5 6 7 6 7 8 7 8 9 On pourrait concevoir la m\u00eame chose sur 4 \u00e9l\u00e9ments, ou finalement autant que l'on veut. La seule restriction est d'avoir une correspondance syst\u00e9matique entre le nombre de variables d'it\u00e9ration (par exemple 3 ci-dessus avec x, y, z) et la longueur de chaque sous-tuple de la liste sur laquelle on it\u00e8re (chaque sous-tuple a 3 \u00e9l\u00e9ments ci-dessus). Affectation multiple et le nom de variable _ L'affectation multiple est un m\u00e9canisme tr\u00e8s puissant et important en Python. Pour rappel, il permet d'effectuer sur une m\u00eame ligne plusieurs affectations en m\u00eame temps, par exemple : x, y, z = 1, 2, 3. On voit que cette syntaxe correspond \u00e0 un tuple de chaque c\u00f4t\u00e9 de l'op\u00e9rateur =. Notez qu'il serait possible de le faire \u00e9galement avec les listes : [x, y, z] = [1, 2, 3]. Toutefois, cette syntaxe est alourdie par la pr\u00e9sence des crochets. On pr\u00e9f\u00e8rera donc la premi\u00e8re syntaxe avec les tuples sans parenth\u00e8se. Remarque Nous avons appel\u00e9 l'op\u00e9ration x, y, z = 1, 2, 3 affectation multiple pour signifier que l'on affectait des valeurs \u00e0 plusieurs variables en m\u00eame temps. Toutefois, vous pourrez rencontrer aussi l'expression tuple unpacking que l'on pourrait traduire par \u00ab d\u00e9sempaquetage de tuple \u00bb. Cela signifie que l'on d\u00e9compose le tuple initial 1, 2, 3 en 3 variables diff\u00e9rentes (comme si on vidait son sac \u00e0 dos, d'o\u00f9 le terme d\u00e9sempaquetage !). Nous avions crois\u00e9 l'importance de l'affectation multiple dans le chapitre 9 Fonctions lorsqu'une fonction renvoyait plusieurs valeurs. 1 2 3 4 5 6 >>> def fct (): ... return 3 , 14 ... >>> x , y = fct () >>> print ( x , y ) 3 14 La syntaxe x, y = fct() permet de r\u00e9cup\u00e9rer les 2 valeurs renvoy\u00e9es par la fonction et de les affecter \u00e0 la vol\u00e9e dans 2 variables diff\u00e9rentes. Cela \u00e9vite l'op\u00e9ration laborieuse de r\u00e9cup\u00e9rer d'abord le tuple, puis de cr\u00e9er les variables en utilisant l'indi\u00e7age : 1 2 3 4 5 6 7 >>> resultat = fct () >>> resultat ( 3 , 14 ) >>> x = resultat [ 0 ] >>> y = resultat [ 1 ] >>> print ( x , y ) 3 14 Conseils Lorsqu'une fonction renvoie plusieurs valeurs sous forme de tuple, ce sera bien s\u00fbr la forme x, y = fct() qui sera privil\u00e9gi\u00e9e. Quand une fonction renvoie plusieurs valeurs mais que l'on ne souhaite pas les utiliser toutes dans la suite du code, on peut utiliser le nom de variable _ (underscore) pour indiquer que certaines valeurs ne nous int\u00e9ressent pas : 1 2 3 4 5 6 7 8 >>> def fct (): ... return 1 , 2 , 3 , 4 ... >>> x , _ , y , _ = fct () >>> x 1 >>> y 3 Cela envoie le message \u00e0 celui qui lit le code \u00ab je me fiche des valeurs r\u00e9cup\u00e9r\u00e9es dans ces variables _ \u00bb. Notez que l'on peut utiliser une ou plusieurs variables underscores(s). Dans l'exemple ci-dessus, la 2\u00e8me et la 4\u00e8me variable renvoy\u00e9es par la fonction seront ignor\u00e9es dans la suite du code. Cela a le m\u00e9rite d'\u00e9viter la cr\u00e9ation de variables dont on ne se sert pas. Remarque La variable _ a une autre signication sp\u00e9ciale dans l'interpr\u00e9teur interactif, elle prend automatiquement la derni\u00e8re valeur affich\u00e9e : 1 2 3 4 5 6 7 8 >>> 3 3 >>> _ 3 >>> \"m\u00e9sange\" 'm\u00e9sange' >>> _ 'm\u00e9sange' Attention, cela n'est vrai que dans l'interpr\u00e9teur. Remarque Le underscore est couramment utilis\u00e9 dans les noms de variable pour s\u00e9parer les mots et \u00eatre explicite, par exemple seq_ADN ou liste_listes_residus. On verra dans le chapitre 15 Bonnes pratiques en programmation Python que ce style de nommage est appel\u00e9 snake_case. Toutefois, il faut \u00e9viter d'utiliser les underscores en d\u00e9but et/ou en fin de nom de variable (e.g. _var , var_ , __var , __var__ ). On verra au chapitre 19 Avoir la classe avec les objets que ces underscores ont une signification particuli\u00e8re. Sets Les containers de type set repr\u00e9sentent un autre type d'objet s\u00e9quentiel qui peut se r\u00e9v\u00e9ler tr\u00e8s pratique. Ils ont la particularit\u00e9 d'\u00eatre non modifiables, non ordonn\u00e9s et de ne contenir qu'une seule copie maximum de chaque \u00e9l\u00e9ment. Pour cr\u00e9er un nouveau set on peut utiliser les accolades : 1 2 3 4 5 >>> s = { 1 , 2 , 3 , 3 } >>> s { 1 , 2 , 3 } >>> type ( s ) < class ' set '> Notez que la r\u00e9p\u00e9tition du 3 dans la d\u00e9finition du set en ligne 1 donne au final un seul 3 car chaque \u00e9l\u00e9ment ne peut \u00eatre pr\u00e9sent qu'une seule fois. A quoi diff\u00e9rencie-t-on un set d'un dictionnaire alors que les deux utilisent des accolades ? Le set sera d\u00e9fini seulement par des valeurs {val1, val2, ...} alors que le dictionnaire aura toujours des couples cl\u00e9/valeur {cl\u00e91: val1, cl\u00e92: val2, ...}. En g\u00e9n\u00e9ral, on utilisera la fonction interne \u00e0 Python set() pour g\u00e9n\u00e9rer un nouveau set. Celle-ci prend en argument n'importe quel objet it\u00e9rable et le convertit en set (op\u00e9ration de casting) : 1 2 3 4 5 6 7 8 9 10 11 12 >>> set ([ 1 , 2 , 4 , 1 ]) { 1 , 2 , 4 } >>> set (( 2 , 2 , 2 , 1 )) { 1 , 2 } >>> set ( range ( 5 )) { 0 , 1 , 2 , 3 , 4 } >>> set ({ \"cl\u00e91\" : 1 , \"cl\u00e92\" : 2 }) { 'cl\u00e91' , 'cl\u00e92' } >>> set ([ \"ti\" , \"to\" , \"to\" ]) { 'ti' , 'to' } >>> set ( \"Ma\u00eetre corbeau sur un arbre perch\u00e9\" ) { 'h' , 'u' , 'o' , 'b' , ' ' , 'M' , 'a' , 'p' , 'n' , 'e' , '\u00e9' , 'c' , '\u00ee' , 's' , 't' , 'r' } Nous avons dit plus haut que les sets ne sont pas ordonn\u00e9s, il est donc impossible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment par sa position. Il est \u00e9galement impossible de modifier un de ses \u00e9l\u00e9ments. Par contre, les sets sont it\u00e9rables : 1 2 3 4 5 6 7 8 9 10 11 >>> s = set ([ 1 , 2 , 4 , 1 ]) >>> s [ 1 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object is not subscriptable >>> for elt in s : ... print ( elt ) ... 1 2 4 Les containers de type set sont tr\u00e8s utiles pour rechercher les \u00e9l\u00e9ments uniques d'une suite d'\u00e9l\u00e9ments. Cela revient \u00e0 \u00e9liminer tous les doublons. Par exemple : 1 2 3 4 5 6 >>> import random as rd >>> l = [ rd . randint ( 0 , 9 ) for i in range ( 10 )] >>> l [ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ] >>> set ( l ) { 3 , 5 , 6 , 7 , 8 , 9 } On peut bien s\u00fbr transformer dans l'autre sens un set en liste. Cela permet par exemple d'\u00e9liminer les doublons de la liste initiale tout en r\u00e9cup\u00e9rant une liste \u00e0 la fin : 1 2 >>> list ( set ([ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ])) [ 3 , 5 , 6 , 7 , 8 , 9 ] On peut faire des choses tr\u00e8s puissantes. Par exemple, un compteur de lettres en combinaison avec une liste de compr\u00e9hension, le tout en une ligne ! 1 2 3 4 5 >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> set ( seq ) { 'c' , 'g' , 't' , 'a' } >>> [( base , seq . count ( base )) for base in set ( seq )] [( 'c' , 15 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'a' , 10 )] Les sets permettent aussi l'\u00e9valuation d'union ou d'intersection math\u00e9matiques en conjonction avec les op\u00e9rateurs respectivement | et & : 1 2 3 4 5 6 >>> l = [ 3 , 3 , 5 , 1 , 3 , 4 , 1 , 1 , 4 , 4 ] >>> l2 = [ 3 , 0 , 5 , 3 , 3 , 1 , 1 , 1 , 2 , 2 ] >>> set ( l ) & set ( l2 ) { 1 , 3 , 5 } >>> set ( l ) | set ( l2 ) { 0 , 1 , 2 , 3 , 4 , 5 } Conseils Pour aller plus loin, vous pouvez consulter deux articles sur les sites programiz et towardsdatascience. Dictionnaires et sets de compr\u00e9hension Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Nous avons vu au chapitre 11 Plus sur les listes les listes de compr\u00e9hension. Il est \u00e9galement possible de g\u00e9n\u00e9rer des dictionnaires de compr\u00e9hension : 1 2 3 4 5 6 7 8 9 10 11 12 >>> dico = { \"a\" : 10 , \"g\" : 10 , \"t\" : 11 , \"c\" : 15 } >>> dico . items () dict_items ([( 'a' , 10 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'c' , 15 )]) >>> { key : val * 2 for key , val in dico . items ()} { 'a' : 20 , 'g' : 20 , 't' : 22 , 'c' : 30 } >>> >>> { key : val for key , val in enumerate ( \"toto\" )} { 0 : 't' , 1 : 'o' , 2 : 't' , 3 : 'o' } >>> >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> { base : seq . count ( base ) for base in set ( seq )} { 'a' : 10 , 'g' : 10 , 't' : 11 , 'c' : 15 } De mani\u00e8re g\u00e9n\u00e9rale, tout objet sur lequel on peut faire une double it\u00e9ration du type for var1, var2 in obj est utilisable pour cr\u00e9er un dictionnaire de compr\u00e9hension. Si vous souhaitez aller plus loin, vous pouvez consulter cet article sur le site Datacamp. Il est \u00e9galement possible de g\u00e9n\u00e9rer des sets de compr\u00e9hension sur le m\u00eame mod\u00e8le que les listes de compr\u00e9hension : 1 2 3 4 >>> { i for i in range ( 10 )} { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } >>> { i ** 2 for i in range ( 10 )} { 0 , 1 , 64 , 4 , 36 , 9 , 16 , 49 , 81 , 25 } Module collections Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Le module collections contient d'autres types de containers qui peuvent se r\u00e9v\u00e9ler utiles, c'est une v\u00e9ritable mine d'or ! Nous n'aborderons pas tous ces objets ici, mais nous pouvons citer tout de m\u00eame certains d'entre eux si vous souhaitez aller un peu plus loin : les dictionnaires ordonn\u00e9s qui se comportent comme les dictionnaires classiques mais qui sont ordonn\u00e9s ; les defaultdicts permettant de g\u00e9n\u00e9rer des valeurs par d\u00e9faut quand on demande une cl\u00e9 qui n'existe pas (cela \u00e9vite que Python g\u00e9n\u00e8re une erreur) ; les compteurs dont un exemple est montr\u00e9 ci-dessous ; les namedtuples que nous \u00e9voquerons au chapitre 19 Avoir la classe avec les objets. L'objet collection.Counter() est particuli\u00e8rement int\u00e9ressant et simple \u00e0 utiliser. Il cr\u00e9e des compteurs \u00e0 partir d'objets it\u00e9rables, par exemple : 1 2 3 4 5 6 7 8 9 10 >>> import collections >>> compo_seq = collections . Counter ( \"aatctccgatcgatcgatcgatgatc\" ) >>> compo_seq Counter ({ 'a' : 7 , 't' : 7 , 'c' : 7 , 'g' : 5 }) >>> type ( compo_seq ) < class ' collections . Counter '> >>> compo_seq [ \"a\" ] 7 >>> compo_seq [ \"n\" ] 0 On voit que Python a automatiquement compt\u00e9 chaque atgc de la cha\u00eene de caract\u00e8res pass\u00e9e en argument ! Cela cr\u00e9e un objet de type Counterqui se comporte ensuite comme un dictionnaire, \u00e0 une exception pr\u00e8s : si on appelle une cl\u00e9 qui n'existe pas dans l'it\u00e9rable initiale (comme le n ci-dessus) cela renvoie 0.","title":"Dictionnaires, tuples et sets"},{"location":"bts-sio-1/python/collections/#dictionnaires-tuples-et-sets","text":"Jusqu'\u00e0 maintenant nous avons vu et manipul\u00e9 le type d'objet s\u00e9quentiel le plus classique : les listes. On se rappelle qu'elles sont modifiables, ordonn\u00e9es et it\u00e9rables. Dans ce chapitre nous allons voir trois nouveaux types d'objet s\u00e9quentiel avec des propri\u00e9t\u00e9s diff\u00e9rentes : les dictionnaires, les tuples et les sets. Remarque Les objets s\u00e9quentiels peuvent \u00eatre aussi appel\u00e9s parfois containers.","title":"Dictionnaires, tuples et sets"},{"location":"bts-sio-1/python/collections/#dictionnaires","text":"","title":"Dictionnaires"},{"location":"bts-sio-1/python/collections/#definition","text":"Les dictionnaires se r\u00e9v\u00e8lent tr\u00e8s pratiques lorsque vous devez manipuler des structures complexes \u00e0 d\u00e9crire et que les listes pr\u00e9sentent leurs limites. Les dictionnaires sont des collections non ordonn\u00e9es d'objets, c'est-\u00e0-dire qu'il n'y a pas de notion d'ordre (i.e. pas d'indice). On acc\u00e8de aux valeurs d'un dictionnaire par des cl\u00e9s. Ceci semble un peu confus ? Regardez l'exemple suivant : 1 2 3 4 5 6 >>> ani1 = {} >>> ani1 [ \"nom\" ] = \"girafe\" >>> ani1 [ \"taille\" ] = 5.0 >>> ani1 [ \"poids\" ] = 1100 >>> ani1 { 'nom' : 'girafe' , 'taille' : 5.0 , 'poids' : 1100 } En premier, on d\u00e9finit un dictionnaire vide avec les accolades {} (tout comme on peut le faire pour les listes avec []). Ensuite, on remplit le dictionnaire avec diff\u00e9rentes cl\u00e9s (\"nom\", \"taille\", \"poids\") auxquelles on affecte des valeurs (\"girafe\", 5.0, 1100). Vous pouvez mettre autant de cl\u00e9s que vous voulez dans un dictionnaire (tout comme vous pouvez ajouter autant d'\u00e9l\u00e9ments que vous voulez dans une liste). Remarque Un dictionnaire est affich\u00e9 sans ordre particulier. On peut aussi initialiser toutes les cl\u00e9s et les valeurs d'un dictionnaire en une seule op\u00e9ration : 1 >>> ani2 = { \"nom\" : \"singe\" , \"poids\" : 70 , \"taille\" : 1.75 } Mais rien ne nous emp\u00eache d'ajouter une cl\u00e9 et une valeur suppl\u00e9mentaire : 1 >>> ani2 [ \"age\" ] = 15 Pour r\u00e9cup\u00e9rer la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e, il suffit d'utiliser la syntaxe suivante dictionnaire[\"cle\"]. Par exemple : 1 2 >>> ani1 [ \"taille\" ] 5.0 Remarque Toutes les cl\u00e9s de dictionnaire utilis\u00e9es jusqu'\u00e0 pr\u00e9sent \u00e9taient des cha\u00eenes de caract\u00e8res. Rien n'emp\u00eache d'utiliser d'autres types d'objets comme des entiers (voire m\u00eame des tuples, cf. rubrique suivante), cela peut parfois s'av\u00e9rer tr\u00e8s utile. N\u00e9anmoins, nous vous conseillons, autant que possible, d'utiliser syst\u00e9matiquement des cha\u00eenes de caract\u00e8res pour vos cl\u00e9s de dictionnaire. Apr\u00e8s ce premier tour d'horizon, on voit tout de suite l'avantage des dictionnaires. Pouvoir retrouver des \u00e9l\u00e9ments par des noms (cl\u00e9s) plut\u00f4t que par des indices. Les humains retiennent mieux les noms que les chiffres. Ainsi, l'usage des dictionnaires rend en g\u00e9n\u00e9ral le code plus lisible. Par exemple, si nous souhaitions stocker les coordonn\u00e9es (x,y,z) d'un point dans l'espace : coors = [0, 1, 2] pour la version liste, coors = {\"x\": 0, \"y\": 1, \"z\": 2} pour la version dictionnaire. Un lecteur comprendra tout de suite que coors[\"z\"] contient la coordonn\u00e9e z , ce sera moins intuitif avec coors[2].","title":"D\u00e9finition"},{"location":"bts-sio-1/python/collections/#iteration-sur-les-cles-pour-obtenir-les-valeurs","text":"Il est possible d'obtenir toutes les valeurs d'un dictionnaire \u00e0 partir de ses cl\u00e9s : 1 2 3 4 5 6 7 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> for key in ani2 : ... print ( key , ani2 [ key ]) ... poids 70 nom singe taille 1.75","title":"It\u00e9ration sur les cl\u00e9s pour obtenir les valeurs"},{"location":"bts-sio-1/python/collections/#methodes-keys-values-et-items","text":"Les m\u00e9thodes .keys() et .values() renvoient, comme vous pouvez vous en doutez, les cl\u00e9s et les valeurs d'un dictionnaire : 1 2 3 4 >>> ani2 . keys () dict_keys ([ 'poids' , 'nom' , 'taille' ]) >>> ani2 . values () dict_values ([ 70 , 'singe' , 1.75 ]) Les mentions dict_keys et dict_values indiquent que nous avons \u00e0 faire \u00e0 des objets un peu particuliers. Ils ne sont pas indexables (on ne peut pas retrouver un \u00e9l\u00e9ment par indice, par exemple dico.keys()[0] renverra une erreur). Si besoin, nous pouvons les transformer en liste avec la fonction list() : 1 2 3 4 >>> ani2 . values () dict_values ([ 'singe' , 70 , 1.75 ]) >>> list ( ani2 . values ()) [ 'singe' , 70 , 1.75 ] Toutefois, ce sont des objets \u00ab it\u00e9rables \u00bb, donc utilisables dans une boucle. Enfin, il existe la m\u00e9thode .items() qui renvoie un nouvel objet dict_items : 1 2 3 >>> dico = { 0 : \"t\" , 1 : \"o\" , 2 : \"t\" , 3 : \"o\" } >>> dico . items () dict_items ([( 0 , 't' ), ( 1 , 'o' ), ( 2 , 't' ), ( 3 , 'o' )]) Celui-ci n'est pas indexable (on ne peut pas retrouver un \u00e9l\u00e9ment par un indice) mais il est it\u00e9rable : 1 2 3 4 5 6 7 8 9 10 11 >>> dico . items ()[ 2 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'dict_items' object is not subscriptable >>> for key , val in dico . items (): ... print ( key , val ) ... 0 t 1 o 2 t 3 o Notez la syntaxe particuli\u00e8re qui ressemble \u00e0 la fonction enumerate() vue au chapitre 5 Boucles et comparaisons. On it\u00e8re \u00e0 la fois sur key et sur val. On verra plus bas que cela peut-\u00eatre utile pour construire des dictionnaires de compr\u00e9hension.","title":"M\u00e9thodes .keys(), .values() et .items()"},{"location":"bts-sio-1/python/collections/#existence-dune-cle","text":"Pour v\u00e9rifier si une cl\u00e9 existe dans un dictionnaire, on peut utiliser le test d\u2019appartenance avec l'instruction in qui renvoie un bool\u00e9en : 1 2 3 4 5 6 7 8 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> if \"poids\" in ani2 : ... print ( \"La cl\u00e9 'poids' existe pour ani2\" ) ... La cl\u00e9 'poids' existe pour ani2 >>> if \"age\" in ani2 : ... print ( \"La cl\u00e9 'age' existe pour ani2\" ) ... Dans le second test (lignes 5 \u00e0 7), le message n'est pas affich\u00e9 car la cl\u00e9 age n'est pas pr\u00e9sente dans le dictionnaire ani2.","title":"Existence d'une cl\u00e9"},{"location":"bts-sio-1/python/collections/#methode-get","text":"La m\u00e9thode .get() extrait la valeur associ\u00e9e \u00e0 une cl\u00e9 mais ne renvoie pas d'erreur si la cl\u00e9 n'existe pas : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> ani2 . get ( \"nom\" ) 'singe' >>> ani2 . get ( \"age\" ) >>> Ici la valeur associ\u00e9e \u00e0 la cl\u00e9 nom est singe mais la cl\u00e9 age n'existe pas. On peut \u00e9galement indiquer \u00e0 .get() une valeur par d\u00e9faut si la cl\u00e9 n'existe pas : 1 2 >>> ani2 . get ( \"age\" , 42 ) 42","title":"M\u00e9thode .get()"},{"location":"bts-sio-1/python/collections/#tri-par-cles","text":"On peut utiliser la fonction sorted() vue pr\u00e9c\u00e9demment avec les listes pour trier un dictionnaire par ses cl\u00e9s : 1 2 3 >>> ani2 = { 'nom' : 'singe' , 'taille' : 1.75 , 'poids' : 70 } >>> sorted ( ani2 ) [ 'nom' , 'poids' , 'taille' ] Les cl\u00e9s sont tri\u00e9es ici par ordre alphab\u00e9tique.","title":"Tri par cl\u00e9s"},{"location":"bts-sio-1/python/collections/#tri-par-valeurs","text":"Pour trier un dictionnaire par ses valeurs, il faut utiliser la fonction sorted avec l'argument key : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get ) [ 'b' , 'a' , 'c' ] L'argument key=dico.get indique explicitement qu'il faut r\u00e9aliser le tri par les valeurs du dictionnaire. On retrouve la m\u00e9thode .get() vue plus haut, mais sans les parenth\u00e8ses (key=dico.get mais pas key=dico.get()). Attention, ce sont les cl\u00e9s du dictionnaires qui sont renvoy\u00e9es, pas les valeurs. Ces cl\u00e9s sont cependant renvoy\u00e9es dans un ordre qui permet d'obtenir les cl\u00e9s tri\u00e9es par ordre croissant : 1 2 3 4 5 6 7 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> for key in sorted ( dico , key = dico . get ): ... print ( key , dico [ key ]) ... b 5 a 15 c 20 Enfin, l'argument reverse=True fonctionne \u00e9galement : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get , reverse = True ) [ 'c' , 'a' , 'b' ] Remarque Lorsqu'on trie un dictionnaire par ses valeurs, il faut \u00eatre s\u00fbr que cela soit possible. Ce n'est, par exemple, pas le cas pour le dictionnaire ani2 car les valeurs sont des valeurs num\u00e9riques et une cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> sorted ( ani2 , key = ani2 . get ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' On obtient ici une erreur car Python ne sait pas comparer une cha\u00eene de caract\u00e8res (singe) avec des valeurs num\u00e9riques (70 et 1.75).","title":"Tri par valeurs"},{"location":"bts-sio-1/python/collections/#cle-associee-au-minimum-ou-au-maximum-des-valeurs","text":"Les fonctions min() et max(), que vous avez d\u00e9j\u00e0 manipul\u00e9es dans les chapitres pr\u00e9c\u00e9dents, acceptent \u00e9galement l'argument key=. On peut ainsi obtenir la cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs d'un dictionnaire : 1 2 3 4 5 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> max ( dico , key = dico . get ) 'c' >>> min ( dico , key = dico . get ) 'b'","title":"Cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs"},{"location":"bts-sio-1/python/collections/#liste-de-dictionnaires","text":"En cr\u00e9ant une liste de dictionnaires qui poss\u00e8dent les m\u00eames cl\u00e9s, on obtient une structure qui ressemble \u00e0 une base de donn\u00e9es : 1 2 3 4 5 6 7 8 9 10 >>> animaux = [ ani1 , ani2 ] >>> animaux [{ 'nom' : 'girafe' , 'poids' : 1100 , 'taille' : 5.0 }, { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 }] >>> >>> for ani in animaux : ... print ( ani [ \"nom\" ]) ... girafe singe Vous constatez ainsi que les dictionnaires permettent de g\u00e9rer des structures complexes de mani\u00e8re plus explicite que les listes.","title":"Liste de dictionnaires"},{"location":"bts-sio-1/python/collections/#fonction-dict","text":"Conseil Pour les d\u00e9butants vous pouvez sauter cette rubrique. La fonction dict() va convertir l'argument qui lui est pass\u00e9 en dictionnaire. Il s'agit donc d'une fonction de casting comme int(), str(), etc. Toutefois, l'argument qui lui est pass\u00e9 doit avoir une forme particuli\u00e8re : un objet s\u00e9quentiel contenant d'autres objets s\u00e9quentiels de 2 \u00e9l\u00e9ments. Par exemple, une liste de listes de 2 \u00e9l\u00e9ments : 1 2 3 >>> liste_animaux = [[ \"girafe\" , 2 ], [ \"singe\" , 3 ]] >>> dict ( liste_animaux ) { 'girafe' : 2 , 'singe' : 3 } Ou un tuple de tuples de 2 \u00e9l\u00e9ments (cf. rubrique suivante pour la d\u00e9finition d'un tuple), ou encore une combinaison liste / tuple : 1 2 3 4 5 6 >>> tuple_animaux = (( \"girafe\" , 2 ), ( \"singe\" , 3 )) >>> dict ( tuple_animaux ) { 'girafe' : 2 , 'singe' : 3 } >>> >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 )]) { 'girafe' : 2 , 'singe' : 3 } Si un des sous-\u00e9l\u00e9ments a plus de 2 \u00e9l\u00e9ments (ou moins), Python renvoie une erreur : 1 2 3 4 >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 , 4 )]) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : dictionary update sequence element #1 has length 3; 2 is required","title":"Fonction dict()"},{"location":"bts-sio-1/python/collections/#tuples","text":"","title":"Tuples"},{"location":"bts-sio-1/python/collections/#definition_1","text":"Les tuples (\u00ab n-uplets \u00bb en fran\u00e7ais) correspondent aux listes \u00e0 la diff\u00e9rence qu'ils sont non modifiables. On a vu dans le chapitre 11 Plus sur les listes que les listes pouvaient \u00eatre modifi\u00e9es par r\u00e9f\u00e9rences, notamment lors de la copie de listes. Les tuples s'affranchissent de ce probl\u00e8me puisqu'ils sont non modifiables. Pratiquement, ils utilisent les parenth\u00e8ses au lieu des crochets : 1 2 3 4 5 6 7 8 9 10 11 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x [ 2 ] 3 >>> x [ 0 : 2 ] ( 1 , 2 ) >>> x [ 2 ] = 15 Traceback ( innermost last ): File \"<stdin>\" , line 1 , in ? TypeError : object doesn 't support item assignment L'affectation et l'indi\u00e7age fonctionnent comme avec les listes. Mais si on essaie de modifier un des \u00e9l\u00e9ments du tuple, Python renvoie un message d'erreur. Si vous voulez ajouter un \u00e9l\u00e9ment (ou le modifier), vous devez cr\u00e9er un autre tuple : 1 2 3 >>> x = ( 1 , 2 , 3 ) >>> x + ( 2 ,) ( 1 , 2 , 3 , 2 ) Remarque Pour utiliser un tuple d'un seul \u00e9l\u00e9ment, vous devez utiliser une syntaxe avec une virgule (element,), ceci pour \u00e9viter une ambigu\u00eft\u00e9 avec une simple expression. Autre particularit\u00e9 des tuples, il est possible d'en cr\u00e9er de nouveaux sans les parenth\u00e8ses, d\u00e8s lors que ceci ne pose pas d'ambigu\u00eft\u00e9 avec une autre expression : 1 2 3 4 5 6 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x = 1 , 2 , 3 >>> x ( 1 , 2 , 3 ) Toutefois, nous vous conseillons d'utiliser syst\u00e9matiquement les parenth\u00e8ses afin d'\u00e9viter les confusions. Enfin, on peut utiliser la fonction tuple(sequence) qui fonctionne exactement comme la fonction list(), c'est-\u00e0-dire qu'elle prend en argument un objet s\u00e9quentiel et renvoie le tuple correspondant (op\u00e9ration de casting) : 1 2 3 4 >>> tuple ([ 1 , 2 , 3 ]) ( 1 , 2 , 3 ) >>> tuple ( \"ATGCCGCGAT\" ) ( 'A' , 'T' , 'G' , 'C' , 'C' , 'G' , 'C' , 'G' , 'A' , 'T' ) Remarque Les listes, les dictionnaires et les tuples sont des objets qui peuvent contenir des collections d'autres objets. On peut donc construire des listes qui contiennent des dictionnaires, des tuples ou d'autres listes, mais aussi des dictionnaires contenant des tuples, des listes, etc.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/collections/#iterations-sur-plusieurs-valeurs-a-la-fois","text":"Pratiquement, nous avons d\u00e9j\u00e0 crois\u00e9 les tuples avec la fonction enumerate() dans le chapitre 5 Boucles et comparaisons. Cette derni\u00e8re permettait d'it\u00e9rer en m\u00eame temps sur les indices et les \u00e9l\u00e9ments d'une liste : 1 2 3 4 5 6 7 8 9 10 11 12 >>> for i , elt in enumerate ([ 75 , - 75 , 0 ]): ... print ( i , elt ) ... 0 75 1 - 75 2 0 >>> for obj in enumerate ([ 75 , - 75 , 0 ]): ... print ( obj , type ( obj )) ... ( 0 , 75 ) < class ' tuple '> ( 1 , - 75 ) < class ' tuple '> ( 2 , 0 ) < class ' tuple '> En fin de compte, la fonction enumerate() it\u00e8re sur une s\u00e9rie de tuples. Pouvoir s\u00e9parer i et elt dans la boucle est possible du fait que Python autorise l'affectation multiple du style i, elt = 0, 75 (cf. rubrique suivante). Dans le m\u00eame ordre d'id\u00e9e, nous avons vu \u00e0 la rubrique pr\u00e9c\u00e9dente la m\u00e9thode .dict_items() qui permettait d'it\u00e9rer sur des couples cl\u00e9 / valeur d'un dictionnaire : 1 2 3 4 5 6 7 8 9 10 11 >>> dico = { \"pinson\" : 2 , \"merle\" : 3 } >>> for key , val in dico . items (): ... print ( key , val ) ... pinson 2 merle 3 >>> for obj in dico . items (): ... print ( obj , type ( obj )) ... ( 'pinson' , 2 ) < class ' tuple '> ( 'merle' , 3 ) < class ' tuple '> On voit que cette m\u00e9thode .dict_items() it\u00e8re comme enumerate() sur une s\u00e9rie de tuples. Sur la m\u00eame base, on peut finalement it\u00e9rer sur 3 valeurs en m\u00eame temps \u00e0 partir d'une liste de tuples de 3 \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 9 >>> liste = [( i , i + 1 , i + 2 ) for i in range ( 5 , 8 )] >>> liste [( 5 , 6 , 7 ), ( 6 , 7 , 8 ), ( 7 , 8 , 9 )] >>> for x , y , z in liste : ... print ( x , y , z ) ... 5 6 7 6 7 8 7 8 9 On pourrait concevoir la m\u00eame chose sur 4 \u00e9l\u00e9ments, ou finalement autant que l'on veut. La seule restriction est d'avoir une correspondance syst\u00e9matique entre le nombre de variables d'it\u00e9ration (par exemple 3 ci-dessus avec x, y, z) et la longueur de chaque sous-tuple de la liste sur laquelle on it\u00e8re (chaque sous-tuple a 3 \u00e9l\u00e9ments ci-dessus).","title":"It\u00e9rations sur plusieurs valeurs \u00e0 la fois"},{"location":"bts-sio-1/python/collections/#affectation-multiple-et-le-nom-de-variable-_","text":"L'affectation multiple est un m\u00e9canisme tr\u00e8s puissant et important en Python. Pour rappel, il permet d'effectuer sur une m\u00eame ligne plusieurs affectations en m\u00eame temps, par exemple : x, y, z = 1, 2, 3. On voit que cette syntaxe correspond \u00e0 un tuple de chaque c\u00f4t\u00e9 de l'op\u00e9rateur =. Notez qu'il serait possible de le faire \u00e9galement avec les listes : [x, y, z] = [1, 2, 3]. Toutefois, cette syntaxe est alourdie par la pr\u00e9sence des crochets. On pr\u00e9f\u00e8rera donc la premi\u00e8re syntaxe avec les tuples sans parenth\u00e8se. Remarque Nous avons appel\u00e9 l'op\u00e9ration x, y, z = 1, 2, 3 affectation multiple pour signifier que l'on affectait des valeurs \u00e0 plusieurs variables en m\u00eame temps. Toutefois, vous pourrez rencontrer aussi l'expression tuple unpacking que l'on pourrait traduire par \u00ab d\u00e9sempaquetage de tuple \u00bb. Cela signifie que l'on d\u00e9compose le tuple initial 1, 2, 3 en 3 variables diff\u00e9rentes (comme si on vidait son sac \u00e0 dos, d'o\u00f9 le terme d\u00e9sempaquetage !). Nous avions crois\u00e9 l'importance de l'affectation multiple dans le chapitre 9 Fonctions lorsqu'une fonction renvoyait plusieurs valeurs. 1 2 3 4 5 6 >>> def fct (): ... return 3 , 14 ... >>> x , y = fct () >>> print ( x , y ) 3 14 La syntaxe x, y = fct() permet de r\u00e9cup\u00e9rer les 2 valeurs renvoy\u00e9es par la fonction et de les affecter \u00e0 la vol\u00e9e dans 2 variables diff\u00e9rentes. Cela \u00e9vite l'op\u00e9ration laborieuse de r\u00e9cup\u00e9rer d'abord le tuple, puis de cr\u00e9er les variables en utilisant l'indi\u00e7age : 1 2 3 4 5 6 7 >>> resultat = fct () >>> resultat ( 3 , 14 ) >>> x = resultat [ 0 ] >>> y = resultat [ 1 ] >>> print ( x , y ) 3 14 Conseils Lorsqu'une fonction renvoie plusieurs valeurs sous forme de tuple, ce sera bien s\u00fbr la forme x, y = fct() qui sera privil\u00e9gi\u00e9e. Quand une fonction renvoie plusieurs valeurs mais que l'on ne souhaite pas les utiliser toutes dans la suite du code, on peut utiliser le nom de variable _ (underscore) pour indiquer que certaines valeurs ne nous int\u00e9ressent pas : 1 2 3 4 5 6 7 8 >>> def fct (): ... return 1 , 2 , 3 , 4 ... >>> x , _ , y , _ = fct () >>> x 1 >>> y 3 Cela envoie le message \u00e0 celui qui lit le code \u00ab je me fiche des valeurs r\u00e9cup\u00e9r\u00e9es dans ces variables _ \u00bb. Notez que l'on peut utiliser une ou plusieurs variables underscores(s). Dans l'exemple ci-dessus, la 2\u00e8me et la 4\u00e8me variable renvoy\u00e9es par la fonction seront ignor\u00e9es dans la suite du code. Cela a le m\u00e9rite d'\u00e9viter la cr\u00e9ation de variables dont on ne se sert pas. Remarque La variable _ a une autre signication sp\u00e9ciale dans l'interpr\u00e9teur interactif, elle prend automatiquement la derni\u00e8re valeur affich\u00e9e : 1 2 3 4 5 6 7 8 >>> 3 3 >>> _ 3 >>> \"m\u00e9sange\" 'm\u00e9sange' >>> _ 'm\u00e9sange' Attention, cela n'est vrai que dans l'interpr\u00e9teur. Remarque Le underscore est couramment utilis\u00e9 dans les noms de variable pour s\u00e9parer les mots et \u00eatre explicite, par exemple seq_ADN ou liste_listes_residus. On verra dans le chapitre 15 Bonnes pratiques en programmation Python que ce style de nommage est appel\u00e9 snake_case. Toutefois, il faut \u00e9viter d'utiliser les underscores en d\u00e9but et/ou en fin de nom de variable (e.g. _var , var_ , __var , __var__ ). On verra au chapitre 19 Avoir la classe avec les objets que ces underscores ont une signification particuli\u00e8re.","title":"Affectation multiple et le nom de variable _"},{"location":"bts-sio-1/python/collections/#sets","text":"Les containers de type set repr\u00e9sentent un autre type d'objet s\u00e9quentiel qui peut se r\u00e9v\u00e9ler tr\u00e8s pratique. Ils ont la particularit\u00e9 d'\u00eatre non modifiables, non ordonn\u00e9s et de ne contenir qu'une seule copie maximum de chaque \u00e9l\u00e9ment. Pour cr\u00e9er un nouveau set on peut utiliser les accolades : 1 2 3 4 5 >>> s = { 1 , 2 , 3 , 3 } >>> s { 1 , 2 , 3 } >>> type ( s ) < class ' set '> Notez que la r\u00e9p\u00e9tition du 3 dans la d\u00e9finition du set en ligne 1 donne au final un seul 3 car chaque \u00e9l\u00e9ment ne peut \u00eatre pr\u00e9sent qu'une seule fois. A quoi diff\u00e9rencie-t-on un set d'un dictionnaire alors que les deux utilisent des accolades ? Le set sera d\u00e9fini seulement par des valeurs {val1, val2, ...} alors que le dictionnaire aura toujours des couples cl\u00e9/valeur {cl\u00e91: val1, cl\u00e92: val2, ...}. En g\u00e9n\u00e9ral, on utilisera la fonction interne \u00e0 Python set() pour g\u00e9n\u00e9rer un nouveau set. Celle-ci prend en argument n'importe quel objet it\u00e9rable et le convertit en set (op\u00e9ration de casting) : 1 2 3 4 5 6 7 8 9 10 11 12 >>> set ([ 1 , 2 , 4 , 1 ]) { 1 , 2 , 4 } >>> set (( 2 , 2 , 2 , 1 )) { 1 , 2 } >>> set ( range ( 5 )) { 0 , 1 , 2 , 3 , 4 } >>> set ({ \"cl\u00e91\" : 1 , \"cl\u00e92\" : 2 }) { 'cl\u00e91' , 'cl\u00e92' } >>> set ([ \"ti\" , \"to\" , \"to\" ]) { 'ti' , 'to' } >>> set ( \"Ma\u00eetre corbeau sur un arbre perch\u00e9\" ) { 'h' , 'u' , 'o' , 'b' , ' ' , 'M' , 'a' , 'p' , 'n' , 'e' , '\u00e9' , 'c' , '\u00ee' , 's' , 't' , 'r' } Nous avons dit plus haut que les sets ne sont pas ordonn\u00e9s, il est donc impossible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment par sa position. Il est \u00e9galement impossible de modifier un de ses \u00e9l\u00e9ments. Par contre, les sets sont it\u00e9rables : 1 2 3 4 5 6 7 8 9 10 11 >>> s = set ([ 1 , 2 , 4 , 1 ]) >>> s [ 1 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object is not subscriptable >>> for elt in s : ... print ( elt ) ... 1 2 4 Les containers de type set sont tr\u00e8s utiles pour rechercher les \u00e9l\u00e9ments uniques d'une suite d'\u00e9l\u00e9ments. Cela revient \u00e0 \u00e9liminer tous les doublons. Par exemple : 1 2 3 4 5 6 >>> import random as rd >>> l = [ rd . randint ( 0 , 9 ) for i in range ( 10 )] >>> l [ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ] >>> set ( l ) { 3 , 5 , 6 , 7 , 8 , 9 } On peut bien s\u00fbr transformer dans l'autre sens un set en liste. Cela permet par exemple d'\u00e9liminer les doublons de la liste initiale tout en r\u00e9cup\u00e9rant une liste \u00e0 la fin : 1 2 >>> list ( set ([ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ])) [ 3 , 5 , 6 , 7 , 8 , 9 ] On peut faire des choses tr\u00e8s puissantes. Par exemple, un compteur de lettres en combinaison avec une liste de compr\u00e9hension, le tout en une ligne ! 1 2 3 4 5 >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> set ( seq ) { 'c' , 'g' , 't' , 'a' } >>> [( base , seq . count ( base )) for base in set ( seq )] [( 'c' , 15 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'a' , 10 )] Les sets permettent aussi l'\u00e9valuation d'union ou d'intersection math\u00e9matiques en conjonction avec les op\u00e9rateurs respectivement | et & : 1 2 3 4 5 6 >>> l = [ 3 , 3 , 5 , 1 , 3 , 4 , 1 , 1 , 4 , 4 ] >>> l2 = [ 3 , 0 , 5 , 3 , 3 , 1 , 1 , 1 , 2 , 2 ] >>> set ( l ) & set ( l2 ) { 1 , 3 , 5 } >>> set ( l ) | set ( l2 ) { 0 , 1 , 2 , 3 , 4 , 5 } Conseils Pour aller plus loin, vous pouvez consulter deux articles sur les sites programiz et towardsdatascience.","title":"Sets"},{"location":"bts-sio-1/python/collections/#dictionnaires-et-sets-de-comprehension","text":"Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Nous avons vu au chapitre 11 Plus sur les listes les listes de compr\u00e9hension. Il est \u00e9galement possible de g\u00e9n\u00e9rer des dictionnaires de compr\u00e9hension : 1 2 3 4 5 6 7 8 9 10 11 12 >>> dico = { \"a\" : 10 , \"g\" : 10 , \"t\" : 11 , \"c\" : 15 } >>> dico . items () dict_items ([( 'a' , 10 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'c' , 15 )]) >>> { key : val * 2 for key , val in dico . items ()} { 'a' : 20 , 'g' : 20 , 't' : 22 , 'c' : 30 } >>> >>> { key : val for key , val in enumerate ( \"toto\" )} { 0 : 't' , 1 : 'o' , 2 : 't' , 3 : 'o' } >>> >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> { base : seq . count ( base ) for base in set ( seq )} { 'a' : 10 , 'g' : 10 , 't' : 11 , 'c' : 15 } De mani\u00e8re g\u00e9n\u00e9rale, tout objet sur lequel on peut faire une double it\u00e9ration du type for var1, var2 in obj est utilisable pour cr\u00e9er un dictionnaire de compr\u00e9hension. Si vous souhaitez aller plus loin, vous pouvez consulter cet article sur le site Datacamp. Il est \u00e9galement possible de g\u00e9n\u00e9rer des sets de compr\u00e9hension sur le m\u00eame mod\u00e8le que les listes de compr\u00e9hension : 1 2 3 4 >>> { i for i in range ( 10 )} { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } >>> { i ** 2 for i in range ( 10 )} { 0 , 1 , 64 , 4 , 36 , 9 , 16 , 49 , 81 , 25 }","title":"Dictionnaires et sets de compr\u00e9hension"},{"location":"bts-sio-1/python/collections/#module-collections","text":"Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Le module collections contient d'autres types de containers qui peuvent se r\u00e9v\u00e9ler utiles, c'est une v\u00e9ritable mine d'or ! Nous n'aborderons pas tous ces objets ici, mais nous pouvons citer tout de m\u00eame certains d'entre eux si vous souhaitez aller un peu plus loin : les dictionnaires ordonn\u00e9s qui se comportent comme les dictionnaires classiques mais qui sont ordonn\u00e9s ; les defaultdicts permettant de g\u00e9n\u00e9rer des valeurs par d\u00e9faut quand on demande une cl\u00e9 qui n'existe pas (cela \u00e9vite que Python g\u00e9n\u00e8re une erreur) ; les compteurs dont un exemple est montr\u00e9 ci-dessous ; les namedtuples que nous \u00e9voquerons au chapitre 19 Avoir la classe avec les objets. L'objet collection.Counter() est particuli\u00e8rement int\u00e9ressant et simple \u00e0 utiliser. Il cr\u00e9e des compteurs \u00e0 partir d'objets it\u00e9rables, par exemple : 1 2 3 4 5 6 7 8 9 10 >>> import collections >>> compo_seq = collections . Counter ( \"aatctccgatcgatcgatcgatgatc\" ) >>> compo_seq Counter ({ 'a' : 7 , 't' : 7 , 'c' : 7 , 'g' : 5 }) >>> type ( compo_seq ) < class ' collections . Counter '> >>> compo_seq [ \"a\" ] 7 >>> compo_seq [ \"n\" ] 0 On voit que Python a automatiquement compt\u00e9 chaque atgc de la cha\u00eene de caract\u00e8res pass\u00e9e en argument ! Cela cr\u00e9e un objet de type Counterqui se comporte ensuite comme un dictionnaire, \u00e0 une exception pr\u00e8s : si on appelle une cl\u00e9 qui n'existe pas dans l'it\u00e9rable initiale (comme le n ci-dessus) cela renvoie 0.","title":"Module collections"},{"location":"bts-sio-1/python/fichiers/","text":"Fichiers Lecture dans un fichier Une grande partie de l'information en Data Science est stock\u00e9e dans des fichiers. Pour traiter cette information, vous devez le plus souvent lire ou \u00e9crire dans un ou plusieurs fichiers. Python poss\u00e8de pour cela de nombreux outils qui vous simplifient la vie. M\u00e9thode .readlines() Avant de passer \u00e0 un exemple concret, cr\u00e9ez un fichier dans un \u00e9diteur de texte que vous enregistrerez dans votre r\u00e9pertoire courant avec le nom zoo.txt et le contenu suivant : 1 2 3 4 girafe tigre singe souris Ensuite, testez le code suivant dans l'interpr\u00e9teur Python : ````python {.line-numbers} filin = open(\"zoo.txt\", \"r\") filin <_io.TextIOWrapper name='zoo.txt' mode='r' encoding='UTF-8'> filin.readlines() ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] filin.close() filin.readlines() Traceback (most recent call last): File \" \", line 1, in ValueError: I/O operation on closed file. ```` Il y a plusieurs commentaires \u00e0 faire sur cet exemple : Ligne 1. L'instruction open() ouvre le fichier zoo.txt . Ce fichier est ouvert en lecture seule, comme l'indique le second argument r (pour read ) de la fonction open() . Remarquez que le fichier n'est pas encore lu, mais simplement ouvert (un peu comme lorsqu'on ouvre un livre, mais qu'on ne l'a pas encore lu). Le curseur de lecture est pr\u00eat \u00e0 lire le premier caract\u00e8re du fichier. L'instruction open(\"zoo.txt\", \"r\") suppose que le fichier zoo.txt est dans le r\u00e9pertoire depuis lequel l'interpr\u00e9teur Python a \u00e9t\u00e9 lanc\u00e9. Si ce n'est pas le cas, il faut pr\u00e9ciser le chemin d'acc\u00e8s au fichier. Par exemple, /home/pierre/zoo.txt pour Linux ou Mac OS X ou C:\\Users\\pierre\\zoo.txt pour Windows . Ligne 2. Lorsqu'on affiche le contenu de la variable filin, on se rend compte que Python la consid\u00e8re comme un objet de type fichier ouvert (ligne 3). Ligne 4. Nous utilisons \u00e0 nouveau la syntaxe objet.m\u00e9thode() . Ici la m\u00e9thode .readlines() agit sur l'objet filin en d\u00e9pla\u00e7ant le curseur de lecture du d\u00e9but \u00e0 la fin du fichier, puis elle renvoie une liste contenant toutes les lignes du fichier (dans notre analogie avec un livre, ceci correspondrait \u00e0 lire toutes les lignes du livre). Ligne 6. Enfin, on applique la m\u00e9thode .close() sur l'objet filin , ce qui, vous vous en doutez, ferme le fichier (ceci correspondrait \u00e0 fermer le livre). Vous remarquerez que la m\u00e9thode .close() ne renvoie rien mais modifie l'\u00e9tat de l'objet filin en fichier ferm\u00e9. Ainsi, si on essaie de lire \u00e0 nouveau les lignes du fichier, Python renvoie une erreur car il ne peut pas lire un fichier ferm\u00e9 (lignes 7 \u00e0 10). Voici maintenant un exemple complet de lecture d'un fichier avec Python . ```python filin = open(\"zoo.txt\", \"r\") lignes = filin.readlines() lignes ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] for ligne in lignes: ... print(ligne) ... girafe tigre singe souris filin.close() ``` Vous voyez qu'en cinq lignes de code, vous avez lu, parcouru le fichier et affich\u00e9 son contenu. Remarque Chaque \u00e9l\u00e9ment de la liste lignes est une cha\u00eene de caract\u00e8res. C'est en effet sous forme de cha\u00eenes de caract\u00e8res que Python lit le contenu d'un fichier. Chaque \u00e9l\u00e9ment de la liste lignes se termine par le caract\u00e8re \\n . Ce caract\u00e8re un peu particulier correspond au \u00ab saut de ligne \u00bb qui permet de passer d'une ligne \u00e0 la suivante. Ceci est cod\u00e9 par un caract\u00e8re sp\u00e9cial que l'on repr\u00e9sente par \\n . Par d\u00e9faut, l'instruction print() affiche quelque chose puis revient \u00e0 la ligne. Ce retour \u00e0 la ligne d\u00fb \u00e0 print() se cumule alors avec celui de la fin de ligne ( \\n ) de chaque ligne du fichier et donne l'impression qu'une ligne est saut\u00e9e \u00e0 chaque fois. Il existe en Python le mot-cl\u00e9 with qui permet d'ouvrir et de fermer un fichier de mani\u00e8re efficace. Si pour une raison ou une autre l'ouverture ou la lecture du fichier conduit \u00e0 une erreur, l'utilisation de with garantit la bonne fermeture du fichier, ce qui n'est pas le cas dans le code pr\u00e9c\u00e9dent. Voici donc le m\u00eame exemple avec with : ```python with open(\"zoo.txt\", 'r') as filin: ... lignes = filin.readlines() ... for ligne in lignes: ... print(ligne) ... girafe tigre singe souris ``` Remarque L'instruction with introduit un bloc d'indentation. C'est \u00e0 l'int\u00e9rieur de ce bloc que nous effectuons toutes les op\u00e9rations sur le fichier. Une fois sorti du bloc d'indentation, Python fermera automatiquement le fichier. Vous n'avez donc plus besoin d\u2019utiliser la m\u00e9thode .close() . M\u00e9thode .read() Il existe d'autres m\u00e9thodes que .readlines() pour lire (et manipuler) un fichier. Par exemple, la m\u00e9thode .read() lit tout le contenu d'un fichier et renvoie une cha\u00eene de caract\u00e8res unique. ```python with open(\"zoo.txt\", \"r\") as filin: ... filin.read() ... 'girafe\\ntigre\\nsinge\\nsouris\\n' ``` M\u00e9thode .readline() La m\u00e9thode .readline() (sans s \u00e0 la fin) lit une ligne d'un fichier et la renvoie sous forme de cha\u00eene de caract\u00e8res. \u00c0 chaque nouvel appel de .readline() , la ligne suivante est renvoy\u00e9e. Associ\u00e9e \u00e0 la boucle while , cette m\u00e9thode permet de lire un fichier ligne par ligne. ```python with open(\"zoo.txt\", \"r\") as filin: ... ligne = filin.readline() ... while ligne != \"\": ... print(ligne) ... ligne = filin.readline() ... girafe tigre singe souris ``` It\u00e9rations directe sur le fichier Python essaie de vous faciliter la vie au maximum. Voici un moyen \u00e0 la fois simple et \u00e9l\u00e9gant de parcourir un fichier. ```python with open(\"zoo.txt\", \"r\") as filin: ... for ligne in filin: ... print(ligne) ... girafe tigre singe souris ``` L'objet filin est \u00ab it\u00e9rable \u00bb, ainsi la boucle for va demander \u00e0 Python d'aller lire le fichier ligne par ligne. Conseils Privil\u00e9giez cette m\u00e9thode par la suite. Remarque Les m\u00e9thodes abord\u00e9es pr\u00e9c\u00e9demment permettent d'acc\u00e9der au contenu d'un fichier, soit ligne par ligne (m\u00e9thode .readline() ), soit globalement en une seule cha\u00eene de caract\u00e8res (m\u00e9thode .read() ), soit globalement avec les lignes diff\u00e9renci\u00e9es sous forme d'une liste de cha\u00eenes de caract\u00e8res (m\u00e9thode .readlines() ). Il est \u00e9galement possible en Python de se rendre \u00e0 un endroit particulier d'un fichier avec la m\u00e9thode .seek() mais qui sort du cadre de cet ouvrage. \u00c9criture dans un fichier \u00c9crire dans un fichier est aussi simple que de le lire. Voyez l'exemple suivant : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(animal) ... 7 7 4 ``` Quelques commentaires sur cet exemple : Ligne 1. Cr\u00e9ation d'une liste de cha\u00eenes de caract\u00e8res animaux2 . Ligne 2. Ouverture du fichier zoo2.txt en mode \u00e9criture, avec le caract\u00e8re w pour write . L'instruction with cr\u00e9e un bloc d'instructions qui doit \u00eatre indent\u00e9. Ligne 3. Parcours de la liste animaux2 avec une boucle for . Ligne 4. \u00c0 chaque it\u00e9ration de la boucle, nous avons \u00e9crit chaque \u00e9l\u00e9ment de la liste dans le fichier. La m\u00e9thode .write() s'applique sur l'objet filout . Notez qu'\u00e0 chaque utilisation de la m\u00e9thode .write() , celle-ci nous affiche le nombre d'octets (\u00e9quivalent au nombre de caract\u00e8res) \u00e9crits dans le fichier (lignes 6 \u00e0 8). Ceci est valable uniquement dans l'interpr\u00e9teur, si vous cr\u00e9ez un programme avec les m\u00eames lignes de code, ces valeurs ne s'afficheront pas \u00e0 l'\u00e9cran. Si nous ouvrons le fichier zoo2.txt avec un \u00e9diteur de texte, voici ce que nous obtenons : poissonabeillechat Ce n'est pas exactement le r\u00e9sultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne. Nous avons oubli\u00e9 d'ajouter le caract\u00e8re fin de ligne apr\u00e8s chaque nom d'animal. Pour ce faire, nous pouvons utiliser l'\u00e9criture format\u00e9e : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(f\"{animal}\\n\") ... 8 8 5 ``` Ligne 4. L'\u00e9criture format\u00e9e permet d'ajouter un retour \u00e0 la ligne ( \\n ) apr\u00e8s le nom de chaque animal. Lignes 6 \u00e0 8. Le nombre d'octets \u00e9crits dans le fichier est augment\u00e9 de 1 par rapport \u00e0 l'exemple pr\u00e9c\u00e9dent car le caract\u00e8re retour \u00e0 la ligne compte pour un seul octet. Le contenu du fichier zoo2.txt est alors : python poisson abeille chat Vous voyez qu'il est extr\u00eamement simple en Python de lire ou d'\u00e9crire dans un fichier. Ouvrir deux fichiers avec l'instruction with On peut avec l'instruction with ouvrir deux fichiers (ou plus) en m\u00eame temps. Voyez l'exemple suivant : python with open(\"zoo.txt\", \"r\") as fichier1, open(\"zoo2.txt\", \"w\") as fichier2: for ligne in fichier1: fichier2.write(\"* \" + ligne) Si le fichier zoo.txt contient le texte suivant : python souris girafe lion singe alors le contenu de zoo2.txt sera : python * souris * girafe * lion * singe Dans cet exemple, with permet une notation tr\u00e8s compacte en s'affranchissant de deux m\u00e9thodes .close() . Sachez que l'instruction with est plus g\u00e9n\u00e9rale et est utilisable dans d'autres contextes.","title":"Fichiers"},{"location":"bts-sio-1/python/fichiers/#fichiers","text":"","title":"Fichiers"},{"location":"bts-sio-1/python/fichiers/#lecture-dans-un-fichier","text":"Une grande partie de l'information en Data Science est stock\u00e9e dans des fichiers. Pour traiter cette information, vous devez le plus souvent lire ou \u00e9crire dans un ou plusieurs fichiers. Python poss\u00e8de pour cela de nombreux outils qui vous simplifient la vie.","title":"Lecture dans un fichier"},{"location":"bts-sio-1/python/fichiers/#methode-readlines","text":"Avant de passer \u00e0 un exemple concret, cr\u00e9ez un fichier dans un \u00e9diteur de texte que vous enregistrerez dans votre r\u00e9pertoire courant avec le nom zoo.txt et le contenu suivant : 1 2 3 4 girafe tigre singe souris Ensuite, testez le code suivant dans l'interpr\u00e9teur Python : ````python {.line-numbers} filin = open(\"zoo.txt\", \"r\") filin <_io.TextIOWrapper name='zoo.txt' mode='r' encoding='UTF-8'> filin.readlines() ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] filin.close() filin.readlines() Traceback (most recent call last): File \" \", line 1, in ValueError: I/O operation on closed file. ```` Il y a plusieurs commentaires \u00e0 faire sur cet exemple : Ligne 1. L'instruction open() ouvre le fichier zoo.txt . Ce fichier est ouvert en lecture seule, comme l'indique le second argument r (pour read ) de la fonction open() . Remarquez que le fichier n'est pas encore lu, mais simplement ouvert (un peu comme lorsqu'on ouvre un livre, mais qu'on ne l'a pas encore lu). Le curseur de lecture est pr\u00eat \u00e0 lire le premier caract\u00e8re du fichier. L'instruction open(\"zoo.txt\", \"r\") suppose que le fichier zoo.txt est dans le r\u00e9pertoire depuis lequel l'interpr\u00e9teur Python a \u00e9t\u00e9 lanc\u00e9. Si ce n'est pas le cas, il faut pr\u00e9ciser le chemin d'acc\u00e8s au fichier. Par exemple, /home/pierre/zoo.txt pour Linux ou Mac OS X ou C:\\Users\\pierre\\zoo.txt pour Windows . Ligne 2. Lorsqu'on affiche le contenu de la variable filin, on se rend compte que Python la consid\u00e8re comme un objet de type fichier ouvert (ligne 3). Ligne 4. Nous utilisons \u00e0 nouveau la syntaxe objet.m\u00e9thode() . Ici la m\u00e9thode .readlines() agit sur l'objet filin en d\u00e9pla\u00e7ant le curseur de lecture du d\u00e9but \u00e0 la fin du fichier, puis elle renvoie une liste contenant toutes les lignes du fichier (dans notre analogie avec un livre, ceci correspondrait \u00e0 lire toutes les lignes du livre). Ligne 6. Enfin, on applique la m\u00e9thode .close() sur l'objet filin , ce qui, vous vous en doutez, ferme le fichier (ceci correspondrait \u00e0 fermer le livre). Vous remarquerez que la m\u00e9thode .close() ne renvoie rien mais modifie l'\u00e9tat de l'objet filin en fichier ferm\u00e9. Ainsi, si on essaie de lire \u00e0 nouveau les lignes du fichier, Python renvoie une erreur car il ne peut pas lire un fichier ferm\u00e9 (lignes 7 \u00e0 10). Voici maintenant un exemple complet de lecture d'un fichier avec Python . ```python filin = open(\"zoo.txt\", \"r\") lignes = filin.readlines() lignes ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] for ligne in lignes: ... print(ligne) ... girafe tigre singe souris filin.close() ``` Vous voyez qu'en cinq lignes de code, vous avez lu, parcouru le fichier et affich\u00e9 son contenu. Remarque Chaque \u00e9l\u00e9ment de la liste lignes est une cha\u00eene de caract\u00e8res. C'est en effet sous forme de cha\u00eenes de caract\u00e8res que Python lit le contenu d'un fichier. Chaque \u00e9l\u00e9ment de la liste lignes se termine par le caract\u00e8re \\n . Ce caract\u00e8re un peu particulier correspond au \u00ab saut de ligne \u00bb qui permet de passer d'une ligne \u00e0 la suivante. Ceci est cod\u00e9 par un caract\u00e8re sp\u00e9cial que l'on repr\u00e9sente par \\n . Par d\u00e9faut, l'instruction print() affiche quelque chose puis revient \u00e0 la ligne. Ce retour \u00e0 la ligne d\u00fb \u00e0 print() se cumule alors avec celui de la fin de ligne ( \\n ) de chaque ligne du fichier et donne l'impression qu'une ligne est saut\u00e9e \u00e0 chaque fois. Il existe en Python le mot-cl\u00e9 with qui permet d'ouvrir et de fermer un fichier de mani\u00e8re efficace. Si pour une raison ou une autre l'ouverture ou la lecture du fichier conduit \u00e0 une erreur, l'utilisation de with garantit la bonne fermeture du fichier, ce qui n'est pas le cas dans le code pr\u00e9c\u00e9dent. Voici donc le m\u00eame exemple avec with : ```python with open(\"zoo.txt\", 'r') as filin: ... lignes = filin.readlines() ... for ligne in lignes: ... print(ligne) ... girafe tigre singe souris ``` Remarque L'instruction with introduit un bloc d'indentation. C'est \u00e0 l'int\u00e9rieur de ce bloc que nous effectuons toutes les op\u00e9rations sur le fichier. Une fois sorti du bloc d'indentation, Python fermera automatiquement le fichier. Vous n'avez donc plus besoin d\u2019utiliser la m\u00e9thode .close() .","title":"M\u00e9thode .readlines()"},{"location":"bts-sio-1/python/fichiers/#methode-read","text":"Il existe d'autres m\u00e9thodes que .readlines() pour lire (et manipuler) un fichier. Par exemple, la m\u00e9thode .read() lit tout le contenu d'un fichier et renvoie une cha\u00eene de caract\u00e8res unique. ```python with open(\"zoo.txt\", \"r\") as filin: ... filin.read() ... 'girafe\\ntigre\\nsinge\\nsouris\\n' ```","title":"M\u00e9thode .read()"},{"location":"bts-sio-1/python/fichiers/#methode-readline","text":"La m\u00e9thode .readline() (sans s \u00e0 la fin) lit une ligne d'un fichier et la renvoie sous forme de cha\u00eene de caract\u00e8res. \u00c0 chaque nouvel appel de .readline() , la ligne suivante est renvoy\u00e9e. Associ\u00e9e \u00e0 la boucle while , cette m\u00e9thode permet de lire un fichier ligne par ligne. ```python with open(\"zoo.txt\", \"r\") as filin: ... ligne = filin.readline() ... while ligne != \"\": ... print(ligne) ... ligne = filin.readline() ... girafe tigre singe souris ```","title":"M\u00e9thode .readline()"},{"location":"bts-sio-1/python/fichiers/#iterations-directe-sur-le-fichier","text":"Python essaie de vous faciliter la vie au maximum. Voici un moyen \u00e0 la fois simple et \u00e9l\u00e9gant de parcourir un fichier. ```python with open(\"zoo.txt\", \"r\") as filin: ... for ligne in filin: ... print(ligne) ... girafe tigre singe souris ``` L'objet filin est \u00ab it\u00e9rable \u00bb, ainsi la boucle for va demander \u00e0 Python d'aller lire le fichier ligne par ligne. Conseils Privil\u00e9giez cette m\u00e9thode par la suite. Remarque Les m\u00e9thodes abord\u00e9es pr\u00e9c\u00e9demment permettent d'acc\u00e9der au contenu d'un fichier, soit ligne par ligne (m\u00e9thode .readline() ), soit globalement en une seule cha\u00eene de caract\u00e8res (m\u00e9thode .read() ), soit globalement avec les lignes diff\u00e9renci\u00e9es sous forme d'une liste de cha\u00eenes de caract\u00e8res (m\u00e9thode .readlines() ). Il est \u00e9galement possible en Python de se rendre \u00e0 un endroit particulier d'un fichier avec la m\u00e9thode .seek() mais qui sort du cadre de cet ouvrage.","title":"It\u00e9rations directe sur le fichier"},{"location":"bts-sio-1/python/fichiers/#ecriture-dans-un-fichier","text":"\u00c9crire dans un fichier est aussi simple que de le lire. Voyez l'exemple suivant : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(animal) ... 7 7 4 ``` Quelques commentaires sur cet exemple : Ligne 1. Cr\u00e9ation d'une liste de cha\u00eenes de caract\u00e8res animaux2 . Ligne 2. Ouverture du fichier zoo2.txt en mode \u00e9criture, avec le caract\u00e8re w pour write . L'instruction with cr\u00e9e un bloc d'instructions qui doit \u00eatre indent\u00e9. Ligne 3. Parcours de la liste animaux2 avec une boucle for . Ligne 4. \u00c0 chaque it\u00e9ration de la boucle, nous avons \u00e9crit chaque \u00e9l\u00e9ment de la liste dans le fichier. La m\u00e9thode .write() s'applique sur l'objet filout . Notez qu'\u00e0 chaque utilisation de la m\u00e9thode .write() , celle-ci nous affiche le nombre d'octets (\u00e9quivalent au nombre de caract\u00e8res) \u00e9crits dans le fichier (lignes 6 \u00e0 8). Ceci est valable uniquement dans l'interpr\u00e9teur, si vous cr\u00e9ez un programme avec les m\u00eames lignes de code, ces valeurs ne s'afficheront pas \u00e0 l'\u00e9cran. Si nous ouvrons le fichier zoo2.txt avec un \u00e9diteur de texte, voici ce que nous obtenons : poissonabeillechat Ce n'est pas exactement le r\u00e9sultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne. Nous avons oubli\u00e9 d'ajouter le caract\u00e8re fin de ligne apr\u00e8s chaque nom d'animal. Pour ce faire, nous pouvons utiliser l'\u00e9criture format\u00e9e : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(f\"{animal}\\n\") ... 8 8 5 ``` Ligne 4. L'\u00e9criture format\u00e9e permet d'ajouter un retour \u00e0 la ligne ( \\n ) apr\u00e8s le nom de chaque animal. Lignes 6 \u00e0 8. Le nombre d'octets \u00e9crits dans le fichier est augment\u00e9 de 1 par rapport \u00e0 l'exemple pr\u00e9c\u00e9dent car le caract\u00e8re retour \u00e0 la ligne compte pour un seul octet. Le contenu du fichier zoo2.txt est alors : python poisson abeille chat Vous voyez qu'il est extr\u00eamement simple en Python de lire ou d'\u00e9crire dans un fichier.","title":"\u00c9criture dans un fichier"},{"location":"bts-sio-1/python/fichiers/#ouvrir-deux-fichiers-avec-linstruction-with","text":"On peut avec l'instruction with ouvrir deux fichiers (ou plus) en m\u00eame temps. Voyez l'exemple suivant : python with open(\"zoo.txt\", \"r\") as fichier1, open(\"zoo2.txt\", \"w\") as fichier2: for ligne in fichier1: fichier2.write(\"* \" + ligne) Si le fichier zoo.txt contient le texte suivant : python souris girafe lion singe alors le contenu de zoo2.txt sera : python * souris * girafe * lion * singe Dans cet exemple, with permet une notation tr\u00e8s compacte en s'affranchissant de deux m\u00e9thodes .close() . Sachez que l'instruction with est plus g\u00e9n\u00e9rale et est utilisable dans d'autres contextes.","title":"Ouvrir deux fichiers avec l'instruction with"},{"location":"bts-sio-1/python/fonction/","text":"Fonctions Principe et g\u00e9n\u00e9ralit\u00e9s En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions . D\u00e9finition Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat. Passage d'arguments Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre. Renvoi de r\u00e9sultats Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes. Arguments positionnels et arguments par mot-cl\u00e9 Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant : d\u00e9finition d'une fonction carre() def carre(x): y = x**2 return y programme principal z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"Fonctions"},{"location":"bts-sio-1/python/fonction/#fonctions","text":"","title":"Fonctions"},{"location":"bts-sio-1/python/fonction/#principe-et-generalites","text":"En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions .","title":"Principe et g\u00e9n\u00e9ralit\u00e9s"},{"location":"bts-sio-1/python/fonction/#definition","text":"Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/fonction/#passage-darguments","text":"Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre.","title":"Passage d'arguments"},{"location":"bts-sio-1/python/fonction/#renvoi-de-resultats","text":"Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes.","title":"Renvoi de r\u00e9sultats"},{"location":"bts-sio-1/python/fonction/#arguments-positionnels-et-arguments-par-mot-cle","text":"Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant :","title":"Arguments positionnels et arguments par mot-cl\u00e9"},{"location":"bts-sio-1/python/fonction/#definition-dune-fonction-carre","text":"def carre(x): y = x**2 return y","title":"d\u00e9finition d'une fonction carre()"},{"location":"bts-sio-1/python/fonction/#programme-principal","text":"z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"programme principal"},{"location":"bts-sio-1/python/listes/","text":"Listes D\u00e9finition Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie. Utilisation Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus ! Op\u00e9ration sur les listes Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes. Indi\u00e7age n\u00e9gatif La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] . Tranches Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] . Fonction len() L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8 Les fonctions range() et list() L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] Listes de listes Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler. Minimum, maximum et somme d'une liste Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Listes"},{"location":"bts-sio-1/python/listes/#listes","text":"","title":"Listes"},{"location":"bts-sio-1/python/listes/#definition","text":"Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/listes/#utilisation","text":"Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus !","title":"Utilisation"},{"location":"bts-sio-1/python/listes/#operation-sur-les-listes","text":"Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes.","title":"Op\u00e9ration sur les listes"},{"location":"bts-sio-1/python/listes/#indicage-negatif","text":"La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] .","title":"Indi\u00e7age n\u00e9gatif"},{"location":"bts-sio-1/python/listes/#tranches","text":"Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] .","title":"Tranches"},{"location":"bts-sio-1/python/listes/#fonction-len","text":"L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8","title":"Fonction len()"},{"location":"bts-sio-1/python/listes/#les-fonctions-range-et-list","text":"L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ]","title":"Les fonctions range() et list()"},{"location":"bts-sio-1/python/listes/#listes-de-listes","text":"Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler.","title":"Listes de listes"},{"location":"bts-sio-1/python/listes/#minimum-maximum-et-somme-dune-liste","text":"Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Minimum, maximum et somme d'une liste"},{"location":"bts-sio-1/python/tests/","text":"Tests D\u00e9finition Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb. Tests \u00e0 plusieurs cas Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if . Importance de l'indentation De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb . Tests multiples Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False Instructions break et continue Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4 Tests de valeur sur des floats Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests"},{"location":"bts-sio-1/python/tests/#tests","text":"","title":"Tests"},{"location":"bts-sio-1/python/tests/#definition","text":"Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/tests/#tests-a-plusieurs-cas","text":"Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if .","title":"Tests \u00e0 plusieurs cas"},{"location":"bts-sio-1/python/tests/#importance-de-lindentation","text":"De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb .","title":"Importance de l'indentation"},{"location":"bts-sio-1/python/tests/#tests-multiples","text":"Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False","title":"Tests multiples"},{"location":"bts-sio-1/python/tests/#instructions-break-et-continue","text":"Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4","title":"Instructions break et continue"},{"location":"bts-sio-1/python/tests/#tests-de-valeur-sur-des-floats","text":"Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests de valeur sur des floats"},{"location":"cybersecurite/authentification_principes/","text":"Les principes de l'authentification Introduction Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter. Objectif de l'authentification Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages. OBJECTIFS Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts. Facteurs de l'authentification OBJECTIFS L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e. 1 FACTEUR = AUTHENTIFICATION SIMPLE L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple. PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe. Limites des facteurs d'authentification LA BIOM\u00c9TRIE De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons. LIMITES DE LA BIOM\u00c9TRIE Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place . EXEMPLE EN BELGIQUE Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes. Les risques li\u00e9s aux mots de passe Pr\u00e9sentation Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques . Divulgation M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance. N\u00e9gligeance On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection . Malveillance La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9. Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours. Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ; Conclusion L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Les principes de l'authentification"},{"location":"cybersecurite/authentification_principes/#les-principes-de-lauthentification","text":"","title":"Les principes de l'authentification"},{"location":"cybersecurite/authentification_principes/#introduction","text":"Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter.","title":"Introduction"},{"location":"cybersecurite/authentification_principes/#objectif-de-lauthentification","text":"Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages.","title":"Objectif de l'authentification"},{"location":"cybersecurite/authentification_principes/#objectifs","text":"Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts.","title":"OBJECTIFS"},{"location":"cybersecurite/authentification_principes/#facteurs-de-lauthentification","text":"","title":"Facteurs de l'authentification"},{"location":"cybersecurite/authentification_principes/#objectifs_1","text":"L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e.","title":"OBJECTIFS"},{"location":"cybersecurite/authentification_principes/#1-facteur-authentification-simple","text":"L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple.","title":"1 FACTEUR = AUTHENTIFICATION SIMPLE"},{"location":"cybersecurite/authentification_principes/#plusieurs-facteurs-authentification-forte","text":"Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe.","title":"PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE"},{"location":"cybersecurite/authentification_principes/#limites-des-facteurs-dauthentification","text":"","title":"Limites des facteurs d'authentification"},{"location":"cybersecurite/authentification_principes/#la-biometrie","text":"De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons.","title":"LA BIOM\u00c9TRIE"},{"location":"cybersecurite/authentification_principes/#limites-de-la-biometrie","text":"Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place .","title":"LIMITES DE LA BIOM\u00c9TRIE"},{"location":"cybersecurite/authentification_principes/#exemple-en-belgique","text":"Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes.","title":"EXEMPLE EN BELGIQUE"},{"location":"cybersecurite/authentification_principes/#les-risques-lies-aux-mots-de-passe","text":"","title":"Les risques li\u00e9s aux mots de passe"},{"location":"cybersecurite/authentification_principes/#presentation","text":"Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques .","title":"Pr\u00e9sentation"},{"location":"cybersecurite/authentification_principes/#divulgation","text":"M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance.","title":"Divulgation"},{"location":"cybersecurite/authentification_principes/#negligeance","text":"On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection .","title":"N\u00e9gligeance"},{"location":"cybersecurite/authentification_principes/#malveillance","text":"La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9.","title":"Malveillance"},{"location":"cybersecurite/authentification_principes/#ces-differentes-causes-de-divulgation-seront-abordees-en-detail-dans-la-suite-de-ce-cours","text":"Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ;","title":"Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours."},{"location":"cybersecurite/authentification_principes/#conclusion","text":"L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Conclusion"},{"location":"cybersecurite/rgpd/","text":"Qu'est-ce que le RGPD ? Le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es ou RGPD remplace l'ensemble de la l\u00e9gislation sur les donn\u00e9es nominatives issue de la loi de 1978. Le RGPD, c\u2019est avant tout une d\u00e9marche \u00e0 suivre. Voici les quelques axes principaux : \u00eatre responsable de son traitement de donn\u00e9es , des objectifs et des moyens que celui-ci implique ; faire la liste des traitements de donn\u00e9es ; trier les donn\u00e9es et identifier les risques ; respecter les droits des personnes ; s\u00e9curiser les donn\u00e9es ; tout documenter . L\u2019utilisation digitale du marketing pose \u00e0 chaque fois la question des donn\u00e9es personnelles. C\u2019est le cas des statistiques ou du profilage des internautes. Sans revenir en d\u00e9tail sur l'int\u00e9gralit\u00e9 de cette r\u00e8gle, il convient de comprendre son fonctionnement et son impact pour la cr\u00e9ation et l'utilisation de supports marketing ou de communication. La RDGP et l\u2019accountability Contrairement aux dispositions pr\u00e9c\u00e9dentes, le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es supprime les obligations de d\u00e9claration pr\u00e9alable et met en responsabilit\u00e9 chaque annonceur. Note En un mot, vous devez y penser avant de commencer votre projet. Vous ne d\u00e9clarez plus rien mais \u00eates responsable de votre action. Le cadre de l'application du RGPD n'est plus d\u00e9claratif, mais il vous appartient de rapporter la preuve de la conformit\u00e9 de la gestion des donn\u00e9es personnelles et de la s\u00e9curit\u00e9 de celles-ci. En cas de contr\u00f4le des autorit\u00e9s, il vous faudra justifier de ces points de fa\u00e7on document\u00e9e. C\u2019est ce que la CNIL appelle l\u2019 accountability . Selon elle, c\u2019est \u00ab l\u2019obligation pour les entreprises de mettre en \u0153uvre des m\u00e9canismes et des proc\u00e9dures internes permettant de d\u00e9montrer le respect des r\u00e8gles relatives \u00e0 la protection des donn\u00e9es. \u00bb Quels sont ces m\u00e9canismes et proc\u00e9dures ? Vous pourrez alors trouver dans la loi, qu\u2019il \u00ab est imp\u00e9ratif de d\u00e9signer un pilote et d'assurer : la cartographie des traitements de donn\u00e9es personnelles les actions correctives \u00e0 mener en fonction de l'issue de l'\u00e9tablissement de la cartographie la gestion des risques les processus permettant d'assurer la s\u00e9curit\u00e9 les droits et libert\u00e9s des personnes concern\u00e9es la d\u00e9finition du risque et documenter l'ensemble des mesures de mise en conformit\u00e9 au RGPD que vous avez effectu\u00e9es. \u00bb Articles 24 et 30 r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016, modifi\u00e9s par Rectificatif au r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016 relatif \u00e0 la protection des personnes physiques \u00e0 l\u2019\u00e9gard du traitement des donn\u00e9es \u00e0 caract\u00e8re personnel et \u00e0 la libre circulation de ces donn\u00e9es, et abrogeant la directive 95/46/CE (r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es) JOUE L127 2 du 23/05/2018) Cela peut vous para\u00eetre contraignant, mais c\u2019est l\u2019occasion d\u2019une v\u00e9rification g\u00e9n\u00e9rale . Par o\u00f9 commencer ? Pour vous aider dans cette d\u00e9marche, la CNIL fournit les supports et un logiciel gratuit (PIA) pour analyser votre projet. Consultez le . D\u00e9couvrez la notion de \"Privacy by design\"","title":"Qu'est-ce que le RGPD ?"},{"location":"cybersecurite/rgpd/#quest-ce-que-le-rgpd","text":"Le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es ou RGPD remplace l'ensemble de la l\u00e9gislation sur les donn\u00e9es nominatives issue de la loi de 1978. Le RGPD, c\u2019est avant tout une d\u00e9marche \u00e0 suivre. Voici les quelques axes principaux : \u00eatre responsable de son traitement de donn\u00e9es , des objectifs et des moyens que celui-ci implique ; faire la liste des traitements de donn\u00e9es ; trier les donn\u00e9es et identifier les risques ; respecter les droits des personnes ; s\u00e9curiser les donn\u00e9es ; tout documenter . L\u2019utilisation digitale du marketing pose \u00e0 chaque fois la question des donn\u00e9es personnelles. C\u2019est le cas des statistiques ou du profilage des internautes. Sans revenir en d\u00e9tail sur l'int\u00e9gralit\u00e9 de cette r\u00e8gle, il convient de comprendre son fonctionnement et son impact pour la cr\u00e9ation et l'utilisation de supports marketing ou de communication.","title":"Qu'est-ce que le RGPD ?"},{"location":"cybersecurite/rgpd/#la-rdgp-et-laccountability","text":"Contrairement aux dispositions pr\u00e9c\u00e9dentes, le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es supprime les obligations de d\u00e9claration pr\u00e9alable et met en responsabilit\u00e9 chaque annonceur. Note En un mot, vous devez y penser avant de commencer votre projet. Vous ne d\u00e9clarez plus rien mais \u00eates responsable de votre action. Le cadre de l'application du RGPD n'est plus d\u00e9claratif, mais il vous appartient de rapporter la preuve de la conformit\u00e9 de la gestion des donn\u00e9es personnelles et de la s\u00e9curit\u00e9 de celles-ci. En cas de contr\u00f4le des autorit\u00e9s, il vous faudra justifier de ces points de fa\u00e7on document\u00e9e. C\u2019est ce que la CNIL appelle l\u2019 accountability . Selon elle, c\u2019est \u00ab l\u2019obligation pour les entreprises de mettre en \u0153uvre des m\u00e9canismes et des proc\u00e9dures internes permettant de d\u00e9montrer le respect des r\u00e8gles relatives \u00e0 la protection des donn\u00e9es. \u00bb","title":"La RDGP et l\u2019accountability"},{"location":"cybersecurite/rgpd/#quels-sont-ces-mecanismes-et-procedures","text":"Vous pourrez alors trouver dans la loi, qu\u2019il \u00ab est imp\u00e9ratif de d\u00e9signer un pilote et d'assurer : la cartographie des traitements de donn\u00e9es personnelles les actions correctives \u00e0 mener en fonction de l'issue de l'\u00e9tablissement de la cartographie la gestion des risques les processus permettant d'assurer la s\u00e9curit\u00e9 les droits et libert\u00e9s des personnes concern\u00e9es la d\u00e9finition du risque et documenter l'ensemble des mesures de mise en conformit\u00e9 au RGPD que vous avez effectu\u00e9es. \u00bb Articles 24 et 30 r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016, modifi\u00e9s par Rectificatif au r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016 relatif \u00e0 la protection des personnes physiques \u00e0 l\u2019\u00e9gard du traitement des donn\u00e9es \u00e0 caract\u00e8re personnel et \u00e0 la libre circulation de ces donn\u00e9es, et abrogeant la directive 95/46/CE (r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es) JOUE L127 2 du 23/05/2018) Cela peut vous para\u00eetre contraignant, mais c\u2019est l\u2019occasion d\u2019une v\u00e9rification g\u00e9n\u00e9rale . Par o\u00f9 commencer ? Pour vous aider dans cette d\u00e9marche, la CNIL fournit les supports et un logiciel gratuit (PIA) pour analyser votre projet. Consultez le .","title":"Quels sont ces m\u00e9canismes et proc\u00e9dures ?"},{"location":"cybersecurite/rgpd/#decouvrez-la-notion-de-privacy-by-design","text":"","title":"D\u00e9couvrez la notion de \"Privacy by design\""}]}