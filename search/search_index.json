{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BTS SIO R\u00e9f\u00e9rentiel Documentaire","title":"Home"},{"location":"#bts-sio-referentiel-documentaire","text":"","title":"BTS SIO R\u00e9f\u00e9rentiel Documentaire"},{"location":"bts-sio-1/python/boucles/","text":"Boucles et comparaisons Boucles for Principe En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3 Fonction range() Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps ! Nommage de la variable d'it\u00e9ration Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]: It\u00e9ration sur les indices Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Comparaisons Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus. Boucles while Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles et comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-et-comparaisons","text":"","title":"Boucles et comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-for","text":"","title":"Boucles for"},{"location":"bts-sio-1/python/boucles/#principe","text":"En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3","title":"Principe"},{"location":"bts-sio-1/python/boucles/#fonction-range","text":"Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps !","title":"Fonction range()"},{"location":"bts-sio-1/python/boucles/#nommage-de-la-variable-diteration","text":"Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]:","title":"Nommage de la variable d'it\u00e9ration"},{"location":"bts-sio-1/python/boucles/#iteration-sur-les-indices","text":"Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris","title":"It\u00e9ration sur les indices"},{"location":"bts-sio-1/python/boucles/#comparaisons","text":"Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus.","title":"Comparaisons"},{"location":"bts-sio-1/python/boucles/#boucles-while","text":"Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles while"},{"location":"bts-sio-1/python/chaines/","text":"Plus sur les cha\u00eenes de caract\u00e8res Cha\u00eenes de caract\u00e8res et listes Les cha\u00eenes de caract\u00e8res peuvent \u00eatre consid\u00e9r\u00e9es comme des listes (de caract\u00e8res) un peu particuli\u00e8res : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux 'girafe tigre' >>> len ( animaux ) 12 >>> animaux [ 3 ] 'a' Nous pouvons donc utiliser certaines propri\u00e9t\u00e9s des listes comme les tranches : 1 2 3 4 5 6 7 8 9 >>> animaux = \"girafe tigre\" >>> animaux [ 0 : 4 ] 'gira' >>> animaux [ 9 :] 'gre' >>> animaux [: - 2 ] 'girafe tig' >>> animaux [ 1 : - 2 : 2 ] 'iaetg' Mais a contrario des listes, les cha\u00eenes de caract\u00e8res pr\u00e9sentent toutefois une diff\u00e9rence notable, ce sont des listes non modifiables. Une fois une cha\u00eene de caract\u00e8res d\u00e9finie, vous ne pouvez plus modifier un de ses \u00e9l\u00e9ments. Le cas \u00e9ch\u00e9ant, Python renvoie un message d'erreur : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux [ 4 ] 'f' >>> animaux [ 4 ] = \"F\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Par cons\u00e9quent, si vous voulez modifier une cha\u00eene de caract\u00e8res, vous devez en construire une nouvelle. Pour cela, n'oubliez pas que les op\u00e9rateurs de concat\u00e9nation (+) et de duplication ( * ) (introduits dans le chapitre 2 Variables) peuvent vous aider. Vous pouvez \u00e9galement g\u00e9n\u00e9rer une liste, qui elle est modifiable, puis revenir \u00e0 une cha\u00eene de caract\u00e8res (voir plus bas). Caract\u00e8res sp\u00e9ciaux Il existe certains caract\u00e8res sp\u00e9ciaux comme \\n que nous avons d\u00e9j\u00e0 vu (pour le retour \u00e0 la ligne). Le caract\u00e8re \\t produit une tabulation. Si vous voulez \u00e9crire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus avec les guillemets de d\u00e9claration de la cha\u00eene de caract\u00e8res, vous pouvez utiliser \\' ou \\\". 1 2 3 4 5 >>> print ( \"Un retour \u00e0 la ligne \\n puis une tabulation \\t puis un guillemet \\\" \" ) Un retour \u00e0 la ligne puis une tabulation puis un guillemet \" >>> print ( 'J \\' affiche un guillemet simple' ) J 'affiche un guillemet simple Vous pouvez aussi utiliser astucieusement des guillemets doubles ou simples pour d\u00e9clarer votre cha\u00eene de caract\u00e8res : 1 2 3 4 >>> print ( \"Un brin d'ADN\" ) Un brin d 'ADN >>> print ( 'Python est un \"super\" langage de programmation' ) Python est un \"super\" langage de programmation Quand on souhaite \u00e9crire un texte sur plusieurs lignes, il est tr\u00e8s commode d'utiliser les guillemets triples qui conservent le formatage (notamment les retours \u00e0 la ligne) : 1 2 3 4 5 6 7 8 9 >>> x = \"\"\"souris ... chat ... abeille\"\"\" >>> x 'souris \\n chat \\n abeille' >>> print ( x ) souris chat abeille Attention, les caract\u00e8res sp\u00e9ciaux n'apparaissent int\u00e9rpr\u00e9t\u00e9s que lorsqu'ils sont utilis\u00e9s avec la fonction print(). Par exemple, le \\n n'apparait comme un saut de ligne que lorsqu'il est dans une cha\u00eene de caract\u00e8res pass\u00e9e \u00e0 la fonction print() : 1 2 3 4 5 >>> \"bla \\n bla\" 'bla \\n bla' >>> print ( \"bla \\n bla\" ) bla bla Pr\u00e9fixe de cha\u00eene de caract\u00e8res Nous avons vu au chapitre 3 la notion de f-string. Il s'agit d'un m\u00e9canisme pour formater du texte au sein d'une cha\u00eene de caract\u00e8res. Par exemple : 1 2 3 >>> var = \"f-string\" >>> f \"voici une belle { var } \" 'voici une belle f-string' Que signifie le f que l'on accole aux guillements de la cha\u00eene de caract\u00e8res ? Celui-ci est appel\u00e9 \u00ab pr\u00e9fixe de cha\u00eene de caract\u00e8res \u00bb ou stringprefix. Remarque Un stringprefix modifie la mani\u00e8re dont Python va interpr\u00e9ter la dite string. Celui-ci doit \u00eatre syst\u00e9matiquement \u00ab coll\u00e9 \u00bb \u00e0 la cha\u00eene de caract\u00e8res, c'est-\u00e0-dire pas d'espace entre les deux. Il existe diff\u00e9rents stringprefixes en Python, nous vous montrons ici les deux qui nous apparaissent les plus importants. 1 Le pr\u00e9fixe r mis pour raw string qui force la non-interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux : 1 2 3 4 5 6 7 8 9 10 11 >>> s = \"Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne Et l\u00e0 une autre ligne >>> s = r \"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\\\ nEt l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne \\ nEt l\u00e0 une autre ligne L'ajout du r va forcer Python \u00e0 ne pas interpr\u00e9ter le \\n comme un retour \u00e0 la ligne, mais comme un backslash litt\u00e9ral suivi d'un n. Quand on demande \u00e0 l'interpr\u00e9teur d'afficher cette cha\u00eene de caract\u00e8res, celui-ci met deux backslashes pour signifier qu'il s'agit d'un backslash litt\u00e9ral (le premier \u00e9chappe le second). Finalement, l'utilisation de la syntaxe r\"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" renvoie une cha\u00eene de caract\u00e8res normale, puisqu'on voit ensuite que le r \u00e0 disparu lorsqu'on demande \u00e0 Python d'afficher le contenu de la variable s. Comme dans var = 2 + 2, d'abord Python \u00e9value 2 + 2 et c'est ce r\u00e9sultat qui est affect\u00e9 \u00e0 la variable var. Enfin, on notera que seule l'utilisation du print() m\u00e8ne \u00e0 l'interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux comme \\n, comme expliqu\u00e9 dans la rubrique pr\u00e9c\u00e9dente. Les caract\u00e8res sp\u00e9ciaux non interpr\u00e9t\u00e9s dans les raw strings sont de mani\u00e8re g\u00e9n\u00e9rale tout ce dont le backslash modifie la signification, par exemple un \\n, un \\t, etc. 1 Le pr\u00e9fixe f mis pour formatted string qui met en place l'\u00e9criture formatt\u00e9e comme vue au chapitre 3 Affichage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animal = \"renard\" >>> animal2 = \"poulain\" >>> s = f \"Le { animal } est un animal gentil \\n Le { animal2 } aussi\" >>> s 'Le renard est un animal gentil \\n Le poulain aussi' >>> print ( s ) Le renard est un animal gentil Le poulain aussi >>> s = \"Le {animal} est un animal gentil \\n Le {animal2} aussi\" >>> s 'Le {animal} est un animal gentil \\n Le {animal2} aussi' >>> print ( s ) Le { animal } est un animal gentil Le { animal2 } aussi La f-string remplace le contenu des variables situ\u00e9es entre les accolades et interpr\u00e8te le \\n comme un retour \u00e0 la ligne. Pour rappel, consultez le chapitre 3 si vous souhaitez plus de d\u00e9tails sur le fonctionnement des f-strings. Conseils Il existe de nombreux autres d\u00e9tails concernant les pr\u00e9fixes qui vont au del\u00e0 de ce cours. Pour en savoir plus, vous pouvez consulter la documentations officielle. 10.5 M\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res Voici quelques m\u00e9thodes sp\u00e9cifiques aux objets de type str : 1 2 3 4 5 6 7 >>> x = \"girafe\" >>> x . upper () 'GIRAFE' >>> x 'girafe' >>> 'TIGRE' . lower () 'tigre' Les m\u00e9thodes .lower() et .upper() renvoient un texte en minuscule et en majuscule respectivement. On remarque que l'utilisation de ces m\u00e9thodes n'alt\u00e8re pas la cha\u00eene de caract\u00e8res de d\u00e9part mais renvoie une cha\u00eene de caract\u00e8res transform\u00e9e. Pour mettre en majuscule la premi\u00e8re lettre seulement, vous pouvez faire : 1 2 >>> x [ 0 ] . upper () + x [ 1 :] 'Girafe' ou plus simplement utiliser la m\u00e9thode ad\u00e9quate : 1 2 >>> x . capitalize () 'Girafe' Il existe une m\u00e9thode associ\u00e9e aux cha\u00eenes de caract\u00e8res qui est particuli\u00e8rement pratique, la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split () [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> for animal in animaux . split (): ... print ( animal ) ... girafe tigre singe souris La m\u00e9thode .split() d\u00e9coupe une cha\u00eene de caract\u00e8res en plusieurs \u00e9l\u00e9ments appel\u00e9s champs, en utilisant comme s\u00e9parateur n'importe quelle combinaison \u00ab d'espace(s) blanc(s) \u00bb. D\u00e9finition Un espace blanc (whitespace en anglais) correspond aux caract\u00e8res qui sont invisibles \u00e0 l'\u0153il, mais qui occupent de l'espace dans un texte. Les espaces blancs les plus classiques sont l'espace, la tabulation et le retour \u00e0 la ligne. Il est possible de modifier le s\u00e9parateur de champs, par exemple : 1 2 3 >>> animaux = \"girafe:tigre:singe::souris\" >>> animaux . split ( \":\" ) [ 'girafe' , 'tigre' , 'singe' , '' , 'souris' ] Attention, dans cet exemple, le s\u00e9parateur est un seul caract\u00e8res \u00ab : \u00bb (et non pas une combinaison de un ou plusieurs :) conduisant ainsi \u00e0 une cha\u00eene vide entre singe et souris. Il est \u00e9galement int\u00e9ressant d'indiquer \u00e0 .split() le nombre de fois qu'on souhaite d\u00e9couper la cha\u00eene de caract\u00e8res avec l'argument maxsplit : 1 2 3 4 5 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split ( maxsplit = 1 ) [ 'girafe' , 'tigre singe souris' ] >>> animaux . split ( maxsplit = 2 ) [ 'girafe' , 'tigre' , 'singe souris' ] La m\u00e9thode .find(), quant \u00e0 elle, recherche une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 8 9 >>> animal = \"girafe\" >>> animal . find ( \"i\" ) 1 >>> animal . find ( \"afe\" ) 3 >>> animal . find ( \"z\" ) - 1 >>> animal . find ( \"tig\" ) - 1 Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9, alors l'indice du d\u00e9but de l'\u00e9l\u00e9ment dans la cha\u00eene de caract\u00e8res est renvoy\u00e9. Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9, alors la valeur -1 est renvoy\u00e9e. Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9 plusieurs fois, seul l'indice de la premi\u00e8re occurrence est renvoy\u00e9 : 1 2 3 >>> animaux = \"girafe tigre\" >>> animaux . find ( \"i\" ) 1 On trouve aussi la m\u00e9thode .replace() qui substitue une cha\u00eene de caract\u00e8res par une autre : 1 2 3 4 5 >>> animaux = \"girafe tigre\" >>> animaux . replace ( \"tigre\" , \"singe\" ) 'girafe singe' >>> animaux . replace ( \"i\" , \"o\" ) 'gorafe togre' La m\u00e9thode .count() compte le nombre d\u2019occurrences d'une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux . count ( \"i\" ) 2 >>> animaux . count ( \"z\" ) 0 >>> animaux . count ( \"tigre\" ) 1 La m\u00e9thode .startswith() v\u00e9rifie si une cha\u00eene de caract\u00e8res commence par une autre cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> chaine = \"Bonjour monsieur le capitaine !\" >>> chaine . startswith ( \"Bonjour\" ) True >>> chaine . startswith ( \"Au revoir\" ) False Cette m\u00e9thode est particuli\u00e8rement utile lorsqu'on lit un fichier et que l'on veut r\u00e9cup\u00e9rer certaines lignes commen\u00e7ant par un mot-cl\u00e9. Par exemple dans un fichier PDB, les lignes contenant les coordonn\u00e9es des atomes commencent par le mot-cl\u00e9 ATOM. Enfin, la m\u00e9thode .strip() permet de \u00ab nettoyer les bords \u00bb d'une cha\u00eene de caract\u00e8res : 1 2 3 >>> chaine = \" Comment enlever les espaces au d\u00e9but et \u00e0 la fin ? \" >>> chaine . strip () 'Comment enlever les espaces au d\u00e9but et \u00e0 la fin ?' La m\u00e9thode .strip() enl\u00e8ve les espaces situ\u00e9s sur les bords de la cha\u00eene de caract\u00e8re mais pas ceux situ\u00e9s entre des caract\u00e8res visibles. En r\u00e9alit\u00e9, cette m\u00e9thode enl\u00e8ve n'importe quel combinaison \u00ab d'espace(s) blanc(s) \u00bb sur les bords, par exemple : 1 2 3 >>> chaine = \" \\t fonctionne avec les tabulations et les retours \u00e0 la ligne \\n \" >>> chaine . strip () 'fonctionne avec les tabulations et les retours \u00e0 la ligne' La m\u00e9thode .strip() est tr\u00e8s pratique quand on lit un fichier et qu'on veut se d\u00e9barrasser des retours \u00e0 la ligne. Extraction de valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res Une t\u00e2che courante en Python est de lire une cha\u00eene de caract\u00e8res (provenant par exemple d'un fichier), d'extraire des valeurs de cette cha\u00eene de caract\u00e8res pour ensuite les manipuler. On consid\u00e8re par exemple la cha\u00eene de caract\u00e8res val : 1 >>> val = \"3.4 17.2 atom\" On souhaite extraire les valeurs 3.4 et 17.2 pour ensuite les additionner. Dans un premier temps, on d\u00e9coupe la cha\u00eene de caract\u00e8res avec la m\u00e9thode .split() : 1 2 3 >>> val2 = val . split () >>> val2 [ '3.4' , '17.2' , 'atom' ] On obtient alors une liste de cha\u00eenes de caract\u00e8res. On transforme ensuite les deux premiers \u00e9l\u00e9ments de cette liste en floats (avec la fonction float()) pour pouvoir les additionner : 1 2 >>> float ( val2 [ 0 ]) + float ( val2 [ 1 ]) 20.599999999999998 Remarque Retenez bien l'utilisation des instructions pr\u00e9c\u00e9dentes pour extraire des valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res. Elles sont r\u00e9guli\u00e8rement employ\u00e9es pour analyser des donn\u00e9es extraites d'un fichier. 10.7 Conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res On a vu dans le chapitre 2 Variables la conversion d'un type simple (entier, float et cha\u00eene de caract\u00e8res) en un autre avec les fonctions int(), float() et str(). La conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res est particuli\u00e8re puisqu'elle fait appelle \u00e0 la m\u00e9thode .join(). 1 2 3 4 5 6 7 8 9 >>> seq = [ \"A\" , \"T\" , \"G\" , \"A\" , \"T\" ] >>> seq [ 'A' , 'T' , 'G' , 'A' , 'T' ] >>> \"-\" . join ( seq ) 'A-T-G-A-T' >>> \" \" . join ( seq ) 'A T G A T' >>> \"\" . join ( seq ) 'ATGAT' Les \u00e9l\u00e9ments de la liste initiale sont concat\u00e9n\u00e9s les uns \u00e0 la suite des autres et intercal\u00e9s par un s\u00e9parateur qui peut \u00eatre n'importe quelle cha\u00eene de caract\u00e8res. Ici, on a utilis\u00e9 un tiret, un espace et rien (une cha\u00eene de caract\u00e8res vide). Attention, la m\u00e9thode .join() ne s'applique qu'\u00e0 une liste de cha\u00eenes de caract\u00e8res. 1 2 3 4 5 >>> maliste = [ \"A\" , 5 , \"G\" ] >>> \" \" . join ( maliste ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : sequence item 1 : expected string , int found On esp\u00e8re qu'apr\u00e8s ce petit tour d'horizon vous serez convaincu de la richesse des m\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res. Pour avoir une liste exhaustive de l'ensemble des m\u00e9thodes associ\u00e9es \u00e0 une variable particuli\u00e8re, vous pouvez utiliser la fonction dir(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >>> animaux = \"girafe tigre\" >>> dir ( animaux ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '_ _getitem__ ', ' __getnewargs__ ', ' __gt__ ', ' __hash__ ', ' __init__ ', ' _ _init_subclass__ ', ' __iter__ ', ' __le__ ', ' __len__ ', ' __lt__ ', ' __mo d__ ', ' __mul__ ', ' __ne__ ', ' __new__ ', ' __reduce__ ', ' __reduce_ex__ ' , '__repr__' , '__rmod__' , '__rmul__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , 'capitalize' , 'casefold' , 'center' , 'count' , 'encode' , 'endswith' , 'expandtabs' , 'find' , 'format' , 'for mat_map ', ' index ', ' isalnum ', ' isalpha ', ' isdecimal ', ' isdigit ', ' i sidentifier ', ' islower ', ' isnumeric ', ' isprintable ', ' isspace ', ' is title ', ' isupper ', ' join ', ' ljust ', ' lower ', ' lstrip ', ' maketrans ', 'partition' , 'replace' , 'rfind' , 'rindex' , 'rjust' , 'rpartition' , 'rsplit' , 'rstrip' , 'split' , 'splitlines' , 'startswith' , 'strip' , 'swapcase' , 'title' , 'translate' , 'upper' , 'zfill' ] Pour l'instant, vous pouvez ignorer les m\u00e9thodes qui commencent et qui se terminent par deux tirets bas (underscores) __ . Vous pouvez \u00e9galement acc\u00e9der \u00e0 l'aide et \u00e0 la documentation d'une m\u00e9thode particuli\u00e8re avec help(), par exemple pour la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 11 >>> help ( animaux . split ) Help on built - in function split : split ( ... ) S . split ([ sep [, maxsplit ]]) -> list of strings Return a list of the words in the string S , using sep as the delimiter string . If maxsplit is given , at most maxsplit splits are done . If sep is not specified or is None , any whitespace string is a separator . ( END ) Attention \u00e0 ne pas mettre les parenth\u00e8ses \u00e0 la suite du nom de la m\u00e9thode. L'instruction correcte est help(animaux.split) et non pas help(animaux.split()).","title":"Plus sur les cha\u00eenes de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#plus-sur-les-chaines-de-caracteres","text":"","title":"Plus sur les cha\u00eenes de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#chaines-de-caracteres-et-listes","text":"Les cha\u00eenes de caract\u00e8res peuvent \u00eatre consid\u00e9r\u00e9es comme des listes (de caract\u00e8res) un peu particuli\u00e8res : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux 'girafe tigre' >>> len ( animaux ) 12 >>> animaux [ 3 ] 'a' Nous pouvons donc utiliser certaines propri\u00e9t\u00e9s des listes comme les tranches : 1 2 3 4 5 6 7 8 9 >>> animaux = \"girafe tigre\" >>> animaux [ 0 : 4 ] 'gira' >>> animaux [ 9 :] 'gre' >>> animaux [: - 2 ] 'girafe tig' >>> animaux [ 1 : - 2 : 2 ] 'iaetg' Mais a contrario des listes, les cha\u00eenes de caract\u00e8res pr\u00e9sentent toutefois une diff\u00e9rence notable, ce sont des listes non modifiables. Une fois une cha\u00eene de caract\u00e8res d\u00e9finie, vous ne pouvez plus modifier un de ses \u00e9l\u00e9ments. Le cas \u00e9ch\u00e9ant, Python renvoie un message d'erreur : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux [ 4 ] 'f' >>> animaux [ 4 ] = \"F\" Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Par cons\u00e9quent, si vous voulez modifier une cha\u00eene de caract\u00e8res, vous devez en construire une nouvelle. Pour cela, n'oubliez pas que les op\u00e9rateurs de concat\u00e9nation (+) et de duplication ( * ) (introduits dans le chapitre 2 Variables) peuvent vous aider. Vous pouvez \u00e9galement g\u00e9n\u00e9rer une liste, qui elle est modifiable, puis revenir \u00e0 une cha\u00eene de caract\u00e8res (voir plus bas).","title":"Cha\u00eenes de caract\u00e8res et listes"},{"location":"bts-sio-1/python/chaines/#caracteres-speciaux","text":"Il existe certains caract\u00e8res sp\u00e9ciaux comme \\n que nous avons d\u00e9j\u00e0 vu (pour le retour \u00e0 la ligne). Le caract\u00e8re \\t produit une tabulation. Si vous voulez \u00e9crire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus avec les guillemets de d\u00e9claration de la cha\u00eene de caract\u00e8res, vous pouvez utiliser \\' ou \\\". 1 2 3 4 5 >>> print ( \"Un retour \u00e0 la ligne \\n puis une tabulation \\t puis un guillemet \\\" \" ) Un retour \u00e0 la ligne puis une tabulation puis un guillemet \" >>> print ( 'J \\' affiche un guillemet simple' ) J 'affiche un guillemet simple Vous pouvez aussi utiliser astucieusement des guillemets doubles ou simples pour d\u00e9clarer votre cha\u00eene de caract\u00e8res : 1 2 3 4 >>> print ( \"Un brin d'ADN\" ) Un brin d 'ADN >>> print ( 'Python est un \"super\" langage de programmation' ) Python est un \"super\" langage de programmation Quand on souhaite \u00e9crire un texte sur plusieurs lignes, il est tr\u00e8s commode d'utiliser les guillemets triples qui conservent le formatage (notamment les retours \u00e0 la ligne) : 1 2 3 4 5 6 7 8 9 >>> x = \"\"\"souris ... chat ... abeille\"\"\" >>> x 'souris \\n chat \\n abeille' >>> print ( x ) souris chat abeille Attention, les caract\u00e8res sp\u00e9ciaux n'apparaissent int\u00e9rpr\u00e9t\u00e9s que lorsqu'ils sont utilis\u00e9s avec la fonction print(). Par exemple, le \\n n'apparait comme un saut de ligne que lorsqu'il est dans une cha\u00eene de caract\u00e8res pass\u00e9e \u00e0 la fonction print() : 1 2 3 4 5 >>> \"bla \\n bla\" 'bla \\n bla' >>> print ( \"bla \\n bla\" ) bla bla","title":"Caract\u00e8res sp\u00e9ciaux"},{"location":"bts-sio-1/python/chaines/#prefixe-de-chaine-de-caracteres","text":"Nous avons vu au chapitre 3 la notion de f-string. Il s'agit d'un m\u00e9canisme pour formater du texte au sein d'une cha\u00eene de caract\u00e8res. Par exemple : 1 2 3 >>> var = \"f-string\" >>> f \"voici une belle { var } \" 'voici une belle f-string' Que signifie le f que l'on accole aux guillements de la cha\u00eene de caract\u00e8res ? Celui-ci est appel\u00e9 \u00ab pr\u00e9fixe de cha\u00eene de caract\u00e8res \u00bb ou stringprefix. Remarque Un stringprefix modifie la mani\u00e8re dont Python va interpr\u00e9ter la dite string. Celui-ci doit \u00eatre syst\u00e9matiquement \u00ab coll\u00e9 \u00bb \u00e0 la cha\u00eene de caract\u00e8res, c'est-\u00e0-dire pas d'espace entre les deux. Il existe diff\u00e9rents stringprefixes en Python, nous vous montrons ici les deux qui nous apparaissent les plus importants. 1 Le pr\u00e9fixe r mis pour raw string qui force la non-interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux : 1 2 3 4 5 6 7 8 9 10 11 >>> s = \"Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\n Et l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne Et l\u00e0 une autre ligne >>> s = r \"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" >>> s 'Voici un retour \u00e0 la ligne \\\\ nEt l\u00e0 une autre ligne' >>> print ( s ) Voici un retour \u00e0 la ligne \\ nEt l\u00e0 une autre ligne L'ajout du r va forcer Python \u00e0 ne pas interpr\u00e9ter le \\n comme un retour \u00e0 la ligne, mais comme un backslash litt\u00e9ral suivi d'un n. Quand on demande \u00e0 l'interpr\u00e9teur d'afficher cette cha\u00eene de caract\u00e8res, celui-ci met deux backslashes pour signifier qu'il s'agit d'un backslash litt\u00e9ral (le premier \u00e9chappe le second). Finalement, l'utilisation de la syntaxe r\"Voici un retour \u00e0 la ligne\\nEt l\u00e0 une autre ligne\" renvoie une cha\u00eene de caract\u00e8res normale, puisqu'on voit ensuite que le r \u00e0 disparu lorsqu'on demande \u00e0 Python d'afficher le contenu de la variable s. Comme dans var = 2 + 2, d'abord Python \u00e9value 2 + 2 et c'est ce r\u00e9sultat qui est affect\u00e9 \u00e0 la variable var. Enfin, on notera que seule l'utilisation du print() m\u00e8ne \u00e0 l'interpr\u00e9tation des caract\u00e8res sp\u00e9ciaux comme \\n, comme expliqu\u00e9 dans la rubrique pr\u00e9c\u00e9dente. Les caract\u00e8res sp\u00e9ciaux non interpr\u00e9t\u00e9s dans les raw strings sont de mani\u00e8re g\u00e9n\u00e9rale tout ce dont le backslash modifie la signification, par exemple un \\n, un \\t, etc. 1 Le pr\u00e9fixe f mis pour formatted string qui met en place l'\u00e9criture formatt\u00e9e comme vue au chapitre 3 Affichage : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animal = \"renard\" >>> animal2 = \"poulain\" >>> s = f \"Le { animal } est un animal gentil \\n Le { animal2 } aussi\" >>> s 'Le renard est un animal gentil \\n Le poulain aussi' >>> print ( s ) Le renard est un animal gentil Le poulain aussi >>> s = \"Le {animal} est un animal gentil \\n Le {animal2} aussi\" >>> s 'Le {animal} est un animal gentil \\n Le {animal2} aussi' >>> print ( s ) Le { animal } est un animal gentil Le { animal2 } aussi La f-string remplace le contenu des variables situ\u00e9es entre les accolades et interpr\u00e8te le \\n comme un retour \u00e0 la ligne. Pour rappel, consultez le chapitre 3 si vous souhaitez plus de d\u00e9tails sur le fonctionnement des f-strings. Conseils Il existe de nombreux autres d\u00e9tails concernant les pr\u00e9fixes qui vont au del\u00e0 de ce cours. Pour en savoir plus, vous pouvez consulter la documentations officielle. 10.5 M\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res Voici quelques m\u00e9thodes sp\u00e9cifiques aux objets de type str : 1 2 3 4 5 6 7 >>> x = \"girafe\" >>> x . upper () 'GIRAFE' >>> x 'girafe' >>> 'TIGRE' . lower () 'tigre' Les m\u00e9thodes .lower() et .upper() renvoient un texte en minuscule et en majuscule respectivement. On remarque que l'utilisation de ces m\u00e9thodes n'alt\u00e8re pas la cha\u00eene de caract\u00e8res de d\u00e9part mais renvoie une cha\u00eene de caract\u00e8res transform\u00e9e. Pour mettre en majuscule la premi\u00e8re lettre seulement, vous pouvez faire : 1 2 >>> x [ 0 ] . upper () + x [ 1 :] 'Girafe' ou plus simplement utiliser la m\u00e9thode ad\u00e9quate : 1 2 >>> x . capitalize () 'Girafe' Il existe une m\u00e9thode associ\u00e9e aux cha\u00eenes de caract\u00e8res qui est particuli\u00e8rement pratique, la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split () [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> for animal in animaux . split (): ... print ( animal ) ... girafe tigre singe souris La m\u00e9thode .split() d\u00e9coupe une cha\u00eene de caract\u00e8res en plusieurs \u00e9l\u00e9ments appel\u00e9s champs, en utilisant comme s\u00e9parateur n'importe quelle combinaison \u00ab d'espace(s) blanc(s) \u00bb. D\u00e9finition Un espace blanc (whitespace en anglais) correspond aux caract\u00e8res qui sont invisibles \u00e0 l'\u0153il, mais qui occupent de l'espace dans un texte. Les espaces blancs les plus classiques sont l'espace, la tabulation et le retour \u00e0 la ligne. Il est possible de modifier le s\u00e9parateur de champs, par exemple : 1 2 3 >>> animaux = \"girafe:tigre:singe::souris\" >>> animaux . split ( \":\" ) [ 'girafe' , 'tigre' , 'singe' , '' , 'souris' ] Attention, dans cet exemple, le s\u00e9parateur est un seul caract\u00e8res \u00ab : \u00bb (et non pas une combinaison de un ou plusieurs :) conduisant ainsi \u00e0 une cha\u00eene vide entre singe et souris. Il est \u00e9galement int\u00e9ressant d'indiquer \u00e0 .split() le nombre de fois qu'on souhaite d\u00e9couper la cha\u00eene de caract\u00e8res avec l'argument maxsplit : 1 2 3 4 5 >>> animaux = \"girafe tigre singe souris\" >>> animaux . split ( maxsplit = 1 ) [ 'girafe' , 'tigre singe souris' ] >>> animaux . split ( maxsplit = 2 ) [ 'girafe' , 'tigre' , 'singe souris' ] La m\u00e9thode .find(), quant \u00e0 elle, recherche une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 8 9 >>> animal = \"girafe\" >>> animal . find ( \"i\" ) 1 >>> animal . find ( \"afe\" ) 3 >>> animal . find ( \"z\" ) - 1 >>> animal . find ( \"tig\" ) - 1 Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9, alors l'indice du d\u00e9but de l'\u00e9l\u00e9ment dans la cha\u00eene de caract\u00e8res est renvoy\u00e9. Si l'\u00e9l\u00e9ment n'est pas trouv\u00e9, alors la valeur -1 est renvoy\u00e9e. Si l'\u00e9l\u00e9ment recherch\u00e9 est trouv\u00e9 plusieurs fois, seul l'indice de la premi\u00e8re occurrence est renvoy\u00e9 : 1 2 3 >>> animaux = \"girafe tigre\" >>> animaux . find ( \"i\" ) 1 On trouve aussi la m\u00e9thode .replace() qui substitue une cha\u00eene de caract\u00e8res par une autre : 1 2 3 4 5 >>> animaux = \"girafe tigre\" >>> animaux . replace ( \"tigre\" , \"singe\" ) 'girafe singe' >>> animaux . replace ( \"i\" , \"o\" ) 'gorafe togre' La m\u00e9thode .count() compte le nombre d\u2019occurrences d'une cha\u00eene de caract\u00e8res pass\u00e9e en argument : 1 2 3 4 5 6 7 >>> animaux = \"girafe tigre\" >>> animaux . count ( \"i\" ) 2 >>> animaux . count ( \"z\" ) 0 >>> animaux . count ( \"tigre\" ) 1 La m\u00e9thode .startswith() v\u00e9rifie si une cha\u00eene de caract\u00e8res commence par une autre cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> chaine = \"Bonjour monsieur le capitaine !\" >>> chaine . startswith ( \"Bonjour\" ) True >>> chaine . startswith ( \"Au revoir\" ) False Cette m\u00e9thode est particuli\u00e8rement utile lorsqu'on lit un fichier et que l'on veut r\u00e9cup\u00e9rer certaines lignes commen\u00e7ant par un mot-cl\u00e9. Par exemple dans un fichier PDB, les lignes contenant les coordonn\u00e9es des atomes commencent par le mot-cl\u00e9 ATOM. Enfin, la m\u00e9thode .strip() permet de \u00ab nettoyer les bords \u00bb d'une cha\u00eene de caract\u00e8res : 1 2 3 >>> chaine = \" Comment enlever les espaces au d\u00e9but et \u00e0 la fin ? \" >>> chaine . strip () 'Comment enlever les espaces au d\u00e9but et \u00e0 la fin ?' La m\u00e9thode .strip() enl\u00e8ve les espaces situ\u00e9s sur les bords de la cha\u00eene de caract\u00e8re mais pas ceux situ\u00e9s entre des caract\u00e8res visibles. En r\u00e9alit\u00e9, cette m\u00e9thode enl\u00e8ve n'importe quel combinaison \u00ab d'espace(s) blanc(s) \u00bb sur les bords, par exemple : 1 2 3 >>> chaine = \" \\t fonctionne avec les tabulations et les retours \u00e0 la ligne \\n \" >>> chaine . strip () 'fonctionne avec les tabulations et les retours \u00e0 la ligne' La m\u00e9thode .strip() est tr\u00e8s pratique quand on lit un fichier et qu'on veut se d\u00e9barrasser des retours \u00e0 la ligne.","title":"Pr\u00e9fixe de cha\u00eene de caract\u00e8res"},{"location":"bts-sio-1/python/chaines/#extraction-de-valeurs-numeriques-dune-chaine-de-caracteres","text":"Une t\u00e2che courante en Python est de lire une cha\u00eene de caract\u00e8res (provenant par exemple d'un fichier), d'extraire des valeurs de cette cha\u00eene de caract\u00e8res pour ensuite les manipuler. On consid\u00e8re par exemple la cha\u00eene de caract\u00e8res val : 1 >>> val = \"3.4 17.2 atom\" On souhaite extraire les valeurs 3.4 et 17.2 pour ensuite les additionner. Dans un premier temps, on d\u00e9coupe la cha\u00eene de caract\u00e8res avec la m\u00e9thode .split() : 1 2 3 >>> val2 = val . split () >>> val2 [ '3.4' , '17.2' , 'atom' ] On obtient alors une liste de cha\u00eenes de caract\u00e8res. On transforme ensuite les deux premiers \u00e9l\u00e9ments de cette liste en floats (avec la fonction float()) pour pouvoir les additionner : 1 2 >>> float ( val2 [ 0 ]) + float ( val2 [ 1 ]) 20.599999999999998 Remarque Retenez bien l'utilisation des instructions pr\u00e9c\u00e9dentes pour extraire des valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res. Elles sont r\u00e9guli\u00e8rement employ\u00e9es pour analyser des donn\u00e9es extraites d'un fichier. 10.7 Conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res On a vu dans le chapitre 2 Variables la conversion d'un type simple (entier, float et cha\u00eene de caract\u00e8res) en un autre avec les fonctions int(), float() et str(). La conversion d'une liste de cha\u00eenes de caract\u00e8res en une cha\u00eene de caract\u00e8res est particuli\u00e8re puisqu'elle fait appelle \u00e0 la m\u00e9thode .join(). 1 2 3 4 5 6 7 8 9 >>> seq = [ \"A\" , \"T\" , \"G\" , \"A\" , \"T\" ] >>> seq [ 'A' , 'T' , 'G' , 'A' , 'T' ] >>> \"-\" . join ( seq ) 'A-T-G-A-T' >>> \" \" . join ( seq ) 'A T G A T' >>> \"\" . join ( seq ) 'ATGAT' Les \u00e9l\u00e9ments de la liste initiale sont concat\u00e9n\u00e9s les uns \u00e0 la suite des autres et intercal\u00e9s par un s\u00e9parateur qui peut \u00eatre n'importe quelle cha\u00eene de caract\u00e8res. Ici, on a utilis\u00e9 un tiret, un espace et rien (une cha\u00eene de caract\u00e8res vide). Attention, la m\u00e9thode .join() ne s'applique qu'\u00e0 une liste de cha\u00eenes de caract\u00e8res. 1 2 3 4 5 >>> maliste = [ \"A\" , 5 , \"G\" ] >>> \" \" . join ( maliste ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : sequence item 1 : expected string , int found On esp\u00e8re qu'apr\u00e8s ce petit tour d'horizon vous serez convaincu de la richesse des m\u00e9thodes associ\u00e9es aux cha\u00eenes de caract\u00e8res. Pour avoir une liste exhaustive de l'ensemble des m\u00e9thodes associ\u00e9es \u00e0 une variable particuli\u00e8re, vous pouvez utiliser la fonction dir(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 >>> animaux = \"girafe tigre\" >>> dir ( animaux ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , '__dir__' , '__doc__' , '__eq__' , '__format__' , '__ge__' , '__getattribute__' , '_ _getitem__ ', ' __getnewargs__ ', ' __gt__ ', ' __hash__ ', ' __init__ ', ' _ _init_subclass__ ', ' __iter__ ', ' __le__ ', ' __len__ ', ' __lt__ ', ' __mo d__ ', ' __mul__ ', ' __ne__ ', ' __new__ ', ' __reduce__ ', ' __reduce_ex__ ' , '__repr__' , '__rmod__' , '__rmul__' , '__setattr__' , '__sizeof__' , '__str__' , '__subclasshook__' , 'capitalize' , 'casefold' , 'center' , 'count' , 'encode' , 'endswith' , 'expandtabs' , 'find' , 'format' , 'for mat_map ', ' index ', ' isalnum ', ' isalpha ', ' isdecimal ', ' isdigit ', ' i sidentifier ', ' islower ', ' isnumeric ', ' isprintable ', ' isspace ', ' is title ', ' isupper ', ' join ', ' ljust ', ' lower ', ' lstrip ', ' maketrans ', 'partition' , 'replace' , 'rfind' , 'rindex' , 'rjust' , 'rpartition' , 'rsplit' , 'rstrip' , 'split' , 'splitlines' , 'startswith' , 'strip' , 'swapcase' , 'title' , 'translate' , 'upper' , 'zfill' ] Pour l'instant, vous pouvez ignorer les m\u00e9thodes qui commencent et qui se terminent par deux tirets bas (underscores) __ . Vous pouvez \u00e9galement acc\u00e9der \u00e0 l'aide et \u00e0 la documentation d'une m\u00e9thode particuli\u00e8re avec help(), par exemple pour la m\u00e9thode .split() : 1 2 3 4 5 6 7 8 9 10 11 >>> help ( animaux . split ) Help on built - in function split : split ( ... ) S . split ([ sep [, maxsplit ]]) -> list of strings Return a list of the words in the string S , using sep as the delimiter string . If maxsplit is given , at most maxsplit splits are done . If sep is not specified or is None , any whitespace string is a separator . ( END ) Attention \u00e0 ne pas mettre les parenth\u00e8ses \u00e0 la suite du nom de la m\u00e9thode. L'instruction correcte est help(animaux.split) et non pas help(animaux.split()).","title":"Extraction de valeurs num\u00e9riques d'une cha\u00eene de caract\u00e8res"},{"location":"bts-sio-1/python/collections/","text":"Dictionnaires, tuples et sets Jusqu'\u00e0 maintenant nous avons vu et manipul\u00e9 le type d'objet s\u00e9quentiel le plus classique : les listes . On se rappelle qu'elles sont modifiables, ordonn\u00e9es et it\u00e9rables. Dans ce chapitre nous allons voir trois nouveaux types d'objet s\u00e9quentiel avec des propri\u00e9t\u00e9s diff\u00e9rentes : les dictionnaires , les tuples et les sets . Remarque Les objets s\u00e9quentiels peuvent \u00eatre aussi appel\u00e9s parfois containers. Dictionnaires D\u00e9finition Les dictionnaires se r\u00e9v\u00e8lent tr\u00e8s pratiques lorsque vous devez manipuler des structures complexes \u00e0 d\u00e9crire et que les listes pr\u00e9sentent leurs limites. Les dictionnaires sont des collections non ordonn\u00e9es d'objets, c'est-\u00e0-dire qu'il n'y a pas de notion d'ordre (i.e. pas d'indice). On acc\u00e8de aux valeurs d'un dictionnaire par des cl\u00e9s. Ceci semble un peu confus ? Regardez l'exemple suivant : 1 2 3 4 5 6 >>> ani1 = {} >>> ani1 [ \"nom\" ] = \"girafe\" >>> ani1 [ \"taille\" ] = 5.0 >>> ani1 [ \"poids\" ] = 1100 >>> ani1 { 'nom' : 'girafe' , 'taille' : 5.0 , 'poids' : 1100 } En premier, on d\u00e9finit un dictionnaire vide avec les accolades {} (tout comme on peut le faire pour les listes avec [] ). Ensuite, on remplit le dictionnaire avec diff\u00e9rentes cl\u00e9s (\"nom\", \"taille\", \"poids\") auxquelles on affecte des valeurs (\"girafe\", 5.0, 1100) . Vous pouvez mettre autant de cl\u00e9s que vous voulez dans un dictionnaire (tout comme vous pouvez ajouter autant d'\u00e9l\u00e9ments que vous voulez dans une liste). Remarque Un dictionnaire est affich\u00e9 sans ordre particulier. On peut aussi initialiser toutes les cl\u00e9s et les valeurs d'un dictionnaire en une seule op\u00e9ration : 1 >>> ani2 = { \"nom\" : \"singe\" , \"poids\" : 70 , \"taille\" : 1.75 } Mais rien ne nous emp\u00eache d'ajouter une cl\u00e9 et une valeur suppl\u00e9mentaire : 1 >>> ani2 [ \"age\" ] = 15 Pour r\u00e9cup\u00e9rer la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e, il suffit d'utiliser la syntaxe suivante dictionnaire[\"cle\"] . Par exemple : 1 2 >>> ani1 [ \"taille\" ] 5.0 Remarque Toutes les cl\u00e9s de dictionnaire utilis\u00e9es jusqu'\u00e0 pr\u00e9sent \u00e9taient des cha\u00eenes de caract\u00e8res. Rien n'emp\u00eache d'utiliser d'autres types d'objets comme des entiers (voire m\u00eame des tuples, cf. rubrique suivante), cela peut parfois s'av\u00e9rer tr\u00e8s utile. N\u00e9anmoins, nous vous conseillons, autant que possible, d'utiliser syst\u00e9matiquement des cha\u00eenes de caract\u00e8res pour vos cl\u00e9s de dictionnaire. Apr\u00e8s ce premier tour d'horizon, on voit tout de suite l'avantage des dictionnaires. Pouvoir retrouver des \u00e9l\u00e9ments par des noms (cl\u00e9s) plut\u00f4t que par des indices. Les humains retiennent mieux les noms que les chiffres. Ainsi, l'usage des dictionnaires rend en g\u00e9n\u00e9ral le code plus lisible. Par exemple, si nous souhaitions stocker les coordonn\u00e9es (x,y,z) d'un point dans l'espace : coors = [0, 1, 2] pour la version liste, coors = {\"x\": 0, \"y\": 1, \"z\": 2} pour la version dictionnaire. Un lecteur comprendra tout de suite que coors[\"z\"] contient la coordonn\u00e9e z , ce sera moins intuitif avec coors[2] . It\u00e9ration sur les cl\u00e9s pour obtenir les valeurs Il est possible d'obtenir toutes les valeurs d'un dictionnaire \u00e0 partir de ses cl\u00e9s : 1 2 3 4 5 6 7 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> for key in ani2 : ... print ( key , ani2 [ key ]) ... poids 70 nom singe taille 1.75 M\u00e9thodes .keys() , .values() et .items() Les m\u00e9thodes .keys() et .values() renvoient, comme vous pouvez vous en doutez, les cl\u00e9s et les valeurs d'un dictionnaire : 1 2 3 4 >>> ani2 . keys () dict_keys ([ 'poids' , 'nom' , 'taille' ]) >>> ani2 . values () dict_values ([ 70 , 'singe' , 1.75 ]) Les mentions dict_keys et dict_values indiquent que nous avons \u00e0 faire \u00e0 des objets un peu particuliers. Ils ne sont pas indexables (on ne peut pas retrouver un \u00e9l\u00e9ment par indice, par exemple dico.keys()[0] renverra une erreur). Si besoin, nous pouvons les transformer en liste avec la fonction list() : 1 2 3 4 >>> ani2 . values () dict_values ([ 'singe' , 70 , 1.75 ]) >>> list ( ani2 . values ()) [ 'singe' , 70 , 1.75 ] Toutefois, ce sont des objets \u00ab it\u00e9rables \u00bb, donc utilisables dans une boucle. Enfin, il existe la m\u00e9thode .items() qui renvoie un nouvel objet dict_items : 1 2 3 >>> dico = { 0 : \"t\" , 1 : \"o\" , 2 : \"t\" , 3 : \"o\" } >>> dico . items () dict_items ([( 0 , 't' ), ( 1 , 'o' ), ( 2 , 't' ), ( 3 , 'o' )]) Celui-ci n'est pas indexable (on ne peut pas retrouver un \u00e9l\u00e9ment par un indice) mais il est it\u00e9rable : 1 2 3 4 5 6 7 8 9 10 11 >>> dico . items ()[ 2 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'dict_items' object is not subscriptable >>> for key , val in dico . items (): ... print ( key , val ) ... 0 t 1 o 2 t 3 o Notez la syntaxe particuli\u00e8re qui ressemble \u00e0 la fonction enumerate() vue au chapitre 5 Boucles et comparaisons. On it\u00e8re \u00e0 la fois sur key et sur val. On verra plus bas que cela peut-\u00eatre utile pour construire des dictionnaires de compr\u00e9hension. Existence d'une cl\u00e9 Pour v\u00e9rifier si une cl\u00e9 existe dans un dictionnaire, on peut utiliser le test d\u2019appartenance avec l'instruction in qui renvoie un bool\u00e9en : 1 2 3 4 5 6 7 8 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> if \"poids\" in ani2 : ... print ( \"La cl\u00e9 'poids' existe pour ani2\" ) ... La cl\u00e9 'poids' existe pour ani2 >>> if \"age\" in ani2 : ... print ( \"La cl\u00e9 'age' existe pour ani2\" ) ... Dans le second test (lignes 5 \u00e0 7), le message n'est pas affich\u00e9 car la cl\u00e9 age n'est pas pr\u00e9sente dans le dictionnaire ani2 . M\u00e9thode .get() La m\u00e9thode .get() extrait la valeur associ\u00e9e \u00e0 une cl\u00e9 mais ne renvoie pas d'erreur si la cl\u00e9 n'existe pas : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> ani2 . get ( \"nom\" ) 'singe' >>> ani2 . get ( \"age\" ) >>> Ici la valeur associ\u00e9e \u00e0 la cl\u00e9 nom est singe mais la cl\u00e9 age n'existe pas. On peut \u00e9galement indiquer \u00e0 .get() une valeur par d\u00e9faut si la cl\u00e9 n'existe pas : 1 2 >>> ani2 . get ( \"age\" , 42 ) 42 Tri par cl\u00e9s On peut utiliser la fonction sorted() vue pr\u00e9c\u00e9demment avec les listes pour trier un dictionnaire par ses cl\u00e9s : 1 2 3 >>> ani2 = { 'nom' : 'singe' , 'taille' : 1.75 , 'poids' : 70 } >>> sorted ( ani2 ) [ 'nom' , 'poids' , 'taille' ] Les cl\u00e9s sont tri\u00e9es ici par ordre alphab\u00e9tique. Tri par valeurs Pour trier un dictionnaire par ses valeurs, il faut utiliser la fonction sorted avec l'argument key : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get ) [ 'b' , 'a' , 'c' ] L'argument key=dico.get indique explicitement qu'il faut r\u00e9aliser le tri par les valeurs du dictionnaire. On retrouve la m\u00e9thode .get() vue plus haut, mais sans les parenth\u00e8ses ( key=dico.get mais pas key=dico.get() ). Attention, ce sont les cl\u00e9s du dictionnaires qui sont renvoy\u00e9es, pas les valeurs. Ces cl\u00e9s sont cependant renvoy\u00e9es dans un ordre qui permet d'obtenir les cl\u00e9s tri\u00e9es par ordre croissant : 1 2 3 4 5 6 7 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> for key in sorted ( dico , key = dico . get ): ... print ( key , dico [ key ]) ... b 5 a 15 c 20 Enfin, l'argument reverse=True fonctionne \u00e9galement : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get , reverse = True ) [ 'c' , 'a' , 'b' ] Remarque Lorsqu'on trie un dictionnaire par ses valeurs, il faut \u00eatre s\u00fbr que cela soit possible. Ce n'est, par exemple, pas le cas pour le dictionnaire ani2 car les valeurs sont des valeurs num\u00e9riques et une cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> sorted ( ani2 , key = ani2 . get ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' On obtient ici une erreur car Python ne sait pas comparer une cha\u00eene de caract\u00e8res ( singe ) avec des valeurs num\u00e9riques ( 70 et 1.75 ). Cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs Les fonctions min() et max() , que vous avez d\u00e9j\u00e0 manipul\u00e9es dans les chapitres pr\u00e9c\u00e9dents, acceptent \u00e9galement l'argument key= . On peut ainsi obtenir la cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs d'un dictionnaire : 1 2 3 4 5 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> max ( dico , key = dico . get ) 'c' >>> min ( dico , key = dico . get ) 'b' Liste de dictionnaires En cr\u00e9ant une liste de dictionnaires qui poss\u00e8dent les m\u00eames cl\u00e9s, on obtient une structure qui ressemble \u00e0 une base de donn\u00e9es : 1 2 3 4 5 6 7 8 9 10 >>> animaux = [ ani1 , ani2 ] >>> animaux [{ 'nom' : 'girafe' , 'poids' : 1100 , 'taille' : 5.0 }, { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 }] >>> >>> for ani in animaux : ... print ( ani [ \"nom\" ]) ... girafe singe Vous constatez ainsi que les dictionnaires permettent de g\u00e9rer des structures complexes de mani\u00e8re plus explicite que les listes. Fonction dict() Conseil Pour les d\u00e9butants vous pouvez sauter cette rubrique. La fonction dict() va convertir l'argument qui lui est pass\u00e9 en dictionnaire. Il s'agit donc d'une fonction de casting comme int() , str() , etc. Toutefois, l'argument qui lui est pass\u00e9 doit avoir une forme particuli\u00e8re : un objet s\u00e9quentiel contenant d'autres objets s\u00e9quentiels de 2 \u00e9l\u00e9ments. Par exemple, une liste de listes de 2 \u00e9l\u00e9ments : 1 2 3 >>> liste_animaux = [[ \"girafe\" , 2 ], [ \"singe\" , 3 ]] >>> dict ( liste_animaux ) { 'girafe' : 2 , 'singe' : 3 } Ou un tuple de tuples de 2 \u00e9l\u00e9ments (cf. rubrique suivante pour la d\u00e9finition d'un tuple), ou encore une combinaison liste / tuple : 1 2 3 4 5 6 >>> tuple_animaux = (( \"girafe\" , 2 ), ( \"singe\" , 3 )) >>> dict ( tuple_animaux ) { 'girafe' : 2 , 'singe' : 3 } >>> >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 )]) { 'girafe' : 2 , 'singe' : 3 } Si un des sous-\u00e9l\u00e9ments a plus de 2 \u00e9l\u00e9ments (ou moins), Python renvoie une erreur : 1 2 3 4 >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 , 4 )]) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : dictionary update sequence element #1 has length 3; 2 is required Tuples D\u00e9finition Les tuples (\u00ab n-uplets \u00bb en fran\u00e7ais) correspondent aux listes \u00e0 la diff\u00e9rence qu'ils sont non modifiables. On a vu dans le chapitre 11 Plus sur les listes que les listes pouvaient \u00eatre modifi\u00e9es par r\u00e9f\u00e9rences, notamment lors de la copie de listes. Les tuples s'affranchissent de ce probl\u00e8me puisqu'ils sont non modifiables. Pratiquement, ils utilisent les parenth\u00e8ses au lieu des crochets : 1 2 3 4 5 6 7 8 9 10 11 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x [ 2 ] 3 >>> x [ 0 : 2 ] ( 1 , 2 ) >>> x [ 2 ] = 15 Traceback ( innermost last ): File \"<stdin>\" , line 1 , in ? TypeError : object doesn 't support item assignment L'affectation et l'indi\u00e7age fonctionnent comme avec les listes . Mais si on essaie de modifier un des \u00e9l\u00e9ments du tuple, Python renvoie un message d'erreur. Si vous voulez ajouter un \u00e9l\u00e9ment (ou le modifier), vous devez cr\u00e9er un autre tuple : 1 2 3 >>> x = ( 1 , 2 , 3 ) >>> x + ( 2 ,) ( 1 , 2 , 3 , 2 ) Remarque Pour utiliser un tuple d'un seul \u00e9l\u00e9ment, vous devez utiliser une syntaxe avec une virgule (element,), ceci pour \u00e9viter une ambigu\u00eft\u00e9 avec une simple expression. Autre particularit\u00e9 des tuples, il est possible d'en cr\u00e9er de nouveaux sans les parenth\u00e8ses, d\u00e8s lors que ceci ne pose pas d'ambigu\u00eft\u00e9 avec une autre expression : 1 2 3 4 5 6 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x = 1 , 2 , 3 >>> x ( 1 , 2 , 3 ) Toutefois, nous vous conseillons d'utiliser syst\u00e9matiquement les parenth\u00e8ses afin d'\u00e9viter les confusions. Enfin, on peut utiliser la fonction tuple(sequence) qui fonctionne exactement comme la fonction list() , c'est-\u00e0-dire qu'elle prend en argument un objet s\u00e9quentiel et renvoie le tuple correspondant (op\u00e9ration de casting) : 1 2 3 4 >>> tuple ([ 1 , 2 , 3 ]) ( 1 , 2 , 3 ) >>> tuple ( \"ATGCCGCGAT\" ) ( 'A' , 'T' , 'G' , 'C' , 'C' , 'G' , 'C' , 'G' , 'A' , 'T' ) Remarque Les listes , les dictionnaires et les tuples sont des objets qui peuvent contenir des collections d'autres objets. On peut donc construire des listes qui contiennent des dictionnaires , des tuples ou d'autres listes , mais aussi des dictionnaires contenant des tuples , des listes , etc. It\u00e9rations sur plusieurs valeurs \u00e0 la fois Pratiquement, nous avons d\u00e9j\u00e0 crois\u00e9 les tuples avec la fonction enumerate() dans le chapitre 5 Boucles et comparaisons. Cette derni\u00e8re permettait d'it\u00e9rer en m\u00eame temps sur les indices et les \u00e9l\u00e9ments d'une liste : 1 2 3 4 5 6 7 8 9 10 11 12 >>> for i , elt in enumerate ([ 75 , - 75 , 0 ]): ... print ( i , elt ) ... 0 75 1 - 75 2 0 >>> for obj in enumerate ([ 75 , - 75 , 0 ]): ... print ( obj , type ( obj )) ... ( 0 , 75 ) < class ' tuple '> ( 1 , - 75 ) < class ' tuple '> ( 2 , 0 ) < class ' tuple '> En fin de compte, la fonction enumerate() it\u00e8re sur une s\u00e9rie de tuples . Pouvoir s\u00e9parer i et elt dans la boucle est possible du fait que Python autorise l'affectation multiple du style i, elt = 0, 75 (cf. rubrique suivante). Dans le m\u00eame ordre d'id\u00e9e, nous avons vu \u00e0 la rubrique pr\u00e9c\u00e9dente la m\u00e9thode .dict_items() qui permettait d'it\u00e9rer sur des couples cl\u00e9/valeur d'un dictionnaire : 1 2 3 4 5 6 7 8 9 10 11 >>> dico = { \"pinson\" : 2 , \"merle\" : 3 } >>> for key , val in dico . items (): ... print ( key , val ) ... pinson 2 merle 3 >>> for obj in dico . items (): ... print ( obj , type ( obj )) ... ( 'pinson' , 2 ) < class ' tuple '> ( 'merle' , 3 ) < class ' tuple '> On voit que cette m\u00e9thode .dict_items() it\u00e8re comme enumerate() sur une s\u00e9rie de tuples . Sur la m\u00eame base, on peut finalement it\u00e9rer sur 3 valeurs en m\u00eame temps \u00e0 partir d'une liste de tuples de 3 \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 9 >>> liste = [( i , i + 1 , i + 2 ) for i in range ( 5 , 8 )] >>> liste [( 5 , 6 , 7 ), ( 6 , 7 , 8 ), ( 7 , 8 , 9 )] >>> for x , y , z in liste : ... print ( x , y , z ) ... 5 6 7 6 7 8 7 8 9 On pourrait concevoir la m\u00eame chose sur 4 \u00e9l\u00e9ments, ou finalement autant que l'on veut. La seule restriction est d'avoir une correspondance syst\u00e9matique entre le nombre de variables d'it\u00e9ration (par exemple 3 ci-dessus avec x, y, z ) et la longueur de chaque sous-tuple de la liste sur laquelle on it\u00e8re (chaque sous-tuple a 3 \u00e9l\u00e9ments ci-dessus). Affectation multiple et le nom de variable _ L'affectation multiple est un m\u00e9canisme tr\u00e8s puissant et important en Python . Pour rappel, il permet d'effectuer sur une m\u00eame ligne plusieurs affectations en m\u00eame temps, par exemple : x, y, z = 1, 2, 3 . On voit que cette syntaxe correspond \u00e0 un tuple de chaque c\u00f4t\u00e9 de l'op\u00e9rateur = . Notez qu'il serait possible de le faire \u00e9galement avec les listes : [x, y, z] = [1, 2, 3] . Toutefois, cette syntaxe est alourdie par la pr\u00e9sence des crochets. On pr\u00e9f\u00e8rera donc la premi\u00e8re syntaxe avec les tuples sans parenth\u00e8se. Remarque Nous avons appel\u00e9 l'op\u00e9ration x, y, z = 1, 2, 3 affectation multiple pour signifier que l'on affectait des valeurs \u00e0 plusieurs variables en m\u00eame temps. Toutefois, vous pourrez rencontrer aussi l'expression tuple unpacking que l'on pourrait traduire par \u00ab d\u00e9sempaquetage de tuple \u00bb. Cela signifie que l'on d\u00e9compose le tuple initial 1, 2, 3 en 3 variables diff\u00e9rentes (comme si on vidait son sac \u00e0 dos, d'o\u00f9 le terme d\u00e9sempaquetage !). Nous avions crois\u00e9 l'importance de l'affectation multiple dans le chapitre 9 Fonctions lorsqu'une fonction renvoyait plusieurs valeurs. 1 2 3 4 5 6 >>> def fct (): ... return 3 , 14 ... >>> x , y = fct () >>> print ( x , y ) 3 14 La syntaxe x, y = fct() permet de r\u00e9cup\u00e9rer les 2 valeurs renvoy\u00e9es par la fonction et de les affecter \u00e0 la vol\u00e9e dans 2 variables diff\u00e9rentes. Cela \u00e9vite l'op\u00e9ration laborieuse de r\u00e9cup\u00e9rer d'abord le tuple , puis de cr\u00e9er les variables en utilisant l'indi\u00e7age : 1 2 3 4 5 6 7 >>> resultat = fct () >>> resultat ( 3 , 14 ) >>> x = resultat [ 0 ] >>> y = resultat [ 1 ] >>> print ( x , y ) 3 14 Remarque Lorsqu'une fonction renvoie plusieurs valeurs sous forme de tuple, ce sera bien s\u00fbr la forme x, y = fct() qui sera privil\u00e9gi\u00e9e. Quand une fonction renvoie plusieurs valeurs mais que l'on ne souhaite pas les utiliser toutes dans la suite du code, on peut utiliser le nom de variable _ (underscore) pour indiquer que certaines valeurs ne nous int\u00e9ressent pas : 1 2 3 4 5 6 7 8 >>> def fct (): ... return 1 , 2 , 3 , 4 ... >>> x , _ , y , _ = fct () >>> x 1 >>> y 3 Cela envoie le message \u00e0 celui qui lit le code \u00ab je me fiche des valeurs r\u00e9cup\u00e9r\u00e9es dans ces variables _ \u00bb. Notez que l'on peut utiliser une ou plusieurs variables underscores(s). Dans l'exemple ci-dessus, la 2\u00e8me et la 4\u00e8me variable renvoy\u00e9es par la fonction seront ignor\u00e9es dans la suite du code. Cela a le m\u00e9rite d'\u00e9viter la cr\u00e9ation de variables dont on ne se sert pas. Remarque La variable _ a une autre signication sp\u00e9ciale dans l'interpr\u00e9teur interactif, elle prend automatiquement la derni\u00e8re valeur affich\u00e9e : 1 2 3 4 5 6 7 8 >>> 3 3 >>> _ 3 >>> \"m\u00e9sange\" 'm\u00e9sange' >>> _ 'm\u00e9sange' Attention, cela n'est vrai que dans l'interpr\u00e9teur. Conseils Le underscore est couramment utilis\u00e9 dans les noms de variable pour s\u00e9parer les mots et \u00eatre explicite, par exemple seq_ADN ou liste_listes_residus. On verra dans le chapitre 15 Bonnes pratiques en programmation Python que ce style de nommage est appel\u00e9 snake_case. Toutefois, il faut \u00e9viter d'utiliser les underscores en d\u00e9but et/ou en fin de nom de variable (e.g. _var , var_ , __var , __var__ ). On verra au chapitre 19 Avoir la classe avec les objets que ces underscores ont une signification particuli\u00e8re. Sets Les containers de type set repr\u00e9sentent un autre type d'objet s\u00e9quentiel qui peut se r\u00e9v\u00e9ler tr\u00e8s pratique. Ils ont la particularit\u00e9 d'\u00eatre non modifiables, non ordonn\u00e9s et de ne contenir qu'une seule copie maximum de chaque \u00e9l\u00e9ment. Pour cr\u00e9er un nouveau set on peut utiliser les accolades : 1 2 3 4 5 >>> s = { 1 , 2 , 3 , 3 } >>> s { 1 , 2 , 3 } >>> type ( s ) < class ' set '> Notez que la r\u00e9p\u00e9tition du 3 dans la d\u00e9finition du set en ligne 1 donne au final un seul 3 car chaque \u00e9l\u00e9ment ne peut \u00eatre pr\u00e9sent qu'une seule fois. A quoi diff\u00e9rencie-t-on un set d'un dictionnaire alors que les deux utilisent des accolades ? Le set sera d\u00e9fini seulement par des valeurs {val1, val2, ...} alors que le dictionnaire aura toujours des couples cl\u00e9/valeur {cl\u00e91: val1, cl\u00e92: val2, ...}. En g\u00e9n\u00e9ral, on utilisera la fonction interne \u00e0 Python set() pour g\u00e9n\u00e9rer un nouveau set. Celle-ci prend en argument n'importe quel objet it\u00e9rable et le convertit en set (op\u00e9ration de casting) : 1 2 3 4 5 6 7 8 9 10 11 12 >>> set ([ 1 , 2 , 4 , 1 ]) { 1 , 2 , 4 } >>> set (( 2 , 2 , 2 , 1 )) { 1 , 2 } >>> set ( range ( 5 )) { 0 , 1 , 2 , 3 , 4 } >>> set ({ \"cl\u00e91\" : 1 , \"cl\u00e92\" : 2 }) { 'cl\u00e91' , 'cl\u00e92' } >>> set ([ \"ti\" , \"to\" , \"to\" ]) { 'ti' , 'to' } >>> set ( \"Ma\u00eetre corbeau sur un arbre perch\u00e9\" ) { 'h' , 'u' , 'o' , 'b' , ' ' , 'M' , 'a' , 'p' , 'n' , 'e' , '\u00e9' , 'c' , '\u00ee' , 's' , 't' , 'r' } Nous avons dit plus haut que les sets ne sont pas ordonn\u00e9s, il est donc impossible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment par sa position. Il est \u00e9galement impossible de modifier un de ses \u00e9l\u00e9ments. Par contre, les sets sont it\u00e9rables : 1 2 3 4 5 6 7 8 9 10 11 >>> s = set ([ 1 , 2 , 4 , 1 ]) >>> s [ 1 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object is not subscriptable >>> for elt in s : ... print ( elt ) ... 1 2 4 Les containers de type set sont tr\u00e8s utiles pour rechercher les \u00e9l\u00e9ments uniques d'une suite d'\u00e9l\u00e9ments. Cela revient \u00e0 \u00e9liminer tous les doublons. Par exemple : 1 2 3 4 5 6 >>> import random as rd >>> l = [ rd . randint ( 0 , 9 ) for i in range ( 10 )] >>> l [ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ] >>> set ( l ) { 3 , 5 , 6 , 7 , 8 , 9 } On peut bien s\u00fbr transformer dans l'autre sens un set en liste. Cela permet par exemple d'\u00e9liminer les doublons de la liste initiale tout en r\u00e9cup\u00e9rant une liste \u00e0 la fin : 1 2 >>> list ( set ([ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ])) [ 3 , 5 , 6 , 7 , 8 , 9 ] On peut faire des choses tr\u00e8s puissantes. Par exemple, un compteur de lettres en combinaison avec une liste de compr\u00e9hension, le tout en une ligne ! 1 2 3 4 5 >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> set ( seq ) { 'c' , 'g' , 't' , 'a' } >>> [( base , seq . count ( base )) for base in set ( seq )] [( 'c' , 15 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'a' , 10 )] Les sets permettent aussi l'\u00e9valuation d'union ou d'intersection math\u00e9matiques en conjonction avec les op\u00e9rateurs respectivement | et & : 1 2 3 4 5 6 >>> l = [ 3 , 3 , 5 , 1 , 3 , 4 , 1 , 1 , 4 , 4 ] >>> l2 = [ 3 , 0 , 5 , 3 , 3 , 1 , 1 , 1 , 2 , 2 ] >>> set ( l ) & set ( l2 ) { 1 , 3 , 5 } >>> set ( l ) | set ( l2 ) { 0 , 1 , 2 , 3 , 4 , 5 } Conseil : Pour aller plus loin, vous pouvez consulter deux articles sur les sites programiz et towardsdatascience. Dictionnaires et sets de compr\u00e9hension Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Nous avons vu au chapitre 11 Plus sur les listes les listes de compr\u00e9hension. Il est \u00e9galement possible de g\u00e9n\u00e9rer des dictionnaires de compr\u00e9hension : 1 2 3 4 5 6 7 8 9 10 11 12 >>> dico = { \"a\" : 10 , \"g\" : 10 , \"t\" : 11 , \"c\" : 15 } >>> dico . items () dict_items ([( 'a' , 10 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'c' , 15 )]) >>> { key : val * 2 for key , val in dico . items ()} { 'a' : 20 , 'g' : 20 , 't' : 22 , 'c' : 30 } >>> >>> { key : val for key , val in enumerate ( \"toto\" )} { 0 : 't' , 1 : 'o' , 2 : 't' , 3 : 'o' } >>> >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> { base : seq . count ( base ) for base in set ( seq )} { 'a' : 10 , 'g' : 10 , 't' : 11 , 'c' : 15 } De mani\u00e8re g\u00e9n\u00e9rale, tout objet sur lequel on peut faire une double it\u00e9ration du type for var1, var2 in obj est utilisable pour cr\u00e9er un dictionnaire de compr\u00e9hension. Si vous souhaitez aller plus loin, vous pouvez consulter cet article sur le site Datacamp. Il est \u00e9galement possible de g\u00e9n\u00e9rer des sets de compr\u00e9hension sur le m\u00eame mod\u00e8le que les listes de compr\u00e9hension : 1 2 3 4 >>> { i for i in range ( 10 )} { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } >>> { i ** 2 for i in range ( 10 )} { 0 , 1 , 64 , 4 , 36 , 9 , 16 , 49 , 81 , 25 } Module collections Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Le module collections contient d'autres types de containers qui peuvent se r\u00e9v\u00e9ler utiles, c'est une v\u00e9ritable mine d'or ! Nous n'aborderons pas tous ces objets ici, mais nous pouvons citer tout de m\u00eame certains d'entre eux si vous souhaitez aller un peu plus loin : les dictionnaires ordonn\u00e9s qui se comportent comme les dictionnaires classiques mais qui sont ordonn\u00e9s ; les defaultdicts permettant de g\u00e9n\u00e9rer des valeurs par d\u00e9faut quand on demande une cl\u00e9 qui n'existe pas (cela \u00e9vite que Python g\u00e9n\u00e8re une erreur) ; les compteurs dont un exemple est montr\u00e9 ci-dessous ; les namedtuples que nous \u00e9voquerons au chapitre 19 Avoir la classe avec les objets. L'objet collection.Counter() est particuli\u00e8rement int\u00e9ressant et simple \u00e0 utiliser. Il cr\u00e9e des compteurs \u00e0 partir d'objets it\u00e9rables, par exemple : 1 2 3 4 5 6 7 8 9 10 >>> import collections >>> compo_seq = collections . Counter ( \"aatctccgatcgatcgatcgatgatc\" ) >>> compo_seq Counter ({ 'a' : 7 , 't' : 7 , 'c' : 7 , 'g' : 5 }) >>> type ( compo_seq ) < class ' collections . Counter '> >>> compo_seq [ \"a\" ] 7 >>> compo_seq [ \"n\" ] 0 On voit que Python a automatiquement compt\u00e9 chaque atgc de la cha\u00eene de caract\u00e8res pass\u00e9e en argument ! Cela cr\u00e9e un objet de type Counterqui se comporte ensuite comme un dictionnaire, \u00e0 une exception pr\u00e8s : si on appelle une cl\u00e9 qui n'existe pas dans l'it\u00e9rable initiale (comme le n ci-dessus) cela renvoie 0.","title":"Dictionnaires, tuples et sets"},{"location":"bts-sio-1/python/collections/#dictionnaires-tuples-et-sets","text":"Jusqu'\u00e0 maintenant nous avons vu et manipul\u00e9 le type d'objet s\u00e9quentiel le plus classique : les listes . On se rappelle qu'elles sont modifiables, ordonn\u00e9es et it\u00e9rables. Dans ce chapitre nous allons voir trois nouveaux types d'objet s\u00e9quentiel avec des propri\u00e9t\u00e9s diff\u00e9rentes : les dictionnaires , les tuples et les sets . Remarque Les objets s\u00e9quentiels peuvent \u00eatre aussi appel\u00e9s parfois containers.","title":"Dictionnaires, tuples et sets"},{"location":"bts-sio-1/python/collections/#dictionnaires","text":"","title":"Dictionnaires"},{"location":"bts-sio-1/python/collections/#definition","text":"Les dictionnaires se r\u00e9v\u00e8lent tr\u00e8s pratiques lorsque vous devez manipuler des structures complexes \u00e0 d\u00e9crire et que les listes pr\u00e9sentent leurs limites. Les dictionnaires sont des collections non ordonn\u00e9es d'objets, c'est-\u00e0-dire qu'il n'y a pas de notion d'ordre (i.e. pas d'indice). On acc\u00e8de aux valeurs d'un dictionnaire par des cl\u00e9s. Ceci semble un peu confus ? Regardez l'exemple suivant : 1 2 3 4 5 6 >>> ani1 = {} >>> ani1 [ \"nom\" ] = \"girafe\" >>> ani1 [ \"taille\" ] = 5.0 >>> ani1 [ \"poids\" ] = 1100 >>> ani1 { 'nom' : 'girafe' , 'taille' : 5.0 , 'poids' : 1100 } En premier, on d\u00e9finit un dictionnaire vide avec les accolades {} (tout comme on peut le faire pour les listes avec [] ). Ensuite, on remplit le dictionnaire avec diff\u00e9rentes cl\u00e9s (\"nom\", \"taille\", \"poids\") auxquelles on affecte des valeurs (\"girafe\", 5.0, 1100) . Vous pouvez mettre autant de cl\u00e9s que vous voulez dans un dictionnaire (tout comme vous pouvez ajouter autant d'\u00e9l\u00e9ments que vous voulez dans une liste). Remarque Un dictionnaire est affich\u00e9 sans ordre particulier. On peut aussi initialiser toutes les cl\u00e9s et les valeurs d'un dictionnaire en une seule op\u00e9ration : 1 >>> ani2 = { \"nom\" : \"singe\" , \"poids\" : 70 , \"taille\" : 1.75 } Mais rien ne nous emp\u00eache d'ajouter une cl\u00e9 et une valeur suppl\u00e9mentaire : 1 >>> ani2 [ \"age\" ] = 15 Pour r\u00e9cup\u00e9rer la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e, il suffit d'utiliser la syntaxe suivante dictionnaire[\"cle\"] . Par exemple : 1 2 >>> ani1 [ \"taille\" ] 5.0 Remarque Toutes les cl\u00e9s de dictionnaire utilis\u00e9es jusqu'\u00e0 pr\u00e9sent \u00e9taient des cha\u00eenes de caract\u00e8res. Rien n'emp\u00eache d'utiliser d'autres types d'objets comme des entiers (voire m\u00eame des tuples, cf. rubrique suivante), cela peut parfois s'av\u00e9rer tr\u00e8s utile. N\u00e9anmoins, nous vous conseillons, autant que possible, d'utiliser syst\u00e9matiquement des cha\u00eenes de caract\u00e8res pour vos cl\u00e9s de dictionnaire. Apr\u00e8s ce premier tour d'horizon, on voit tout de suite l'avantage des dictionnaires. Pouvoir retrouver des \u00e9l\u00e9ments par des noms (cl\u00e9s) plut\u00f4t que par des indices. Les humains retiennent mieux les noms que les chiffres. Ainsi, l'usage des dictionnaires rend en g\u00e9n\u00e9ral le code plus lisible. Par exemple, si nous souhaitions stocker les coordonn\u00e9es (x,y,z) d'un point dans l'espace : coors = [0, 1, 2] pour la version liste, coors = {\"x\": 0, \"y\": 1, \"z\": 2} pour la version dictionnaire. Un lecteur comprendra tout de suite que coors[\"z\"] contient la coordonn\u00e9e z , ce sera moins intuitif avec coors[2] .","title":"D\u00e9finition"},{"location":"bts-sio-1/python/collections/#iteration-sur-les-cles-pour-obtenir-les-valeurs","text":"Il est possible d'obtenir toutes les valeurs d'un dictionnaire \u00e0 partir de ses cl\u00e9s : 1 2 3 4 5 6 7 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> for key in ani2 : ... print ( key , ani2 [ key ]) ... poids 70 nom singe taille 1.75","title":"It\u00e9ration sur les cl\u00e9s pour obtenir les valeurs"},{"location":"bts-sio-1/python/collections/#methodes-keys-values-et-items","text":"Les m\u00e9thodes .keys() et .values() renvoient, comme vous pouvez vous en doutez, les cl\u00e9s et les valeurs d'un dictionnaire : 1 2 3 4 >>> ani2 . keys () dict_keys ([ 'poids' , 'nom' , 'taille' ]) >>> ani2 . values () dict_values ([ 70 , 'singe' , 1.75 ]) Les mentions dict_keys et dict_values indiquent que nous avons \u00e0 faire \u00e0 des objets un peu particuliers. Ils ne sont pas indexables (on ne peut pas retrouver un \u00e9l\u00e9ment par indice, par exemple dico.keys()[0] renverra une erreur). Si besoin, nous pouvons les transformer en liste avec la fonction list() : 1 2 3 4 >>> ani2 . values () dict_values ([ 'singe' , 70 , 1.75 ]) >>> list ( ani2 . values ()) [ 'singe' , 70 , 1.75 ] Toutefois, ce sont des objets \u00ab it\u00e9rables \u00bb, donc utilisables dans une boucle. Enfin, il existe la m\u00e9thode .items() qui renvoie un nouvel objet dict_items : 1 2 3 >>> dico = { 0 : \"t\" , 1 : \"o\" , 2 : \"t\" , 3 : \"o\" } >>> dico . items () dict_items ([( 0 , 't' ), ( 1 , 'o' ), ( 2 , 't' ), ( 3 , 'o' )]) Celui-ci n'est pas indexable (on ne peut pas retrouver un \u00e9l\u00e9ment par un indice) mais il est it\u00e9rable : 1 2 3 4 5 6 7 8 9 10 11 >>> dico . items ()[ 2 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'dict_items' object is not subscriptable >>> for key , val in dico . items (): ... print ( key , val ) ... 0 t 1 o 2 t 3 o Notez la syntaxe particuli\u00e8re qui ressemble \u00e0 la fonction enumerate() vue au chapitre 5 Boucles et comparaisons. On it\u00e8re \u00e0 la fois sur key et sur val. On verra plus bas que cela peut-\u00eatre utile pour construire des dictionnaires de compr\u00e9hension.","title":"M\u00e9thodes .keys(), .values() et .items()"},{"location":"bts-sio-1/python/collections/#existence-dune-cle","text":"Pour v\u00e9rifier si une cl\u00e9 existe dans un dictionnaire, on peut utiliser le test d\u2019appartenance avec l'instruction in qui renvoie un bool\u00e9en : 1 2 3 4 5 6 7 8 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> if \"poids\" in ani2 : ... print ( \"La cl\u00e9 'poids' existe pour ani2\" ) ... La cl\u00e9 'poids' existe pour ani2 >>> if \"age\" in ani2 : ... print ( \"La cl\u00e9 'age' existe pour ani2\" ) ... Dans le second test (lignes 5 \u00e0 7), le message n'est pas affich\u00e9 car la cl\u00e9 age n'est pas pr\u00e9sente dans le dictionnaire ani2 .","title":"Existence d'une cl\u00e9"},{"location":"bts-sio-1/python/collections/#methode-get","text":"La m\u00e9thode .get() extrait la valeur associ\u00e9e \u00e0 une cl\u00e9 mais ne renvoie pas d'erreur si la cl\u00e9 n'existe pas : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> ani2 . get ( \"nom\" ) 'singe' >>> ani2 . get ( \"age\" ) >>> Ici la valeur associ\u00e9e \u00e0 la cl\u00e9 nom est singe mais la cl\u00e9 age n'existe pas. On peut \u00e9galement indiquer \u00e0 .get() une valeur par d\u00e9faut si la cl\u00e9 n'existe pas : 1 2 >>> ani2 . get ( \"age\" , 42 ) 42","title":"M\u00e9thode .get()"},{"location":"bts-sio-1/python/collections/#tri-par-cles","text":"On peut utiliser la fonction sorted() vue pr\u00e9c\u00e9demment avec les listes pour trier un dictionnaire par ses cl\u00e9s : 1 2 3 >>> ani2 = { 'nom' : 'singe' , 'taille' : 1.75 , 'poids' : 70 } >>> sorted ( ani2 ) [ 'nom' , 'poids' , 'taille' ] Les cl\u00e9s sont tri\u00e9es ici par ordre alphab\u00e9tique.","title":"Tri par cl\u00e9s"},{"location":"bts-sio-1/python/collections/#tri-par-valeurs","text":"Pour trier un dictionnaire par ses valeurs, il faut utiliser la fonction sorted avec l'argument key : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get ) [ 'b' , 'a' , 'c' ] L'argument key=dico.get indique explicitement qu'il faut r\u00e9aliser le tri par les valeurs du dictionnaire. On retrouve la m\u00e9thode .get() vue plus haut, mais sans les parenth\u00e8ses ( key=dico.get mais pas key=dico.get() ). Attention, ce sont les cl\u00e9s du dictionnaires qui sont renvoy\u00e9es, pas les valeurs. Ces cl\u00e9s sont cependant renvoy\u00e9es dans un ordre qui permet d'obtenir les cl\u00e9s tri\u00e9es par ordre croissant : 1 2 3 4 5 6 7 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> for key in sorted ( dico , key = dico . get ): ... print ( key , dico [ key ]) ... b 5 a 15 c 20 Enfin, l'argument reverse=True fonctionne \u00e9galement : 1 2 3 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> sorted ( dico , key = dico . get , reverse = True ) [ 'c' , 'a' , 'b' ] Remarque Lorsqu'on trie un dictionnaire par ses valeurs, il faut \u00eatre s\u00fbr que cela soit possible. Ce n'est, par exemple, pas le cas pour le dictionnaire ani2 car les valeurs sont des valeurs num\u00e9riques et une cha\u00eene de caract\u00e8res : 1 2 3 4 5 >>> ani2 = { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 } >>> sorted ( ani2 , key = ani2 . get ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'str' On obtient ici une erreur car Python ne sait pas comparer une cha\u00eene de caract\u00e8res ( singe ) avec des valeurs num\u00e9riques ( 70 et 1.75 ).","title":"Tri par valeurs"},{"location":"bts-sio-1/python/collections/#cle-associee-au-minimum-ou-au-maximum-des-valeurs","text":"Les fonctions min() et max() , que vous avez d\u00e9j\u00e0 manipul\u00e9es dans les chapitres pr\u00e9c\u00e9dents, acceptent \u00e9galement l'argument key= . On peut ainsi obtenir la cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs d'un dictionnaire : 1 2 3 4 5 >>> dico = { \"a\" : 15 , \"b\" : 5 , \"c\" : 20 } >>> max ( dico , key = dico . get ) 'c' >>> min ( dico , key = dico . get ) 'b'","title":"Cl\u00e9 associ\u00e9e au minimum ou au maximum des valeurs"},{"location":"bts-sio-1/python/collections/#liste-de-dictionnaires","text":"En cr\u00e9ant une liste de dictionnaires qui poss\u00e8dent les m\u00eames cl\u00e9s, on obtient une structure qui ressemble \u00e0 une base de donn\u00e9es : 1 2 3 4 5 6 7 8 9 10 >>> animaux = [ ani1 , ani2 ] >>> animaux [{ 'nom' : 'girafe' , 'poids' : 1100 , 'taille' : 5.0 }, { 'nom' : 'singe' , 'poids' : 70 , 'taille' : 1.75 }] >>> >>> for ani in animaux : ... print ( ani [ \"nom\" ]) ... girafe singe Vous constatez ainsi que les dictionnaires permettent de g\u00e9rer des structures complexes de mani\u00e8re plus explicite que les listes.","title":"Liste de dictionnaires"},{"location":"bts-sio-1/python/collections/#fonction-dict","text":"Conseil Pour les d\u00e9butants vous pouvez sauter cette rubrique. La fonction dict() va convertir l'argument qui lui est pass\u00e9 en dictionnaire. Il s'agit donc d'une fonction de casting comme int() , str() , etc. Toutefois, l'argument qui lui est pass\u00e9 doit avoir une forme particuli\u00e8re : un objet s\u00e9quentiel contenant d'autres objets s\u00e9quentiels de 2 \u00e9l\u00e9ments. Par exemple, une liste de listes de 2 \u00e9l\u00e9ments : 1 2 3 >>> liste_animaux = [[ \"girafe\" , 2 ], [ \"singe\" , 3 ]] >>> dict ( liste_animaux ) { 'girafe' : 2 , 'singe' : 3 } Ou un tuple de tuples de 2 \u00e9l\u00e9ments (cf. rubrique suivante pour la d\u00e9finition d'un tuple), ou encore une combinaison liste / tuple : 1 2 3 4 5 6 >>> tuple_animaux = (( \"girafe\" , 2 ), ( \"singe\" , 3 )) >>> dict ( tuple_animaux ) { 'girafe' : 2 , 'singe' : 3 } >>> >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 )]) { 'girafe' : 2 , 'singe' : 3 } Si un des sous-\u00e9l\u00e9ments a plus de 2 \u00e9l\u00e9ments (ou moins), Python renvoie une erreur : 1 2 3 4 >>> dict ([( \"girafe\" , 2 ), ( \"singe\" , 3 , 4 )]) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : dictionary update sequence element #1 has length 3; 2 is required","title":"Fonction dict()"},{"location":"bts-sio-1/python/collections/#tuples","text":"","title":"Tuples"},{"location":"bts-sio-1/python/collections/#definition_1","text":"Les tuples (\u00ab n-uplets \u00bb en fran\u00e7ais) correspondent aux listes \u00e0 la diff\u00e9rence qu'ils sont non modifiables. On a vu dans le chapitre 11 Plus sur les listes que les listes pouvaient \u00eatre modifi\u00e9es par r\u00e9f\u00e9rences, notamment lors de la copie de listes. Les tuples s'affranchissent de ce probl\u00e8me puisqu'ils sont non modifiables. Pratiquement, ils utilisent les parenth\u00e8ses au lieu des crochets : 1 2 3 4 5 6 7 8 9 10 11 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x [ 2 ] 3 >>> x [ 0 : 2 ] ( 1 , 2 ) >>> x [ 2 ] = 15 Traceback ( innermost last ): File \"<stdin>\" , line 1 , in ? TypeError : object doesn 't support item assignment L'affectation et l'indi\u00e7age fonctionnent comme avec les listes . Mais si on essaie de modifier un des \u00e9l\u00e9ments du tuple, Python renvoie un message d'erreur. Si vous voulez ajouter un \u00e9l\u00e9ment (ou le modifier), vous devez cr\u00e9er un autre tuple : 1 2 3 >>> x = ( 1 , 2 , 3 ) >>> x + ( 2 ,) ( 1 , 2 , 3 , 2 ) Remarque Pour utiliser un tuple d'un seul \u00e9l\u00e9ment, vous devez utiliser une syntaxe avec une virgule (element,), ceci pour \u00e9viter une ambigu\u00eft\u00e9 avec une simple expression. Autre particularit\u00e9 des tuples, il est possible d'en cr\u00e9er de nouveaux sans les parenth\u00e8ses, d\u00e8s lors que ceci ne pose pas d'ambigu\u00eft\u00e9 avec une autre expression : 1 2 3 4 5 6 >>> x = ( 1 , 2 , 3 ) >>> x ( 1 , 2 , 3 ) >>> x = 1 , 2 , 3 >>> x ( 1 , 2 , 3 ) Toutefois, nous vous conseillons d'utiliser syst\u00e9matiquement les parenth\u00e8ses afin d'\u00e9viter les confusions. Enfin, on peut utiliser la fonction tuple(sequence) qui fonctionne exactement comme la fonction list() , c'est-\u00e0-dire qu'elle prend en argument un objet s\u00e9quentiel et renvoie le tuple correspondant (op\u00e9ration de casting) : 1 2 3 4 >>> tuple ([ 1 , 2 , 3 ]) ( 1 , 2 , 3 ) >>> tuple ( \"ATGCCGCGAT\" ) ( 'A' , 'T' , 'G' , 'C' , 'C' , 'G' , 'C' , 'G' , 'A' , 'T' ) Remarque Les listes , les dictionnaires et les tuples sont des objets qui peuvent contenir des collections d'autres objets. On peut donc construire des listes qui contiennent des dictionnaires , des tuples ou d'autres listes , mais aussi des dictionnaires contenant des tuples , des listes , etc.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/collections/#iterations-sur-plusieurs-valeurs-a-la-fois","text":"Pratiquement, nous avons d\u00e9j\u00e0 crois\u00e9 les tuples avec la fonction enumerate() dans le chapitre 5 Boucles et comparaisons. Cette derni\u00e8re permettait d'it\u00e9rer en m\u00eame temps sur les indices et les \u00e9l\u00e9ments d'une liste : 1 2 3 4 5 6 7 8 9 10 11 12 >>> for i , elt in enumerate ([ 75 , - 75 , 0 ]): ... print ( i , elt ) ... 0 75 1 - 75 2 0 >>> for obj in enumerate ([ 75 , - 75 , 0 ]): ... print ( obj , type ( obj )) ... ( 0 , 75 ) < class ' tuple '> ( 1 , - 75 ) < class ' tuple '> ( 2 , 0 ) < class ' tuple '> En fin de compte, la fonction enumerate() it\u00e8re sur une s\u00e9rie de tuples . Pouvoir s\u00e9parer i et elt dans la boucle est possible du fait que Python autorise l'affectation multiple du style i, elt = 0, 75 (cf. rubrique suivante). Dans le m\u00eame ordre d'id\u00e9e, nous avons vu \u00e0 la rubrique pr\u00e9c\u00e9dente la m\u00e9thode .dict_items() qui permettait d'it\u00e9rer sur des couples cl\u00e9/valeur d'un dictionnaire : 1 2 3 4 5 6 7 8 9 10 11 >>> dico = { \"pinson\" : 2 , \"merle\" : 3 } >>> for key , val in dico . items (): ... print ( key , val ) ... pinson 2 merle 3 >>> for obj in dico . items (): ... print ( obj , type ( obj )) ... ( 'pinson' , 2 ) < class ' tuple '> ( 'merle' , 3 ) < class ' tuple '> On voit que cette m\u00e9thode .dict_items() it\u00e8re comme enumerate() sur une s\u00e9rie de tuples . Sur la m\u00eame base, on peut finalement it\u00e9rer sur 3 valeurs en m\u00eame temps \u00e0 partir d'une liste de tuples de 3 \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 9 >>> liste = [( i , i + 1 , i + 2 ) for i in range ( 5 , 8 )] >>> liste [( 5 , 6 , 7 ), ( 6 , 7 , 8 ), ( 7 , 8 , 9 )] >>> for x , y , z in liste : ... print ( x , y , z ) ... 5 6 7 6 7 8 7 8 9 On pourrait concevoir la m\u00eame chose sur 4 \u00e9l\u00e9ments, ou finalement autant que l'on veut. La seule restriction est d'avoir une correspondance syst\u00e9matique entre le nombre de variables d'it\u00e9ration (par exemple 3 ci-dessus avec x, y, z ) et la longueur de chaque sous-tuple de la liste sur laquelle on it\u00e8re (chaque sous-tuple a 3 \u00e9l\u00e9ments ci-dessus).","title":"It\u00e9rations sur plusieurs valeurs \u00e0 la fois"},{"location":"bts-sio-1/python/collections/#affectation-multiple-et-le-nom-de-variable-_","text":"L'affectation multiple est un m\u00e9canisme tr\u00e8s puissant et important en Python . Pour rappel, il permet d'effectuer sur une m\u00eame ligne plusieurs affectations en m\u00eame temps, par exemple : x, y, z = 1, 2, 3 . On voit que cette syntaxe correspond \u00e0 un tuple de chaque c\u00f4t\u00e9 de l'op\u00e9rateur = . Notez qu'il serait possible de le faire \u00e9galement avec les listes : [x, y, z] = [1, 2, 3] . Toutefois, cette syntaxe est alourdie par la pr\u00e9sence des crochets. On pr\u00e9f\u00e8rera donc la premi\u00e8re syntaxe avec les tuples sans parenth\u00e8se. Remarque Nous avons appel\u00e9 l'op\u00e9ration x, y, z = 1, 2, 3 affectation multiple pour signifier que l'on affectait des valeurs \u00e0 plusieurs variables en m\u00eame temps. Toutefois, vous pourrez rencontrer aussi l'expression tuple unpacking que l'on pourrait traduire par \u00ab d\u00e9sempaquetage de tuple \u00bb. Cela signifie que l'on d\u00e9compose le tuple initial 1, 2, 3 en 3 variables diff\u00e9rentes (comme si on vidait son sac \u00e0 dos, d'o\u00f9 le terme d\u00e9sempaquetage !). Nous avions crois\u00e9 l'importance de l'affectation multiple dans le chapitre 9 Fonctions lorsqu'une fonction renvoyait plusieurs valeurs. 1 2 3 4 5 6 >>> def fct (): ... return 3 , 14 ... >>> x , y = fct () >>> print ( x , y ) 3 14 La syntaxe x, y = fct() permet de r\u00e9cup\u00e9rer les 2 valeurs renvoy\u00e9es par la fonction et de les affecter \u00e0 la vol\u00e9e dans 2 variables diff\u00e9rentes. Cela \u00e9vite l'op\u00e9ration laborieuse de r\u00e9cup\u00e9rer d'abord le tuple , puis de cr\u00e9er les variables en utilisant l'indi\u00e7age : 1 2 3 4 5 6 7 >>> resultat = fct () >>> resultat ( 3 , 14 ) >>> x = resultat [ 0 ] >>> y = resultat [ 1 ] >>> print ( x , y ) 3 14 Remarque Lorsqu'une fonction renvoie plusieurs valeurs sous forme de tuple, ce sera bien s\u00fbr la forme x, y = fct() qui sera privil\u00e9gi\u00e9e. Quand une fonction renvoie plusieurs valeurs mais que l'on ne souhaite pas les utiliser toutes dans la suite du code, on peut utiliser le nom de variable _ (underscore) pour indiquer que certaines valeurs ne nous int\u00e9ressent pas : 1 2 3 4 5 6 7 8 >>> def fct (): ... return 1 , 2 , 3 , 4 ... >>> x , _ , y , _ = fct () >>> x 1 >>> y 3 Cela envoie le message \u00e0 celui qui lit le code \u00ab je me fiche des valeurs r\u00e9cup\u00e9r\u00e9es dans ces variables _ \u00bb. Notez que l'on peut utiliser une ou plusieurs variables underscores(s). Dans l'exemple ci-dessus, la 2\u00e8me et la 4\u00e8me variable renvoy\u00e9es par la fonction seront ignor\u00e9es dans la suite du code. Cela a le m\u00e9rite d'\u00e9viter la cr\u00e9ation de variables dont on ne se sert pas. Remarque La variable _ a une autre signication sp\u00e9ciale dans l'interpr\u00e9teur interactif, elle prend automatiquement la derni\u00e8re valeur affich\u00e9e : 1 2 3 4 5 6 7 8 >>> 3 3 >>> _ 3 >>> \"m\u00e9sange\" 'm\u00e9sange' >>> _ 'm\u00e9sange' Attention, cela n'est vrai que dans l'interpr\u00e9teur. Conseils Le underscore est couramment utilis\u00e9 dans les noms de variable pour s\u00e9parer les mots et \u00eatre explicite, par exemple seq_ADN ou liste_listes_residus. On verra dans le chapitre 15 Bonnes pratiques en programmation Python que ce style de nommage est appel\u00e9 snake_case. Toutefois, il faut \u00e9viter d'utiliser les underscores en d\u00e9but et/ou en fin de nom de variable (e.g. _var , var_ , __var , __var__ ). On verra au chapitre 19 Avoir la classe avec les objets que ces underscores ont une signification particuli\u00e8re.","title":"Affectation multiple et le nom de variable _"},{"location":"bts-sio-1/python/collections/#sets","text":"Les containers de type set repr\u00e9sentent un autre type d'objet s\u00e9quentiel qui peut se r\u00e9v\u00e9ler tr\u00e8s pratique. Ils ont la particularit\u00e9 d'\u00eatre non modifiables, non ordonn\u00e9s et de ne contenir qu'une seule copie maximum de chaque \u00e9l\u00e9ment. Pour cr\u00e9er un nouveau set on peut utiliser les accolades : 1 2 3 4 5 >>> s = { 1 , 2 , 3 , 3 } >>> s { 1 , 2 , 3 } >>> type ( s ) < class ' set '> Notez que la r\u00e9p\u00e9tition du 3 dans la d\u00e9finition du set en ligne 1 donne au final un seul 3 car chaque \u00e9l\u00e9ment ne peut \u00eatre pr\u00e9sent qu'une seule fois. A quoi diff\u00e9rencie-t-on un set d'un dictionnaire alors que les deux utilisent des accolades ? Le set sera d\u00e9fini seulement par des valeurs {val1, val2, ...} alors que le dictionnaire aura toujours des couples cl\u00e9/valeur {cl\u00e91: val1, cl\u00e92: val2, ...}. En g\u00e9n\u00e9ral, on utilisera la fonction interne \u00e0 Python set() pour g\u00e9n\u00e9rer un nouveau set. Celle-ci prend en argument n'importe quel objet it\u00e9rable et le convertit en set (op\u00e9ration de casting) : 1 2 3 4 5 6 7 8 9 10 11 12 >>> set ([ 1 , 2 , 4 , 1 ]) { 1 , 2 , 4 } >>> set (( 2 , 2 , 2 , 1 )) { 1 , 2 } >>> set ( range ( 5 )) { 0 , 1 , 2 , 3 , 4 } >>> set ({ \"cl\u00e91\" : 1 , \"cl\u00e92\" : 2 }) { 'cl\u00e91' , 'cl\u00e92' } >>> set ([ \"ti\" , \"to\" , \"to\" ]) { 'ti' , 'to' } >>> set ( \"Ma\u00eetre corbeau sur un arbre perch\u00e9\" ) { 'h' , 'u' , 'o' , 'b' , ' ' , 'M' , 'a' , 'p' , 'n' , 'e' , '\u00e9' , 'c' , '\u00ee' , 's' , 't' , 'r' } Nous avons dit plus haut que les sets ne sont pas ordonn\u00e9s, il est donc impossible de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment par sa position. Il est \u00e9galement impossible de modifier un de ses \u00e9l\u00e9ments. Par contre, les sets sont it\u00e9rables : 1 2 3 4 5 6 7 8 9 10 11 >>> s = set ([ 1 , 2 , 4 , 1 ]) >>> s [ 1 ] Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'set' object is not subscriptable >>> for elt in s : ... print ( elt ) ... 1 2 4 Les containers de type set sont tr\u00e8s utiles pour rechercher les \u00e9l\u00e9ments uniques d'une suite d'\u00e9l\u00e9ments. Cela revient \u00e0 \u00e9liminer tous les doublons. Par exemple : 1 2 3 4 5 6 >>> import random as rd >>> l = [ rd . randint ( 0 , 9 ) for i in range ( 10 )] >>> l [ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ] >>> set ( l ) { 3 , 5 , 6 , 7 , 8 , 9 } On peut bien s\u00fbr transformer dans l'autre sens un set en liste. Cela permet par exemple d'\u00e9liminer les doublons de la liste initiale tout en r\u00e9cup\u00e9rant une liste \u00e0 la fin : 1 2 >>> list ( set ([ 7 , 9 , 6 , 6 , 7 , 3 , 8 , 5 , 6 , 7 ])) [ 3 , 5 , 6 , 7 , 8 , 9 ] On peut faire des choses tr\u00e8s puissantes. Par exemple, un compteur de lettres en combinaison avec une liste de compr\u00e9hension, le tout en une ligne ! 1 2 3 4 5 >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> set ( seq ) { 'c' , 'g' , 't' , 'a' } >>> [( base , seq . count ( base )) for base in set ( seq )] [( 'c' , 15 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'a' , 10 )] Les sets permettent aussi l'\u00e9valuation d'union ou d'intersection math\u00e9matiques en conjonction avec les op\u00e9rateurs respectivement | et & : 1 2 3 4 5 6 >>> l = [ 3 , 3 , 5 , 1 , 3 , 4 , 1 , 1 , 4 , 4 ] >>> l2 = [ 3 , 0 , 5 , 3 , 3 , 1 , 1 , 1 , 2 , 2 ] >>> set ( l ) & set ( l2 ) { 1 , 3 , 5 } >>> set ( l ) | set ( l2 ) { 0 , 1 , 2 , 3 , 4 , 5 } Conseil : Pour aller plus loin, vous pouvez consulter deux articles sur les sites programiz et towardsdatascience.","title":"Sets"},{"location":"bts-sio-1/python/collections/#dictionnaires-et-sets-de-comprehension","text":"Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Nous avons vu au chapitre 11 Plus sur les listes les listes de compr\u00e9hension. Il est \u00e9galement possible de g\u00e9n\u00e9rer des dictionnaires de compr\u00e9hension : 1 2 3 4 5 6 7 8 9 10 11 12 >>> dico = { \"a\" : 10 , \"g\" : 10 , \"t\" : 11 , \"c\" : 15 } >>> dico . items () dict_items ([( 'a' , 10 ), ( 'g' , 10 ), ( 't' , 11 ), ( 'c' , 15 )]) >>> { key : val * 2 for key , val in dico . items ()} { 'a' : 20 , 'g' : 20 , 't' : 22 , 'c' : 30 } >>> >>> { key : val for key , val in enumerate ( \"toto\" )} { 0 : 't' , 1 : 'o' , 2 : 't' , 3 : 'o' } >>> >>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\" >>> { base : seq . count ( base ) for base in set ( seq )} { 'a' : 10 , 'g' : 10 , 't' : 11 , 'c' : 15 } De mani\u00e8re g\u00e9n\u00e9rale, tout objet sur lequel on peut faire une double it\u00e9ration du type for var1, var2 in obj est utilisable pour cr\u00e9er un dictionnaire de compr\u00e9hension. Si vous souhaitez aller plus loin, vous pouvez consulter cet article sur le site Datacamp. Il est \u00e9galement possible de g\u00e9n\u00e9rer des sets de compr\u00e9hension sur le m\u00eame mod\u00e8le que les listes de compr\u00e9hension : 1 2 3 4 >>> { i for i in range ( 10 )} { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } >>> { i ** 2 for i in range ( 10 )} { 0 , 1 , 64 , 4 , 36 , 9 , 16 , 49 , 81 , 25 }","title":"Dictionnaires et sets de compr\u00e9hension"},{"location":"bts-sio-1/python/collections/#module-collections","text":"Conseil : pour les d\u00e9butants, vous pouvez passer cette rubrique. Le module collections contient d'autres types de containers qui peuvent se r\u00e9v\u00e9ler utiles, c'est une v\u00e9ritable mine d'or ! Nous n'aborderons pas tous ces objets ici, mais nous pouvons citer tout de m\u00eame certains d'entre eux si vous souhaitez aller un peu plus loin : les dictionnaires ordonn\u00e9s qui se comportent comme les dictionnaires classiques mais qui sont ordonn\u00e9s ; les defaultdicts permettant de g\u00e9n\u00e9rer des valeurs par d\u00e9faut quand on demande une cl\u00e9 qui n'existe pas (cela \u00e9vite que Python g\u00e9n\u00e8re une erreur) ; les compteurs dont un exemple est montr\u00e9 ci-dessous ; les namedtuples que nous \u00e9voquerons au chapitre 19 Avoir la classe avec les objets. L'objet collection.Counter() est particuli\u00e8rement int\u00e9ressant et simple \u00e0 utiliser. Il cr\u00e9e des compteurs \u00e0 partir d'objets it\u00e9rables, par exemple : 1 2 3 4 5 6 7 8 9 10 >>> import collections >>> compo_seq = collections . Counter ( \"aatctccgatcgatcgatcgatgatc\" ) >>> compo_seq Counter ({ 'a' : 7 , 't' : 7 , 'c' : 7 , 'g' : 5 }) >>> type ( compo_seq ) < class ' collections . Counter '> >>> compo_seq [ \"a\" ] 7 >>> compo_seq [ \"n\" ] 0 On voit que Python a automatiquement compt\u00e9 chaque atgc de la cha\u00eene de caract\u00e8res pass\u00e9e en argument ! Cela cr\u00e9e un objet de type Counterqui se comporte ensuite comme un dictionnaire, \u00e0 une exception pr\u00e8s : si on appelle une cl\u00e9 qui n'existe pas dans l'it\u00e9rable initiale (comme le n ci-dessus) cela renvoie 0.","title":"Module collections"},{"location":"bts-sio-1/python/fichiers/","text":"Fichiers Lecture dans un fichier Une grande partie de l'information en Data Science est stock\u00e9e dans des fichiers. Pour traiter cette information, vous devez le plus souvent lire ou \u00e9crire dans un ou plusieurs fichiers. Python poss\u00e8de pour cela de nombreux outils qui vous simplifient la vie. M\u00e9thode .readlines() Avant de passer \u00e0 un exemple concret, cr\u00e9ez un fichier dans un \u00e9diteur de texte que vous enregistrerez dans votre r\u00e9pertoire courant avec le nom zoo.txt et le contenu suivant : 1 2 3 4 girafe tigre singe souris Ensuite, testez le code suivant dans l'interpr\u00e9teur Python : ````python {.line-numbers} filin = open(\"zoo.txt\", \"r\") filin <_io.TextIOWrapper name='zoo.txt' mode='r' encoding='UTF-8'> filin.readlines() ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] filin.close() filin.readlines() Traceback (most recent call last): File \" \", line 1, in ValueError: I/O operation on closed file. ```` Il y a plusieurs commentaires \u00e0 faire sur cet exemple : Ligne 1. L'instruction open() ouvre le fichier zoo.txt . Ce fichier est ouvert en lecture seule, comme l'indique le second argument r (pour read ) de la fonction open() . Remarquez que le fichier n'est pas encore lu, mais simplement ouvert (un peu comme lorsqu'on ouvre un livre, mais qu'on ne l'a pas encore lu). Le curseur de lecture est pr\u00eat \u00e0 lire le premier caract\u00e8re du fichier. L'instruction open(\"zoo.txt\", \"r\") suppose que le fichier zoo.txt est dans le r\u00e9pertoire depuis lequel l'interpr\u00e9teur Python a \u00e9t\u00e9 lanc\u00e9. Si ce n'est pas le cas, il faut pr\u00e9ciser le chemin d'acc\u00e8s au fichier. Par exemple, /home/pierre/zoo.txt pour Linux ou Mac OS X ou C:\\Users\\pierre\\zoo.txt pour Windows . Ligne 2. Lorsqu'on affiche le contenu de la variable filin, on se rend compte que Python la consid\u00e8re comme un objet de type fichier ouvert (ligne 3). Ligne 4. Nous utilisons \u00e0 nouveau la syntaxe objet.m\u00e9thode() . Ici la m\u00e9thode .readlines() agit sur l'objet filin en d\u00e9pla\u00e7ant le curseur de lecture du d\u00e9but \u00e0 la fin du fichier, puis elle renvoie une liste contenant toutes les lignes du fichier (dans notre analogie avec un livre, ceci correspondrait \u00e0 lire toutes les lignes du livre). Ligne 6. Enfin, on applique la m\u00e9thode .close() sur l'objet filin , ce qui, vous vous en doutez, ferme le fichier (ceci correspondrait \u00e0 fermer le livre). Vous remarquerez que la m\u00e9thode .close() ne renvoie rien mais modifie l'\u00e9tat de l'objet filin en fichier ferm\u00e9. Ainsi, si on essaie de lire \u00e0 nouveau les lignes du fichier, Python renvoie une erreur car il ne peut pas lire un fichier ferm\u00e9 (lignes 7 \u00e0 10). Voici maintenant un exemple complet de lecture d'un fichier avec Python . ```python filin = open(\"zoo.txt\", \"r\") lignes = filin.readlines() lignes ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] for ligne in lignes: ... print(ligne) ... girafe tigre singe souris filin.close() ``` Vous voyez qu'en cinq lignes de code, vous avez lu, parcouru le fichier et affich\u00e9 son contenu. Remarque Chaque \u00e9l\u00e9ment de la liste lignes est une cha\u00eene de caract\u00e8res. C'est en effet sous forme de cha\u00eenes de caract\u00e8res que Python lit le contenu d'un fichier. Chaque \u00e9l\u00e9ment de la liste lignes se termine par le caract\u00e8re \\n . Ce caract\u00e8re un peu particulier correspond au \u00ab saut de ligne \u00bb qui permet de passer d'une ligne \u00e0 la suivante. Ceci est cod\u00e9 par un caract\u00e8re sp\u00e9cial que l'on repr\u00e9sente par \\n . Par d\u00e9faut, l'instruction print() affiche quelque chose puis revient \u00e0 la ligne. Ce retour \u00e0 la ligne d\u00fb \u00e0 print() se cumule alors avec celui de la fin de ligne ( \\n ) de chaque ligne du fichier et donne l'impression qu'une ligne est saut\u00e9e \u00e0 chaque fois. Il existe en Python le mot-cl\u00e9 with qui permet d'ouvrir et de fermer un fichier de mani\u00e8re efficace. Si pour une raison ou une autre l'ouverture ou la lecture du fichier conduit \u00e0 une erreur, l'utilisation de with garantit la bonne fermeture du fichier, ce qui n'est pas le cas dans le code pr\u00e9c\u00e9dent. Voici donc le m\u00eame exemple avec with : ```python with open(\"zoo.txt\", 'r') as filin: ... lignes = filin.readlines() ... for ligne in lignes: ... print(ligne) ... girafe tigre singe souris ``` Remarque L'instruction with introduit un bloc d'indentation. C'est \u00e0 l'int\u00e9rieur de ce bloc que nous effectuons toutes les op\u00e9rations sur le fichier. Une fois sorti du bloc d'indentation, Python fermera automatiquement le fichier. Vous n'avez donc plus besoin d\u2019utiliser la m\u00e9thode .close() . M\u00e9thode .read() Il existe d'autres m\u00e9thodes que .readlines() pour lire (et manipuler) un fichier. Par exemple, la m\u00e9thode .read() lit tout le contenu d'un fichier et renvoie une cha\u00eene de caract\u00e8res unique. ```python with open(\"zoo.txt\", \"r\") as filin: ... filin.read() ... 'girafe\\ntigre\\nsinge\\nsouris\\n' ``` M\u00e9thode .readline() La m\u00e9thode .readline() (sans s \u00e0 la fin) lit une ligne d'un fichier et la renvoie sous forme de cha\u00eene de caract\u00e8res. \u00c0 chaque nouvel appel de .readline() , la ligne suivante est renvoy\u00e9e. Associ\u00e9e \u00e0 la boucle while , cette m\u00e9thode permet de lire un fichier ligne par ligne. ```python with open(\"zoo.txt\", \"r\") as filin: ... ligne = filin.readline() ... while ligne != \"\": ... print(ligne) ... ligne = filin.readline() ... girafe tigre singe souris ``` It\u00e9rations directe sur le fichier Python essaie de vous faciliter la vie au maximum. Voici un moyen \u00e0 la fois simple et \u00e9l\u00e9gant de parcourir un fichier. ```python with open(\"zoo.txt\", \"r\") as filin: ... for ligne in filin: ... print(ligne) ... girafe tigre singe souris ``` L'objet filin est \u00ab it\u00e9rable \u00bb, ainsi la boucle for va demander \u00e0 Python d'aller lire le fichier ligne par ligne. Conseils Privil\u00e9giez cette m\u00e9thode par la suite. Remarque Les m\u00e9thodes abord\u00e9es pr\u00e9c\u00e9demment permettent d'acc\u00e9der au contenu d'un fichier, soit ligne par ligne (m\u00e9thode .readline() ), soit globalement en une seule cha\u00eene de caract\u00e8res (m\u00e9thode .read() ), soit globalement avec les lignes diff\u00e9renci\u00e9es sous forme d'une liste de cha\u00eenes de caract\u00e8res (m\u00e9thode .readlines() ). Il est \u00e9galement possible en Python de se rendre \u00e0 un endroit particulier d'un fichier avec la m\u00e9thode .seek() mais qui sort du cadre de cet ouvrage. \u00c9criture dans un fichier \u00c9crire dans un fichier est aussi simple que de le lire. Voyez l'exemple suivant : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(animal) ... 7 7 4 ``` Quelques commentaires sur cet exemple : Ligne 1. Cr\u00e9ation d'une liste de cha\u00eenes de caract\u00e8res animaux2 . Ligne 2. Ouverture du fichier zoo2.txt en mode \u00e9criture, avec le caract\u00e8re w pour write . L'instruction with cr\u00e9e un bloc d'instructions qui doit \u00eatre indent\u00e9. Ligne 3. Parcours de la liste animaux2 avec une boucle for . Ligne 4. \u00c0 chaque it\u00e9ration de la boucle, nous avons \u00e9crit chaque \u00e9l\u00e9ment de la liste dans le fichier. La m\u00e9thode .write() s'applique sur l'objet filout . Notez qu'\u00e0 chaque utilisation de la m\u00e9thode .write() , celle-ci nous affiche le nombre d'octets (\u00e9quivalent au nombre de caract\u00e8res) \u00e9crits dans le fichier (lignes 6 \u00e0 8). Ceci est valable uniquement dans l'interpr\u00e9teur, si vous cr\u00e9ez un programme avec les m\u00eames lignes de code, ces valeurs ne s'afficheront pas \u00e0 l'\u00e9cran. Si nous ouvrons le fichier zoo2.txt avec un \u00e9diteur de texte, voici ce que nous obtenons : poissonabeillechat Ce n'est pas exactement le r\u00e9sultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne. Nous avons oubli\u00e9 d'ajouter le caract\u00e8re fin de ligne apr\u00e8s chaque nom d'animal. Pour ce faire, nous pouvons utiliser l'\u00e9criture format\u00e9e : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(f\"{animal}\\n\") ... 8 8 5 ``` Ligne 4. L'\u00e9criture format\u00e9e permet d'ajouter un retour \u00e0 la ligne ( \\n ) apr\u00e8s le nom de chaque animal. Lignes 6 \u00e0 8. Le nombre d'octets \u00e9crits dans le fichier est augment\u00e9 de 1 par rapport \u00e0 l'exemple pr\u00e9c\u00e9dent car le caract\u00e8re retour \u00e0 la ligne compte pour un seul octet. Le contenu du fichier zoo2.txt est alors : python poisson abeille chat Vous voyez qu'il est extr\u00eamement simple en Python de lire ou d'\u00e9crire dans un fichier. Ouvrir deux fichiers avec l'instruction with On peut avec l'instruction with ouvrir deux fichiers (ou plus) en m\u00eame temps. Voyez l'exemple suivant : python with open(\"zoo.txt\", \"r\") as fichier1, open(\"zoo2.txt\", \"w\") as fichier2: for ligne in fichier1: fichier2.write(\"* \" + ligne) Si le fichier zoo.txt contient le texte suivant : python souris girafe lion singe alors le contenu de zoo2.txt sera : python * souris * girafe * lion * singe Dans cet exemple, with permet une notation tr\u00e8s compacte en s'affranchissant de deux m\u00e9thodes .close() . Sachez que l'instruction with est plus g\u00e9n\u00e9rale et est utilisable dans d'autres contextes.","title":"Fichiers"},{"location":"bts-sio-1/python/fichiers/#fichiers","text":"","title":"Fichiers"},{"location":"bts-sio-1/python/fichiers/#lecture-dans-un-fichier","text":"Une grande partie de l'information en Data Science est stock\u00e9e dans des fichiers. Pour traiter cette information, vous devez le plus souvent lire ou \u00e9crire dans un ou plusieurs fichiers. Python poss\u00e8de pour cela de nombreux outils qui vous simplifient la vie.","title":"Lecture dans un fichier"},{"location":"bts-sio-1/python/fichiers/#methode-readlines","text":"Avant de passer \u00e0 un exemple concret, cr\u00e9ez un fichier dans un \u00e9diteur de texte que vous enregistrerez dans votre r\u00e9pertoire courant avec le nom zoo.txt et le contenu suivant : 1 2 3 4 girafe tigre singe souris Ensuite, testez le code suivant dans l'interpr\u00e9teur Python : ````python {.line-numbers} filin = open(\"zoo.txt\", \"r\") filin <_io.TextIOWrapper name='zoo.txt' mode='r' encoding='UTF-8'> filin.readlines() ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] filin.close() filin.readlines() Traceback (most recent call last): File \" \", line 1, in ValueError: I/O operation on closed file. ```` Il y a plusieurs commentaires \u00e0 faire sur cet exemple : Ligne 1. L'instruction open() ouvre le fichier zoo.txt . Ce fichier est ouvert en lecture seule, comme l'indique le second argument r (pour read ) de la fonction open() . Remarquez que le fichier n'est pas encore lu, mais simplement ouvert (un peu comme lorsqu'on ouvre un livre, mais qu'on ne l'a pas encore lu). Le curseur de lecture est pr\u00eat \u00e0 lire le premier caract\u00e8re du fichier. L'instruction open(\"zoo.txt\", \"r\") suppose que le fichier zoo.txt est dans le r\u00e9pertoire depuis lequel l'interpr\u00e9teur Python a \u00e9t\u00e9 lanc\u00e9. Si ce n'est pas le cas, il faut pr\u00e9ciser le chemin d'acc\u00e8s au fichier. Par exemple, /home/pierre/zoo.txt pour Linux ou Mac OS X ou C:\\Users\\pierre\\zoo.txt pour Windows . Ligne 2. Lorsqu'on affiche le contenu de la variable filin, on se rend compte que Python la consid\u00e8re comme un objet de type fichier ouvert (ligne 3). Ligne 4. Nous utilisons \u00e0 nouveau la syntaxe objet.m\u00e9thode() . Ici la m\u00e9thode .readlines() agit sur l'objet filin en d\u00e9pla\u00e7ant le curseur de lecture du d\u00e9but \u00e0 la fin du fichier, puis elle renvoie une liste contenant toutes les lignes du fichier (dans notre analogie avec un livre, ceci correspondrait \u00e0 lire toutes les lignes du livre). Ligne 6. Enfin, on applique la m\u00e9thode .close() sur l'objet filin , ce qui, vous vous en doutez, ferme le fichier (ceci correspondrait \u00e0 fermer le livre). Vous remarquerez que la m\u00e9thode .close() ne renvoie rien mais modifie l'\u00e9tat de l'objet filin en fichier ferm\u00e9. Ainsi, si on essaie de lire \u00e0 nouveau les lignes du fichier, Python renvoie une erreur car il ne peut pas lire un fichier ferm\u00e9 (lignes 7 \u00e0 10). Voici maintenant un exemple complet de lecture d'un fichier avec Python . ```python filin = open(\"zoo.txt\", \"r\") lignes = filin.readlines() lignes ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n'] for ligne in lignes: ... print(ligne) ... girafe tigre singe souris filin.close() ``` Vous voyez qu'en cinq lignes de code, vous avez lu, parcouru le fichier et affich\u00e9 son contenu. Remarque Chaque \u00e9l\u00e9ment de la liste lignes est une cha\u00eene de caract\u00e8res. C'est en effet sous forme de cha\u00eenes de caract\u00e8res que Python lit le contenu d'un fichier. Chaque \u00e9l\u00e9ment de la liste lignes se termine par le caract\u00e8re \\n . Ce caract\u00e8re un peu particulier correspond au \u00ab saut de ligne \u00bb qui permet de passer d'une ligne \u00e0 la suivante. Ceci est cod\u00e9 par un caract\u00e8re sp\u00e9cial que l'on repr\u00e9sente par \\n . Par d\u00e9faut, l'instruction print() affiche quelque chose puis revient \u00e0 la ligne. Ce retour \u00e0 la ligne d\u00fb \u00e0 print() se cumule alors avec celui de la fin de ligne ( \\n ) de chaque ligne du fichier et donne l'impression qu'une ligne est saut\u00e9e \u00e0 chaque fois. Il existe en Python le mot-cl\u00e9 with qui permet d'ouvrir et de fermer un fichier de mani\u00e8re efficace. Si pour une raison ou une autre l'ouverture ou la lecture du fichier conduit \u00e0 une erreur, l'utilisation de with garantit la bonne fermeture du fichier, ce qui n'est pas le cas dans le code pr\u00e9c\u00e9dent. Voici donc le m\u00eame exemple avec with : ```python with open(\"zoo.txt\", 'r') as filin: ... lignes = filin.readlines() ... for ligne in lignes: ... print(ligne) ... girafe tigre singe souris ``` Remarque L'instruction with introduit un bloc d'indentation. C'est \u00e0 l'int\u00e9rieur de ce bloc que nous effectuons toutes les op\u00e9rations sur le fichier. Une fois sorti du bloc d'indentation, Python fermera automatiquement le fichier. Vous n'avez donc plus besoin d\u2019utiliser la m\u00e9thode .close() .","title":"M\u00e9thode .readlines()"},{"location":"bts-sio-1/python/fichiers/#methode-read","text":"Il existe d'autres m\u00e9thodes que .readlines() pour lire (et manipuler) un fichier. Par exemple, la m\u00e9thode .read() lit tout le contenu d'un fichier et renvoie une cha\u00eene de caract\u00e8res unique. ```python with open(\"zoo.txt\", \"r\") as filin: ... filin.read() ... 'girafe\\ntigre\\nsinge\\nsouris\\n' ```","title":"M\u00e9thode .read()"},{"location":"bts-sio-1/python/fichiers/#methode-readline","text":"La m\u00e9thode .readline() (sans s \u00e0 la fin) lit une ligne d'un fichier et la renvoie sous forme de cha\u00eene de caract\u00e8res. \u00c0 chaque nouvel appel de .readline() , la ligne suivante est renvoy\u00e9e. Associ\u00e9e \u00e0 la boucle while , cette m\u00e9thode permet de lire un fichier ligne par ligne. ```python with open(\"zoo.txt\", \"r\") as filin: ... ligne = filin.readline() ... while ligne != \"\": ... print(ligne) ... ligne = filin.readline() ... girafe tigre singe souris ```","title":"M\u00e9thode .readline()"},{"location":"bts-sio-1/python/fichiers/#iterations-directe-sur-le-fichier","text":"Python essaie de vous faciliter la vie au maximum. Voici un moyen \u00e0 la fois simple et \u00e9l\u00e9gant de parcourir un fichier. ```python with open(\"zoo.txt\", \"r\") as filin: ... for ligne in filin: ... print(ligne) ... girafe tigre singe souris ``` L'objet filin est \u00ab it\u00e9rable \u00bb, ainsi la boucle for va demander \u00e0 Python d'aller lire le fichier ligne par ligne. Conseils Privil\u00e9giez cette m\u00e9thode par la suite. Remarque Les m\u00e9thodes abord\u00e9es pr\u00e9c\u00e9demment permettent d'acc\u00e9der au contenu d'un fichier, soit ligne par ligne (m\u00e9thode .readline() ), soit globalement en une seule cha\u00eene de caract\u00e8res (m\u00e9thode .read() ), soit globalement avec les lignes diff\u00e9renci\u00e9es sous forme d'une liste de cha\u00eenes de caract\u00e8res (m\u00e9thode .readlines() ). Il est \u00e9galement possible en Python de se rendre \u00e0 un endroit particulier d'un fichier avec la m\u00e9thode .seek() mais qui sort du cadre de cet ouvrage.","title":"It\u00e9rations directe sur le fichier"},{"location":"bts-sio-1/python/fichiers/#ecriture-dans-un-fichier","text":"\u00c9crire dans un fichier est aussi simple que de le lire. Voyez l'exemple suivant : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(animal) ... 7 7 4 ``` Quelques commentaires sur cet exemple : Ligne 1. Cr\u00e9ation d'une liste de cha\u00eenes de caract\u00e8res animaux2 . Ligne 2. Ouverture du fichier zoo2.txt en mode \u00e9criture, avec le caract\u00e8re w pour write . L'instruction with cr\u00e9e un bloc d'instructions qui doit \u00eatre indent\u00e9. Ligne 3. Parcours de la liste animaux2 avec une boucle for . Ligne 4. \u00c0 chaque it\u00e9ration de la boucle, nous avons \u00e9crit chaque \u00e9l\u00e9ment de la liste dans le fichier. La m\u00e9thode .write() s'applique sur l'objet filout . Notez qu'\u00e0 chaque utilisation de la m\u00e9thode .write() , celle-ci nous affiche le nombre d'octets (\u00e9quivalent au nombre de caract\u00e8res) \u00e9crits dans le fichier (lignes 6 \u00e0 8). Ceci est valable uniquement dans l'interpr\u00e9teur, si vous cr\u00e9ez un programme avec les m\u00eames lignes de code, ces valeurs ne s'afficheront pas \u00e0 l'\u00e9cran. Si nous ouvrons le fichier zoo2.txt avec un \u00e9diteur de texte, voici ce que nous obtenons : poissonabeillechat Ce n'est pas exactement le r\u00e9sultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne. Nous avons oubli\u00e9 d'ajouter le caract\u00e8re fin de ligne apr\u00e8s chaque nom d'animal. Pour ce faire, nous pouvons utiliser l'\u00e9criture format\u00e9e : ```python animaux2 = [\"poisson\", \"abeille\", \"chat\"] with open(\"zoo2.txt\", \"w\") as filout: ... for animal in animaux2: ... filout.write(f\"{animal}\\n\") ... 8 8 5 ``` Ligne 4. L'\u00e9criture format\u00e9e permet d'ajouter un retour \u00e0 la ligne ( \\n ) apr\u00e8s le nom de chaque animal. Lignes 6 \u00e0 8. Le nombre d'octets \u00e9crits dans le fichier est augment\u00e9 de 1 par rapport \u00e0 l'exemple pr\u00e9c\u00e9dent car le caract\u00e8re retour \u00e0 la ligne compte pour un seul octet. Le contenu du fichier zoo2.txt est alors : python poisson abeille chat Vous voyez qu'il est extr\u00eamement simple en Python de lire ou d'\u00e9crire dans un fichier.","title":"\u00c9criture dans un fichier"},{"location":"bts-sio-1/python/fichiers/#ouvrir-deux-fichiers-avec-linstruction-with","text":"On peut avec l'instruction with ouvrir deux fichiers (ou plus) en m\u00eame temps. Voyez l'exemple suivant : python with open(\"zoo.txt\", \"r\") as fichier1, open(\"zoo2.txt\", \"w\") as fichier2: for ligne in fichier1: fichier2.write(\"* \" + ligne) Si le fichier zoo.txt contient le texte suivant : python souris girafe lion singe alors le contenu de zoo2.txt sera : python * souris * girafe * lion * singe Dans cet exemple, with permet une notation tr\u00e8s compacte en s'affranchissant de deux m\u00e9thodes .close() . Sachez que l'instruction with est plus g\u00e9n\u00e9rale et est utilisable dans d'autres contextes.","title":"Ouvrir deux fichiers avec l'instruction with"},{"location":"bts-sio-1/python/fonction/","text":"Fonctions Principe et g\u00e9n\u00e9ralit\u00e9s En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions . D\u00e9finition Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat. Passage d'arguments Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre. Renvoi de r\u00e9sultats Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes. Arguments positionnels et arguments par mot-cl\u00e9 Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant : d\u00e9finition d'une fonction carre() def carre(x): y = x**2 return y programme principal z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"Fonctions"},{"location":"bts-sio-1/python/fonction/#fonctions","text":"","title":"Fonctions"},{"location":"bts-sio-1/python/fonction/#principe-et-generalites","text":"En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions .","title":"Principe et g\u00e9n\u00e9ralit\u00e9s"},{"location":"bts-sio-1/python/fonction/#definition","text":"Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/fonction/#passage-darguments","text":"Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre.","title":"Passage d'arguments"},{"location":"bts-sio-1/python/fonction/#renvoi-de-resultats","text":"Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes.","title":"Renvoi de r\u00e9sultats"},{"location":"bts-sio-1/python/fonction/#arguments-positionnels-et-arguments-par-mot-cle","text":"Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant :","title":"Arguments positionnels et arguments par mot-cl\u00e9"},{"location":"bts-sio-1/python/fonction/#definition-dune-fonction-carre","text":"def carre(x): y = x**2 return y","title":"d\u00e9finition d'une fonction carre()"},{"location":"bts-sio-1/python/fonction/#programme-principal","text":"z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"programme principal"},{"location":"bts-sio-1/python/listes/","text":"Listes D\u00e9finition Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie. Utilisation Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus ! Op\u00e9ration sur les listes Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes. Indi\u00e7age n\u00e9gatif La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] . Tranches Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] . Fonction len() L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8 Les fonctions range() et list() L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] Listes de listes Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler. Minimum, maximum et somme d'une liste Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Listes"},{"location":"bts-sio-1/python/listes/#listes","text":"","title":"Listes"},{"location":"bts-sio-1/python/listes/#definition","text":"Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/listes/#utilisation","text":"Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus !","title":"Utilisation"},{"location":"bts-sio-1/python/listes/#operation-sur-les-listes","text":"Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes.","title":"Op\u00e9ration sur les listes"},{"location":"bts-sio-1/python/listes/#indicage-negatif","text":"La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] .","title":"Indi\u00e7age n\u00e9gatif"},{"location":"bts-sio-1/python/listes/#tranches","text":"Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] .","title":"Tranches"},{"location":"bts-sio-1/python/listes/#fonction-len","text":"L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8","title":"Fonction len()"},{"location":"bts-sio-1/python/listes/#les-fonctions-range-et-list","text":"L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ]","title":"Les fonctions range() et list()"},{"location":"bts-sio-1/python/listes/#listes-de-listes","text":"Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler.","title":"Listes de listes"},{"location":"bts-sio-1/python/listes/#minimum-maximum-et-somme-dune-liste","text":"Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Minimum, maximum et somme d'une liste"},{"location":"bts-sio-1/python/tests/","text":"Tests D\u00e9finition Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb. Tests \u00e0 plusieurs cas Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if . Importance de l'indentation De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb . Tests multiples Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False Instructions break et continue Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4 Tests de valeur sur des floats Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests"},{"location":"bts-sio-1/python/tests/#tests","text":"","title":"Tests"},{"location":"bts-sio-1/python/tests/#definition","text":"Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb.","title":"D\u00e9finition"},{"location":"bts-sio-1/python/tests/#tests-a-plusieurs-cas","text":"Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if .","title":"Tests \u00e0 plusieurs cas"},{"location":"bts-sio-1/python/tests/#importance-de-lindentation","text":"De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb .","title":"Importance de l'indentation"},{"location":"bts-sio-1/python/tests/#tests-multiples","text":"Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False","title":"Tests multiples"},{"location":"bts-sio-1/python/tests/#instructions-break-et-continue","text":"Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4","title":"Instructions break et continue"},{"location":"bts-sio-1/python/tests/#tests-de-valeur-sur-des-floats","text":"Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests de valeur sur des floats"},{"location":"bts-sio-2/cybersecurite/authentification_principes/","text":"Les principes de l'authentification Introduction Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter. Objectif de l'authentification Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages. OBJECTIFS Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts. Facteurs de l'authentification OBJECTIFS L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e. 1 FACTEUR = AUTHENTIFICATION SIMPLE L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple. PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe. Limites des facteurs d'authentification LA BIOM\u00c9TRIE De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons. LIMITES DE LA BIOM\u00c9TRIE Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place . EXEMPLE EN BELGIQUE Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes. Les risques li\u00e9s aux mots de passe Pr\u00e9sentation Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques . Divulgation M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance. N\u00e9gligeance On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection . Malveillance La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9. Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours. Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ; Conclusion L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Les principes de l'authentification"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#les-principes-de-lauthentification","text":"","title":"Les principes de l'authentification"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#introduction","text":"Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter.","title":"Introduction"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#objectif-de-lauthentification","text":"Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages.","title":"Objectif de l'authentification"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#objectifs","text":"Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts.","title":"OBJECTIFS"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#facteurs-de-lauthentification","text":"","title":"Facteurs de l'authentification"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#objectifs_1","text":"L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e.","title":"OBJECTIFS"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#1-facteur-authentification-simple","text":"L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple.","title":"1 FACTEUR = AUTHENTIFICATION SIMPLE"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#plusieurs-facteurs-authentification-forte","text":"Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe.","title":"PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#limites-des-facteurs-dauthentification","text":"","title":"Limites des facteurs d'authentification"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#la-biometrie","text":"De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons.","title":"LA BIOM\u00c9TRIE"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#limites-de-la-biometrie","text":"Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place .","title":"LIMITES DE LA BIOM\u00c9TRIE"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#exemple-en-belgique","text":"Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes.","title":"EXEMPLE EN BELGIQUE"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#les-risques-lies-aux-mots-de-passe","text":"","title":"Les risques li\u00e9s aux mots de passe"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#presentation","text":"Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques .","title":"Pr\u00e9sentation"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#divulgation","text":"M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance.","title":"Divulgation"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#negligeance","text":"On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection .","title":"N\u00e9gligeance"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#malveillance","text":"La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9.","title":"Malveillance"},{"location":"bts-sio-2/cybersecurite/authentification_principes/#ces-differentes-causes-de-divulgation-seront-abordees-en-detail-dans-la-suite-de-ce-cours","text":"Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ;","title":"Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours."},{"location":"bts-sio-2/cybersecurite/authentification_principes/#conclusion","text":"L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Conclusion"},{"location":"bts-sio-2/cybersecurite/rgpd/","text":"Qu'est-ce que le RGPD ? Le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es ou RGPD remplace l'ensemble de la l\u00e9gislation sur les donn\u00e9es nominatives issue de la loi de 1978. Le RGPD, c\u2019est avant tout une d\u00e9marche \u00e0 suivre. Voici les quelques axes principaux : \u00eatre responsable de son traitement de donn\u00e9es , des objectifs et des moyens que celui-ci implique ; faire la liste des traitements de donn\u00e9es ; trier les donn\u00e9es et identifier les risques ; respecter les droits des personnes ; s\u00e9curiser les donn\u00e9es ; tout documenter . L\u2019utilisation digitale du marketing pose \u00e0 chaque fois la question des donn\u00e9es personnelles. C\u2019est le cas des statistiques ou du profilage des internautes. Sans revenir en d\u00e9tail sur l'int\u00e9gralit\u00e9 de cette r\u00e8gle, il convient de comprendre son fonctionnement et son impact pour la cr\u00e9ation et l'utilisation de supports marketing ou de communication. La RDGP et l\u2019accountability Contrairement aux dispositions pr\u00e9c\u00e9dentes, le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es supprime les obligations de d\u00e9claration pr\u00e9alable et met en responsabilit\u00e9 chaque annonceur. Note En un mot, vous devez y penser avant de commencer votre projet. Vous ne d\u00e9clarez plus rien mais \u00eates responsable de votre action. Le cadre de l'application du RGPD n'est plus d\u00e9claratif, mais il vous appartient de rapporter la preuve de la conformit\u00e9 de la gestion des donn\u00e9es personnelles et de la s\u00e9curit\u00e9 de celles-ci. En cas de contr\u00f4le des autorit\u00e9s, il vous faudra justifier de ces points de fa\u00e7on document\u00e9e. C\u2019est ce que la CNIL appelle l\u2019 accountability . Selon elle, c\u2019est \u00ab l\u2019obligation pour les entreprises de mettre en \u0153uvre des m\u00e9canismes et des proc\u00e9dures internes permettant de d\u00e9montrer le respect des r\u00e8gles relatives \u00e0 la protection des donn\u00e9es. \u00bb Quels sont ces m\u00e9canismes et proc\u00e9dures ? Vous pourrez alors trouver dans la loi, qu\u2019il \u00ab est imp\u00e9ratif de d\u00e9signer un pilote et d'assurer : la cartographie des traitements de donn\u00e9es personnelles les actions correctives \u00e0 mener en fonction de l'issue de l'\u00e9tablissement de la cartographie la gestion des risques les processus permettant d'assurer la s\u00e9curit\u00e9 les droits et libert\u00e9s des personnes concern\u00e9es la d\u00e9finition du risque et documenter l'ensemble des mesures de mise en conformit\u00e9 au RGPD que vous avez effectu\u00e9es. \u00bb Articles 24 et 30 r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016, modifi\u00e9s par Rectificatif au r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016 relatif \u00e0 la protection des personnes physiques \u00e0 l\u2019\u00e9gard du traitement des donn\u00e9es \u00e0 caract\u00e8re personnel et \u00e0 la libre circulation de ces donn\u00e9es, et abrogeant la directive 95/46/CE (r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es) JOUE L127 2 du 23/05/2018) Cela peut vous para\u00eetre contraignant, mais c\u2019est l\u2019occasion d\u2019une v\u00e9rification g\u00e9n\u00e9rale . Par o\u00f9 commencer ? Pour vous aider dans cette d\u00e9marche, la CNIL fournit les supports et un logiciel gratuit (PIA) pour analyser votre projet. Consultez le . D\u00e9couvrez la notion de \"Privacy by design\"","title":"Qu'est-ce que le RGPD ?"},{"location":"bts-sio-2/cybersecurite/rgpd/#quest-ce-que-le-rgpd","text":"Le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es ou RGPD remplace l'ensemble de la l\u00e9gislation sur les donn\u00e9es nominatives issue de la loi de 1978. Le RGPD, c\u2019est avant tout une d\u00e9marche \u00e0 suivre. Voici les quelques axes principaux : \u00eatre responsable de son traitement de donn\u00e9es , des objectifs et des moyens que celui-ci implique ; faire la liste des traitements de donn\u00e9es ; trier les donn\u00e9es et identifier les risques ; respecter les droits des personnes ; s\u00e9curiser les donn\u00e9es ; tout documenter . L\u2019utilisation digitale du marketing pose \u00e0 chaque fois la question des donn\u00e9es personnelles. C\u2019est le cas des statistiques ou du profilage des internautes. Sans revenir en d\u00e9tail sur l'int\u00e9gralit\u00e9 de cette r\u00e8gle, il convient de comprendre son fonctionnement et son impact pour la cr\u00e9ation et l'utilisation de supports marketing ou de communication.","title":"Qu'est-ce que le RGPD ?"},{"location":"bts-sio-2/cybersecurite/rgpd/#la-rdgp-et-laccountability","text":"Contrairement aux dispositions pr\u00e9c\u00e9dentes, le r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es supprime les obligations de d\u00e9claration pr\u00e9alable et met en responsabilit\u00e9 chaque annonceur. Note En un mot, vous devez y penser avant de commencer votre projet. Vous ne d\u00e9clarez plus rien mais \u00eates responsable de votre action. Le cadre de l'application du RGPD n'est plus d\u00e9claratif, mais il vous appartient de rapporter la preuve de la conformit\u00e9 de la gestion des donn\u00e9es personnelles et de la s\u00e9curit\u00e9 de celles-ci. En cas de contr\u00f4le des autorit\u00e9s, il vous faudra justifier de ces points de fa\u00e7on document\u00e9e. C\u2019est ce que la CNIL appelle l\u2019 accountability . Selon elle, c\u2019est \u00ab l\u2019obligation pour les entreprises de mettre en \u0153uvre des m\u00e9canismes et des proc\u00e9dures internes permettant de d\u00e9montrer le respect des r\u00e8gles relatives \u00e0 la protection des donn\u00e9es. \u00bb","title":"La RDGP et l\u2019accountability"},{"location":"bts-sio-2/cybersecurite/rgpd/#quels-sont-ces-mecanismes-et-procedures","text":"Vous pourrez alors trouver dans la loi, qu\u2019il \u00ab est imp\u00e9ratif de d\u00e9signer un pilote et d'assurer : la cartographie des traitements de donn\u00e9es personnelles les actions correctives \u00e0 mener en fonction de l'issue de l'\u00e9tablissement de la cartographie la gestion des risques les processus permettant d'assurer la s\u00e9curit\u00e9 les droits et libert\u00e9s des personnes concern\u00e9es la d\u00e9finition du risque et documenter l'ensemble des mesures de mise en conformit\u00e9 au RGPD que vous avez effectu\u00e9es. \u00bb Articles 24 et 30 r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016, modifi\u00e9s par Rectificatif au r\u00e8glement (UE) 2016/679 du Parlement europ\u00e9en et du Conseil du 27 avril 2016 relatif \u00e0 la protection des personnes physiques \u00e0 l\u2019\u00e9gard du traitement des donn\u00e9es \u00e0 caract\u00e8re personnel et \u00e0 la libre circulation de ces donn\u00e9es, et abrogeant la directive 95/46/CE (r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es) JOUE L127 2 du 23/05/2018) Cela peut vous para\u00eetre contraignant, mais c\u2019est l\u2019occasion d\u2019une v\u00e9rification g\u00e9n\u00e9rale . Par o\u00f9 commencer ? Pour vous aider dans cette d\u00e9marche, la CNIL fournit les supports et un logiciel gratuit (PIA) pour analyser votre projet. Consultez le .","title":"Quels sont ces m\u00e9canismes et proc\u00e9dures ?"},{"location":"bts-sio-2/cybersecurite/rgpd/#decouvrez-la-notion-de-privacy-by-design","text":"","title":"D\u00e9couvrez la notion de \"Privacy by design\""},{"location":"bts-sio-2/cybersecurite/sql_injection/","text":"SQL Injection Qu'est-ce que l'injection SQL (SQLi) ? L'injection SQL est une vuln\u00e9rabilit\u00e9 de s\u00e9curit\u00e9 Web qui permet \u00e0 un attaquant d'interf\u00e9rer avec les requ\u00eates qu'une application effectue sur sa base de donn\u00e9es. Il permet g\u00e9n\u00e9ralement \u00e0 un attaquant de visualiser des donn\u00e9es qu'il n'est normalement pas en mesure de r\u00e9cup\u00e9rer. Cela peut inclure des donn\u00e9es appartenant \u00e0 d'autres utilisateurs ou toute autre donn\u00e9e \u00e0 laquelle l'application elle-m\u00eame est en mesure d'acc\u00e9der. Dans de nombreux cas, un attaquant peut modifier ou supprimer ces donn\u00e9es, provoquant des modifications persistantes du contenu ou du comportement de l'application. Dans certaines situations, un attaquant peut intensifier une attaque par injection SQL pour compromettre le serveur sous-jacent ou une autre infrastructure principale, ou effectuer une attaque par d\u00e9ni de service. Quel est l'impact d'une attaque par injection SQL r\u00e9ussie ? Une attaque par injection SQL r\u00e9ussie peut entra\u00eener un acc\u00e8s non autoris\u00e9 \u00e0 des donn\u00e9es sensibles, telles que des mots de passe, des d\u00e9tails de carte de cr\u00e9dit ou des informations personnelles sur l'utilisateur. De nombreuses violations de donn\u00e9es tr\u00e8s m\u00e9diatis\u00e9es ces derni\u00e8res ann\u00e9es ont \u00e9t\u00e9 le r\u00e9sultat d'attaques par injection SQL , entra\u00eenant des dommages \u00e0 la r\u00e9putation et des amendes r\u00e9glementaires. Dans certains cas, un attaquant peut obtenir une porte d\u00e9rob\u00e9e persistante dans les syst\u00e8mes d'une organisation, entra\u00eenant une compromission \u00e0 long terme qui peut passer inaper\u00e7ue pendant une p\u00e9riode prolong\u00e9e. Exemples d'injection SQL Il existe une grande vari\u00e9t\u00e9 de vuln\u00e9rabilit\u00e9s, d'attaques et de techniques d'injection SQL, qui surviennent dans diff\u00e9rentes situations. Voici quelques exemples courants d'injection SQL : R\u00e9cup\u00e9ration des donn\u00e9es cach\u00e9es , o\u00f9 vous pouvez modifier une requ\u00eate SQL pour renvoyer des r\u00e9sultats suppl\u00e9mentaires. Attaques UNION , o\u00f9 vous pouvez r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir de diff\u00e9rentes tables de base de donn\u00e9es. Examiner la base de donn\u00e9es , o\u00f9 vous pouvez extraire des informations sur la version et la structure de la base de donn\u00e9es. Injection SQL aveugle , o\u00f9 les r\u00e9sultats d'une requ\u00eate que vous contr\u00f4lez ne sont pas renvoy\u00e9s dans les r\u00e9ponses de l'application. R\u00e9cup\u00e9rer des donn\u00e9es cach\u00e9es Consid\u00e9rez une application d'achat qui affiche des produits dans diff\u00e9rentes cat\u00e9gories. Lorsque l'utilisateur clique sur la cat\u00e9gorie Cadeaux, son navigateur demande l'URL : 1 https://insecure-website.com/products?category=Gifts Cela am\u00e8ne l'application \u00e0 effectuer une requ\u00eate SQL pour r\u00e9cup\u00e9rer les d\u00e9tails des produits pertinents \u00e0 partir de la base de donn\u00e9es : 1 SELECT * FROM products WHERE category = 'Gifts' AND released = 1 Cette requ\u00eate SQL demande \u00e0 la base de donn\u00e9es de retourner : * tous les d\u00e9tails (*) * de la table produits * o\u00f9 la category est Gifts * et released est 1. La restriction released = 1 est utilis\u00e9e pour masquer les produits qui ne sont pas publi\u00e9s. Pour les produits in\u00e9dits, probablement released = 0 . L'application n'impl\u00e9mente aucune d\u00e9fense contre les attaques par injection SQL , donc un attaquant peut construire une attaque comme : 1 https://insecure-website.com/products?category=Gifts'-- Cela se traduit par la requ\u00eate SQL : 1 SELECT * FROM products WHERE category = 'Gifts' --' AND released = 1 L'\u00e9l\u00e9ment cl\u00e9 ici est que la s\u00e9quence \u00e0 double tiret -- est un indicateur de commentaire en SQL et signifie que le reste de la requ\u00eate est interpr\u00e9t\u00e9 comme un commentaire. Cela supprime efficacement le reste de la requ\u00eate, de sorte qu'elle n'inclut plus AND released = 1 . Cela signifie que tous les produits sont affich\u00e9s, y compris les produits non lanc\u00e9s. Pour aller plus loin, un attaquant peut faire en sorte que l'application affiche tous les produits de n'importe quelle cat\u00e9gorie, y compris des cat\u00e9gories qu'il ne conna\u00eet pas : 1 https://insecure-website.com/products?category=Gifts'+OR+1=1-- Cela se traduit par la requ\u00eate SQL : 1 SELECT * FROM products WHERE category = 'Gifts' OR 1 = 1 --' AND released = 1 La requ\u00eate modifi\u00e9e renverra tous les \u00e9l\u00e9ments dont la category est Gifts ou 1 est \u00e9gal \u00e0 1 . Comme 1=1 est toujours vrai, la requ\u00eate renverra tous les \u00e9l\u00e9ments. Subversion de la logique applicative Consid\u00e9rez une application qui permet aux utilisateurs de se connecter avec un nom d'utilisateur et un mot de passe. Si un utilisateur soumet le nom d'utilisateur wieneret le mot de passe bluecheese , l'application v\u00e9rifie les informations d'identification en effectuant la requ\u00eate SQL suivante : 1 SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese' Si la requ\u00eate renvoie les d\u00e9tails d'un utilisateur, la connexion est r\u00e9ussie. Sinon, il est rejet\u00e9. Ici, un attaquant peut se connecter en tant qu'utilisateur sans mot de passe simplement en utilisant la s\u00e9quence de commentaires SQL -- pour supprimer la v\u00e9rification du mot de passe de la clause WHERE de la requ\u00eate. Par exemple, la soumission du nom d'utilisateur administrator'-- et d'un mot de passe vide g\u00e9n\u00e8re la requ\u00eate suivante : 1 SELECT * FROM users WHERE username = 'administrator' --' AND password = '' Cette requ\u00eate renvoie l'utilisateur dont le nom est administrator et connecte avec succ\u00e8s l'attaquant en tant qu'utilisateur. R\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de base de donn\u00e9es Dans les cas o\u00f9 les r\u00e9sultats d'une requ\u00eate SQL sont renvoy\u00e9s dans les r\u00e9ponses de l'application, un attaquant peut exploiter une vuln\u00e9rabilit\u00e9 d'injection SQL pour r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de la base de donn\u00e9es. Cela se fait \u00e0 l'aide du UNION mot-cl\u00e9, qui vous permet d'ex\u00e9cuter un SELECT suppl\u00e9mentaire et d'ajouter les r\u00e9sultats \u00e0 la requ\u00eate d'origine. Par exemple, si une application ex\u00e9cute la requ\u00eate suivante contenant l'entr\u00e9e utilisateur \u00ab Gifts \u00bb : 1 SELECT name , description FROM products WHERE category = 'Gifts' alors un attaquant peut soumettre l'entr\u00e9e : 1 ' UNION SELECT username , password FROM users -- Cela obligera l'application \u00e0 renvoyer tous les noms d'utilisateur et mots de passe ainsi que les noms et descriptions des produits. Attaques UNION par injection SQL Lorsqu'une application est vuln\u00e9rable \u00e0 l'injection SQL et que les r\u00e9sultats de la requ\u00eate sont renvoy\u00e9s dans les r\u00e9ponses de l'application, le mot-cl\u00e9 UNION peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de la base de donn\u00e9es. Cela entra\u00eene une attaque UNION par injection SQL . Le mot-cl\u00e9 UNION vous permet d'ex\u00e9cuter une ou plusieurs requ\u00eates SELECT suppl\u00e9mentaires et d'ajouter les r\u00e9sultats \u00e0 la requ\u00eate d'origine. Par exemple: 1 SELECT a , b FROM table1 UNION SELECT c , d FROM table2 Cette requ\u00eate SQL renverra un seul jeu de r\u00e9sultats avec deux colonnes, contenant les valeurs des colonnes a et b dans table1 et des colonnes c et d dans table2 . Pour qu'une requ\u00eate UNION fonctionne, deux exigences cl\u00e9s doivent \u00eatre remplies : Les requ\u00eates individuelles doivent renvoyer le m\u00eame nombre de colonnes. Les types de donn\u00e9es dans chaque colonne doivent \u00eatre compatibles entre les requ\u00eates individuelles. Pour effectuer une attaque UNION par injection SQL , vous devez vous assurer que votre attaque r\u00e9pond \u00e0 ces deux exigences. Il s'agit g\u00e9n\u00e9ralement de d\u00e9terminer : * Combien de colonnes sont renvoy\u00e9es \u00e0 partir de la requ\u00eate d'origine ? * Quelles colonnes renvoy\u00e9es par la requ\u00eate d'origine sont d'un type de donn\u00e9es appropri\u00e9 pour contenir les r\u00e9sultats de la requ\u00eate inject\u00e9e ? D\u00e9termination du nombre de colonnes requises dans une attaque UNION par injection SQL Lors de l'ex\u00e9cution d'une attaque UNION par injection SQL , il existe deux m\u00e9thodes efficaces pour d\u00e9terminer le nombre de colonnes renvoy\u00e9es par la requ\u00eate d'origine. La premi\u00e8re m\u00e9thode consiste \u00e0 injecter une s\u00e9rie de ORDER BY clauses et \u00e0 incr\u00e9menter l'index de colonne sp\u00e9cifi\u00e9 jusqu'\u00e0 ce qu'une erreur se produise. Par exemple, en supposant que le point d'injection est une cha\u00eene entre guillemets dans la WHERE clause de la requ\u00eate d'origine, vous devez soumettre : 1 2 3 4 ' ORDER BY 1-- ' ORDER BY 2-- ' ORDER BY 3-- etc. Cette s\u00e9rie d'instructions modifie la requ\u00eate d'origine pour ordonner les r\u00e9sultats par diff\u00e9rentes colonnes dans l'ensemble de r\u00e9sultats. La colonne d'un ORDER BY clause peut \u00eatre sp\u00e9cifi\u00e9e par son index, vous n'avez donc pas besoin \u00e0 conna\u00eetre le nom des colonnes. Lorsque l'index de colonne sp\u00e9cifi\u00e9 d\u00e9passe le nombre de colonnes r\u00e9elles dans le jeu de r\u00e9sultats, la base de donn\u00e9es renvoie une erreur, telle que : 1 The ` ORDER BY ` position number 3 is out of range of the number of items in the select list . L'application peut en fait renvoyer l'erreur de base de donn\u00e9es dans sa r\u00e9ponse HTTP , ou elle peut renvoyer une erreur g\u00e9n\u00e9rique, ou simplement ne renvoyer aucun r\u00e9sultat. \u00c0 condition que vous puissiez d\u00e9tecter une diff\u00e9rence dans la r\u00e9ponse de l'application, vous pouvez d\u00e9duire le nombre de colonnes renvoy\u00e9es \u00e0 partir de la requ\u00eate. La deuxi\u00e8me m\u00e9thode consiste \u00e0 soumettre une s\u00e9rie de UNION SELECT sp\u00e9cifiant un nombre diff\u00e9rent de valeurs nulles : 1 2 3 4 ' UNION SELECT NULL-- ' UNION SELECT NULL,NULL-- ' UNION SELECT NULL,NULL,NULL-- etc. Si le nombre de valeurs NULL ne correspond pas au nombre de colonnes, la base de donn\u00e9es renvoie une erreur, telle que : 1 All queries combined using a UNION , INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists . Encore une fois, l'application peut en fait renvoyer ce message d'erreur, ou peut simplement renvoyer une erreur g\u00e9n\u00e9rique ou aucun r\u00e9sultat. Lorsque le nombre de valeurs NULL correspond au nombre de colonnes, la base de donn\u00e9es renvoie une ligne suppl\u00e9mentaire dans le jeu de r\u00e9sultats, contenant des valeurs NULL dans chaque colonne. L'effet sur la r\u00e9ponse HTTP r\u00e9sultante d\u00e9pend du code de l'application. Si vous avez de la chance, vous verrez du contenu suppl\u00e9mentaire dans la r\u00e9ponse, comme une ligne suppl\u00e9mentaire sur un tableau HTML . Sinon, les valeurs nulles pourraient d\u00e9clencher une erreur diff\u00e9rente, telle qu'une exception de type NullPointerException . Dans le pire des cas, la r\u00e9ponse peut \u00eatre impossible \u00e0 distinguer de celle qui est provoqu\u00e9e par un nombre incorrect de valeurs NULL , rendant cette m\u00e9thode de d\u00e9termination du nombre de colonnes inefficace. Note La raison de l'utilisation NULL des valeurs renvoy\u00e9es par la requ\u00eate SELECT inject\u00e9e est que les types de donn\u00e9es dans chaque colonne doivent \u00eatre compatibles entre les requ\u00eates d'origine et inject\u00e9es. \u00c9tant donn\u00e9 que NULL est convertible en tous les types de donn\u00e9es couramment utilis\u00e9s, l'utilisation de NULL maximise les chances que l'injectione r\u00e9ussisse lorsque le nombre de colonnes est correct. Sur Oracle , chaque requ\u00eate SELECT doit utiliser le mot-cl\u00e9 FROM et sp\u00e9cifier une table valide. Il existe une table int\u00e9gr\u00e9e sur Oracle appel\u00e9e DUAL qui peut \u00eatre utilis\u00e9e \u00e0 cette fin. Ainsi, les requ\u00eates inject\u00e9es sur Oracle devraient ressembler \u00e0 : ' UNION SELECT NULL FROM DUAL-- . Les injections d\u00e9crites utilisent la s\u00e9quence -- de commentaires \u00e0 double tiret pour commenter le reste de la requ\u00eate d'origine apr\u00e8s le point d'injection. Sur MySQL , la s\u00e9quence de double tiret doit \u00eatre suivie d'un espace. Alternativement, le caract\u00e8re di\u00e8se # peut \u00eatre utilis\u00e9 pour identifier un commentaire. Recherche de colonnes avec un type de donn\u00e9es utile dans une attaque UNION par injection SQL La raison d'effectuer une attaque UNION par injection SQL est de pouvoir r\u00e9cup\u00e9rer les r\u00e9sultats d'une requ\u00eate inject\u00e9e. En r\u00e8gle g\u00e9n\u00e9rale, les donn\u00e9es int\u00e9ressantes que vous souhaitez r\u00e9cup\u00e9rer seront sous forme de cha\u00eene, vous devez donc rechercher une ou plusieurs colonnes dans les r\u00e9sultats de la requ\u00eate d'origine dont le type de donn\u00e9es est ou est compatible avec les donn\u00e9es de cha\u00eene. Apr\u00e8s avoir d\u00e9j\u00e0 d\u00e9termin\u00e9 le nombre de colonnes requises, vous pouvez sonder chaque colonne pour tester si elle peut contenir des donn\u00e9es de cha\u00eene en soumettant une s\u00e9rie de UNION SELECT qui placent une valeur de cha\u00eene dans chaque colonne \u00e0 tour de r\u00f4le. Par exemple, si la requ\u00eate renvoie quatre colonnes, vous devez soumettre : 1 2 3 4 ' UNION SELECT 'a', NULL, NULL, NULL-- ' UNION SELECT NULL, 'a', NULL, NULL-- ' UNION SELECT NULL, NULL, 'a', NULL-- ' UNION SELECT NULL, NULL, NULL, 'a' -- Si le type de donn\u00e9es d'une colonne n'est pas compatible avec les donn\u00e9es de cha\u00eene, la requ\u00eate inject\u00e9e provoquera une erreur de base de donn\u00e9es, telle que : 1 Conversion failed when converting the varchar value 'a' to data type int . Si aucune erreur ne se produit et que la r\u00e9ponse de l'application contient du contenu suppl\u00e9mentaire, y compris la valeur de cha\u00eene inject\u00e9e, la colonne appropri\u00e9e convient pour r\u00e9cup\u00e9rer les donn\u00e9es de cha\u00eene. Utiliser une attaque UNION par injection SQL pour r\u00e9cup\u00e9rer des donn\u00e9es int\u00e9ressantes Lorsque vous avez d\u00e9termin\u00e9 le nombre de colonnes renvoy\u00e9es par la requ\u00eate d'origine et trouv\u00e9 quelles colonnes peuvent contenir des donn\u00e9es de cha\u00eene, vous \u00eates en mesure de r\u00e9cup\u00e9rer des donn\u00e9es int\u00e9ressantes. Supposer que: La requ\u00eate d'origine renvoie deux colonnes, qui peuvent toutes deux contenir des donn\u00e9es de cha\u00eene. Le point d'injection est une cha\u00eene entre guillemets dans la WHEREclause. La base de donn\u00e9es contient une table appel\u00e9e usersavec les colonnes usernameet password. Dans cette situation, vous pouvez r\u00e9cup\u00e9rer le contenu de la userstable en soumettant l'entr\u00e9e : 1 ' UNION SELECT username , password FROM users -- Bien s\u00fbr, l'information cruciale n\u00e9cessaire pour effectuer cette attaque est qu'il existe une table appel\u00e9e users avec deux colonnes appel\u00e9es username et password . Sans ces informations, vous seriez oblig\u00e9 de deviner les noms des tables et des colonnes. En fait, toutes les bases de donn\u00e9es modernes offrent des moyens d'examiner la structure de la base de donn\u00e9es, afin de d\u00e9terminer quelles tables et colonnes elle contient. Examen de la base de donn\u00e9es dans les attaques par injection SQL Lors de l'exploitation des vuln\u00e9rabilit\u00e9s d' injection SQL , il est souvent n\u00e9cessaire de collecter des informations sur la base de donn\u00e9es elle-m\u00eame. Cela inclut le type et la version du logiciel de base de donn\u00e9es, ainsi que le contenu de la base de donn\u00e9es en termes de tables et de colonnes qu'elle contient. Interrogation du type et de la version de la base de donn\u00e9es Diff\u00e9rentes bases de donn\u00e9es offrent diff\u00e9rentes mani\u00e8res d'interroger leur version. Vous devez souvent essayer diff\u00e9rentes requ\u00eates pour en trouver une qui fonctionne, vous permettant de d\u00e9terminer \u00e0 la fois le type et la version du logiciel de base de donn\u00e9es. Les requ\u00eates pour d\u00e9terminer la version de la base de donn\u00e9es pour certains types de base de donn\u00e9es courants sont les suivantes : Type de base de donn\u00e9es Mettre en doute \u001b Microsoft, MySQL SELECT @@version Oracle SELECT * FROM v$version PostgreSQL SELECT version() Par exemple, vous pouvez utiliser une UNIONattaque avec l'entr\u00e9e suivante : 1 ' UNION SELECT @@ version -- Cela peut renvoyer une sortie comme celle-ci, confirmant que la base de donn\u00e9es est Microsoft SQL Server et la version utilis\u00e9e : 1 2 3 4 Microsoft SQL Server 2016 (SP2) (KB4052908) - 13.0.5026.0 (X64) Mar 18 2018 09:11:49 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows Server 2016 Standard 10.0 <X64> (Build 14393: ) (Hypervisor) Lister le contenu de la base de donn\u00e9es La plupart des types de bases de donn\u00e9es (\u00e0 l'exception notable d' Oracle ) ont un ensemble de vues appel\u00e9 sch\u00e9ma d'informations qui fournissent des informations sur la base de donn\u00e9es. Vous pouvez interroger information_schema.tablespour r\u00e9pertorier les tables de la base de donn\u00e9es : 1 SELECT * FROM information_schema . tables Cela renvoie une sortie comme suit : 1 2 3 4 5 TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE ===================================================== MyDatabase dbo Products BASE TABLE MyDatabase dbo Users BASE TABLE MyDatabase dbo Feedback BASE TABLE Cette sortie indique qu'il existe trois tables, appel\u00e9es Products , Users , et Feedback . Vous pouvez ensuite interroger information_schema.columns pour r\u00e9pertorier les colonnes dans des tables individuelles : 1 SELECT * FROM information_schema . columns WHERE table_name = 'Users' Cela renvoie une sortie comme suit : 1 2 3 4 5 TABLE_CATALOG TABLE_SCHEMA TABLE_NAME COLUMN_NAME DATA_TYPE ================================================================= MyDatabase dbo Users UserId int MyDatabase dbo Users Username varchar MyDatabase dbo Users Password varchar Cette sortie affiche les colonnes de la table sp\u00e9cifi\u00e9e et le type de donn\u00e9es de chaque colonne. \u00c9quivalent au sch\u00e9ma d'information sur Oracle Sur Oracle , vous pouvez obtenir les m\u00eames informations avec des requ\u00eates l\u00e9g\u00e8rement diff\u00e9rentes. Vous pouvez lister les tables en interrogeant all_tables: 1 SELECT * FROM all_tables Et vous pouvez lister les colonnes en interrogeant all_tab_columns : 1 SELECT * FROM all_tab_columns WHERE table_name = 'USERS' R\u00e9cup\u00e9rer plusieurs valeurs dans une seule colonne Dans l'exemple pr\u00e9c\u00e9dent, supposons plut\u00f4t que la requ\u00eate ne renvoie qu'une seule colonne. Vous pouvez facilement r\u00e9cup\u00e9rer plusieurs valeurs ensemble dans cette seule colonne en concat\u00e9nant les valeurs ensemble, en incluant id\u00e9alement un s\u00e9parateur appropri\u00e9 pour vous permettre de distinguer les valeurs combin\u00e9es. Par exemple, sur Oracle , vous pouvez soumettre l'entr\u00e9e : 1 ' UNION SELECT username || ' ~ ' || password FROM users -- Cela utilise la s\u00e9quence \u00e0 double tube ||qui est un op\u00e9rateur de concat\u00e9nation de cha\u00eenes sur Oracle. La requ\u00eate inject\u00e9e concat\u00e8ne les valeurs des champs usernameet password, s\u00e9par\u00e9es par le ~caract\u00e8re. Les r\u00e9sultats de la requ\u00eate vous permettront de lire tous les noms d'utilisateur et mots de passe, par exemple : 1 2 3 4 5 ... administrator~s3cure wiener~peter carlos~montoya ... Notez que diff\u00e9rentes bases de donn\u00e9es utilisent une syntaxe diff\u00e9rente pour effectuer la concat\u00e9nation de cha\u00eenes. Pour plus de d\u00e9tails, consultez l' aide-m\u00e9moire sur l'injection SQL . Examen de la base de donn\u00e9es Suite \u00e0 l'identification initiale d'une vuln\u00e9rabilit\u00e9 d'injection SQL, il est g\u00e9n\u00e9ralement utile d'obtenir des informations sur la base de donn\u00e9es elle-m\u00eame. Ces informations peuvent souvent ouvrir la voie \u00e0 une exploitation ult\u00e9rieure. Vous pouvez interroger les d\u00e9tails de la version de la base de donn\u00e9es. La fa\u00e7on dont cela est fait d\u00e9pend du type de base de donn\u00e9es, vous pouvez donc d\u00e9duire le type de base de donn\u00e9es \u00e0 partir de la technique qui fonctionne. Par exemple, sur Oracle, vous pouvez ex\u00e9cuter : 1 SELECT * FROM v$version Vous pouvez \u00e9galement d\u00e9terminer quelles tables de base de donn\u00e9es existent et quelles colonnes elles contiennent. Par exemple, sur la plupart des bases de donn\u00e9es, vous pouvez ex\u00e9cuter la requ\u00eate suivante pour r\u00e9pertorier les tables : 1 SELECT * FROM information_schema . tables Vuln\u00e9rabilit\u00e9s d'injection SQL aveugle De nombreuses instances d'injection SQL sont des vuln\u00e9rabilit\u00e9s aveugles. Cela signifie que l'application ne renvoie pas les r\u00e9sultats de la requ\u00eate SQL ou les d\u00e9tails des erreurs de base de donn\u00e9es dans ses r\u00e9ponses. Des vuln\u00e9rabilit\u00e9s aveugles peuvent toujours \u00eatre exploit\u00e9es pour acc\u00e9der \u00e0 des donn\u00e9es non autoris\u00e9es, mais les techniques impliqu\u00e9es sont g\u00e9n\u00e9ralement plus compliqu\u00e9es et difficiles \u00e0 mettre en \u0153uvre. Selon la nature de la vuln\u00e9rabilit\u00e9 et la base de donn\u00e9es impliqu\u00e9e, les techniques suivantes peuvent \u00eatre utilis\u00e9es pour exploiter les vuln\u00e9rabilit\u00e9s d'injection SQL aveugle : Vous pouvez modifier la logique de la requ\u00eate pour d\u00e9clencher une diff\u00e9rence d\u00e9tectable dans la r\u00e9ponse de l'application en fonction de la v\u00e9racit\u00e9 d'une seule condition. Cela peut impliquer l'injection d'une nouvelle condition dans une logique bool\u00e9enne ou le d\u00e9clenchement conditionnel d'une erreur telle qu'une division par z\u00e9ro. Vous pouvez d\u00e9clencher de mani\u00e8re conditionnelle un d\u00e9lai dans le traitement de la requ\u00eate, ce qui vous permet de d\u00e9duire la v\u00e9racit\u00e9 de la condition en fonction du temps que met l'application pour r\u00e9pondre. Vous pouvez d\u00e9clencher une interaction r\u00e9seau hors bande \u00e0 l'aide des techniques OAST . Cette technique est extr\u00eamement puissante et fonctionne dans des situations o\u00f9 les autres techniques ne le font pas. Souvent, vous pouvez directement exfiltrer les donn\u00e9es via le canal hors bande, par exemple en pla\u00e7ant les donn\u00e9es dans une recherche DNS pour un domaine que vous contr\u00f4lez. Out-of-band application security testing (OAST) utilise des serveurs externes pour voir des vuln\u00e9rabilit\u00e9s autrement invisibles. Il a \u00e9t\u00e9 introduit pour am\u00e9liorer encore le mod\u00e8le DAST (dynamic application security testing). Comment d\u00e9tecter les vuln\u00e9rabilit\u00e9s d'injection SQL La majorit\u00e9 des vuln\u00e9rabilit\u00e9s d'injection SQL peuvent \u00eatre trouv\u00e9es rapidement et de mani\u00e8re fiable \u00e0 l'aide du scanner de vuln\u00e9rabilit\u00e9s Web de Burp Suite . L'injection SQL peut \u00eatre d\u00e9tect\u00e9e manuellement en utilisant un ensemble syst\u00e9matique de tests sur chaque point d'entr\u00e9e de l'application. Cela implique g\u00e9n\u00e9ralement : Soumettre le caract\u00e8re guillemet simple ' et rechercher des erreurs ou d'autres anomalies. Soumettre une syntaxe sp\u00e9cifique \u00e0 SQL qui \u00e9value la valeur de base (d'origine) du point d'entr\u00e9e et une valeur diff\u00e9rente, et rechercher des diff\u00e9rences syst\u00e9matiques dans les r\u00e9ponses d'application r\u00e9sultantes. Soumettre des conditions bool\u00e9ennes telles que OR 1=1 et OR 1=2 , et rechercher des diff\u00e9rences dans les r\u00e9ponses de l'application. Soumettre des charges utiles con\u00e7ues pour d\u00e9clencher des retards lorsqu'elles sont ex\u00e9cut\u00e9es dans une requ\u00eate SQL et rechercher des diff\u00e9rences dans le temps n\u00e9cessaire pour r\u00e9pondre. Soumettre des charges utiles OAST con\u00e7ues pour d\u00e9clencher une interaction r\u00e9seau hors bande lorsqu'elles sont ex\u00e9cut\u00e9es dans une requ\u00eate SQL , et surveiller les interactions r\u00e9sultantes. Injection SQL dans diff\u00e9rentes parties de la requ\u00eate La plupart des vuln\u00e9rabilit\u00e9s d'injection SQL surviennent dans la WHEREclause d'une SELECTrequ\u00eate. Ce type d'injection SQL est g\u00e9n\u00e9ralement bien compris par les testeurs exp\u00e9riment\u00e9s. Mais les vuln\u00e9rabilit\u00e9s d'injection SQL peuvent en principe se produire \u00e0 n'importe quel endroit de la requ\u00eate et au sein de diff\u00e9rents types de requ\u00eates. Les autres emplacements les plus courants o\u00f9 l'injection SQL se produit sont : Dans les instructions UPDATE , dans les valeurs mises \u00e0 jour ou la clause WHERE. Dans les instructions INSERT , dans les valeurs ins\u00e9r\u00e9es. Dans les instructions SELECT , dans le nom de la table ou de la colonne. Dans les d\u00e9clarations SELECT , dans la clause ORDER BY . Injection SQL de second ordre L'injection SQL de premier ordre se produit lorsque l'application prend l'entr\u00e9e de l'utilisateur \u00e0 partir d'une requ\u00eate HTTP et, au cours du traitement de cette requ\u00eate, incorpore l'entr\u00e9e dans une requ\u00eate SQL d'une mani\u00e8re dangereuse. Dans l'injection SQL de second ordre (\u00e9galement appel\u00e9e injection SQL stock\u00e9e), l'application prend l'entr\u00e9e de l'utilisateur \u00e0 partir d'une requ\u00eate HTTP et la stocke pour une utilisation future. Cela se fait g\u00e9n\u00e9ralement en pla\u00e7ant l'entr\u00e9e dans une base de donn\u00e9es, mais aucune vuln\u00e9rabilit\u00e9 ne survient au point o\u00f9 les donn\u00e9es sont stock\u00e9es. Plus tard, lors du traitement d'une requ\u00eate HTTP diff\u00e9rente, l'application r\u00e9cup\u00e8re les donn\u00e9es stock\u00e9es et les int\u00e8gre dans une requ\u00eate SQL de mani\u00e8re non s\u00e9curis\u00e9e. L'injection SQL de second ordre se produit souvent dans des situations o\u00f9 les d\u00e9veloppeurs sont conscients des vuln\u00e9rabilit\u00e9s de l'injection SQL et g\u00e8rent ainsi en toute s\u00e9curit\u00e9 le placement initial de l'entr\u00e9e dans la base de donn\u00e9es. Lorsque les donn\u00e9es sont trait\u00e9es ult\u00e9rieurement, elles sont consid\u00e9r\u00e9es comme s\u00fbres, car elles ont \u00e9t\u00e9 pr\u00e9c\u00e9demment plac\u00e9es dans la base de donn\u00e9es en toute s\u00e9curit\u00e9. \u00c0 ce stade, les donn\u00e9es sont trait\u00e9es de mani\u00e8re dangereuse, car le d\u00e9veloppeur les consid\u00e8re \u00e0 tort comme dignes de confiance. Facteurs sp\u00e9cifiques \u00e0 la base de donn\u00e9es Certaines fonctionnalit\u00e9s de base du langage SQL sont impl\u00e9ment\u00e9es de la m\u00eame mani\u00e8re sur les plates-formes de bases de donn\u00e9es courantes, et de nombreuses fa\u00e7ons de d\u00e9tecter et d'exploiter les vuln\u00e9rabilit\u00e9s d'injection SQL fonctionnent de mani\u00e8re identique sur diff\u00e9rents types de bases de donn\u00e9es. Cependant, il existe \u00e9galement de nombreuses diff\u00e9rences entre les bases de donn\u00e9es communes. Cela signifie que certaines techniques de d\u00e9tection et d'exploitation de l'injection SQL fonctionnent diff\u00e9remment sur diff\u00e9rentes plates-formes. Par exemple: Syntaxe pour la concat\u00e9nation de cha\u00eenes. Commentaires. Requ\u00eates group\u00e9es (ou empil\u00e9es). API sp\u00e9cifiques \u00e0 la plate-forme. Messages d'erreur. Comment emp\u00eacher l'injection SQL La plupart des instances d'injection SQL peuvent \u00eatre \u00e9vit\u00e9es en utilisant des requ\u00eates param\u00e9tr\u00e9es (\u00e9galement appel\u00e9es instructions pr\u00e9par\u00e9es) au lieu de la concat\u00e9nation de cha\u00eenes dans la requ\u00eate. Le code suivant est vuln\u00e9rable \u00e0 l'injection SQL car l'entr\u00e9e utilisateur est concat\u00e9n\u00e9e directement dans la requ\u00eate : 1 String query = \"SELECT * FROM products WHERE category = '\" + input + \"'\" ; 1 2 Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(query); Ce code peut \u00eatre facilement r\u00e9\u00e9crit d'une mani\u00e8re qui emp\u00eache l'entr\u00e9e de l'utilisateur d'interf\u00e9rer avec la structure de la requ\u00eate : 1 2 3 PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM products WHERE category = ?\"); statement.setString(1, input); ResultSet resultSet = statement.executeQuery(); Les requ\u00eates param\u00e9tr\u00e9es peuvent \u00eatre utilis\u00e9es pour toute situation o\u00f9 une entr\u00e9e non fiable appara\u00eet sous forme de donn\u00e9es dans la requ\u00eate, y compris la WHERE clause et les valeurs d'une instruction INSERT ou UPDATE . Ils ne peuvent pas \u00eatre utilis\u00e9s pour g\u00e9rer des entr\u00e9es non fiables dans d'autres parties de la requ\u00eate, telles que les noms de table ou de colonne, ou la ORDER BY clause. La fonctionnalit\u00e9 d'application qui place des donn\u00e9es non fiables dans ces parties de la requ\u00eate devra adopter une approche diff\u00e9rente, telle que la mise en liste blanche des valeurs d'entr\u00e9e autoris\u00e9es, ou l'utilisation d'une logique diff\u00e9rente pour fournir le comportement requis. Pour qu'une requ\u00eate param\u00e9tr\u00e9e emp\u00eache efficacement l'injection SQL , la cha\u00eene utilis\u00e9e dans la requ\u00eate doit toujours \u00eatre une constante cod\u00e9e en dur et ne doit jamais contenir de donn\u00e9es variables de quelque origine que ce soit. Ne soyez pas tent\u00e9 de d\u00e9cider au cas par cas si un \u00e9l\u00e9ment de donn\u00e9es est fiable et continuez \u00e0 utiliser la concat\u00e9nation de cha\u00eenes dans la requ\u00eate pour les cas consid\u00e9r\u00e9s comme s\u00fbrs. Il est trop facile de faire des erreurs sur l'origine possible des donn\u00e9es, ou que des modifications dans d'autres codes violent les hypoth\u00e8ses sur les donn\u00e9es qui sont entach\u00e9es.","title":"SQL Injection"},{"location":"bts-sio-2/cybersecurite/sql_injection/#sql-injection","text":"","title":"SQL Injection"},{"location":"bts-sio-2/cybersecurite/sql_injection/#quest-ce-que-linjection-sql-sqli","text":"L'injection SQL est une vuln\u00e9rabilit\u00e9 de s\u00e9curit\u00e9 Web qui permet \u00e0 un attaquant d'interf\u00e9rer avec les requ\u00eates qu'une application effectue sur sa base de donn\u00e9es. Il permet g\u00e9n\u00e9ralement \u00e0 un attaquant de visualiser des donn\u00e9es qu'il n'est normalement pas en mesure de r\u00e9cup\u00e9rer. Cela peut inclure des donn\u00e9es appartenant \u00e0 d'autres utilisateurs ou toute autre donn\u00e9e \u00e0 laquelle l'application elle-m\u00eame est en mesure d'acc\u00e9der. Dans de nombreux cas, un attaquant peut modifier ou supprimer ces donn\u00e9es, provoquant des modifications persistantes du contenu ou du comportement de l'application. Dans certaines situations, un attaquant peut intensifier une attaque par injection SQL pour compromettre le serveur sous-jacent ou une autre infrastructure principale, ou effectuer une attaque par d\u00e9ni de service.","title":"Qu'est-ce que l'injection SQL (SQLi) ?"},{"location":"bts-sio-2/cybersecurite/sql_injection/#quel-est-limpact-dune-attaque-par-injection-sql-reussie","text":"Une attaque par injection SQL r\u00e9ussie peut entra\u00eener un acc\u00e8s non autoris\u00e9 \u00e0 des donn\u00e9es sensibles, telles que des mots de passe, des d\u00e9tails de carte de cr\u00e9dit ou des informations personnelles sur l'utilisateur. De nombreuses violations de donn\u00e9es tr\u00e8s m\u00e9diatis\u00e9es ces derni\u00e8res ann\u00e9es ont \u00e9t\u00e9 le r\u00e9sultat d'attaques par injection SQL , entra\u00eenant des dommages \u00e0 la r\u00e9putation et des amendes r\u00e9glementaires. Dans certains cas, un attaquant peut obtenir une porte d\u00e9rob\u00e9e persistante dans les syst\u00e8mes d'une organisation, entra\u00eenant une compromission \u00e0 long terme qui peut passer inaper\u00e7ue pendant une p\u00e9riode prolong\u00e9e.","title":"Quel est l'impact d'une attaque par injection SQL r\u00e9ussie ?"},{"location":"bts-sio-2/cybersecurite/sql_injection/#exemples-dinjection-sql","text":"Il existe une grande vari\u00e9t\u00e9 de vuln\u00e9rabilit\u00e9s, d'attaques et de techniques d'injection SQL, qui surviennent dans diff\u00e9rentes situations. Voici quelques exemples courants d'injection SQL : R\u00e9cup\u00e9ration des donn\u00e9es cach\u00e9es , o\u00f9 vous pouvez modifier une requ\u00eate SQL pour renvoyer des r\u00e9sultats suppl\u00e9mentaires. Attaques UNION , o\u00f9 vous pouvez r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir de diff\u00e9rentes tables de base de donn\u00e9es. Examiner la base de donn\u00e9es , o\u00f9 vous pouvez extraire des informations sur la version et la structure de la base de donn\u00e9es. Injection SQL aveugle , o\u00f9 les r\u00e9sultats d'une requ\u00eate que vous contr\u00f4lez ne sont pas renvoy\u00e9s dans les r\u00e9ponses de l'application.","title":"Exemples d'injection SQL"},{"location":"bts-sio-2/cybersecurite/sql_injection/#recuperer-des-donnees-cachees","text":"Consid\u00e9rez une application d'achat qui affiche des produits dans diff\u00e9rentes cat\u00e9gories. Lorsque l'utilisateur clique sur la cat\u00e9gorie Cadeaux, son navigateur demande l'URL : 1 https://insecure-website.com/products?category=Gifts Cela am\u00e8ne l'application \u00e0 effectuer une requ\u00eate SQL pour r\u00e9cup\u00e9rer les d\u00e9tails des produits pertinents \u00e0 partir de la base de donn\u00e9es : 1 SELECT * FROM products WHERE category = 'Gifts' AND released = 1 Cette requ\u00eate SQL demande \u00e0 la base de donn\u00e9es de retourner : * tous les d\u00e9tails (*) * de la table produits * o\u00f9 la category est Gifts * et released est 1. La restriction released = 1 est utilis\u00e9e pour masquer les produits qui ne sont pas publi\u00e9s. Pour les produits in\u00e9dits, probablement released = 0 . L'application n'impl\u00e9mente aucune d\u00e9fense contre les attaques par injection SQL , donc un attaquant peut construire une attaque comme : 1 https://insecure-website.com/products?category=Gifts'-- Cela se traduit par la requ\u00eate SQL : 1 SELECT * FROM products WHERE category = 'Gifts' --' AND released = 1 L'\u00e9l\u00e9ment cl\u00e9 ici est que la s\u00e9quence \u00e0 double tiret -- est un indicateur de commentaire en SQL et signifie que le reste de la requ\u00eate est interpr\u00e9t\u00e9 comme un commentaire. Cela supprime efficacement le reste de la requ\u00eate, de sorte qu'elle n'inclut plus AND released = 1 . Cela signifie que tous les produits sont affich\u00e9s, y compris les produits non lanc\u00e9s. Pour aller plus loin, un attaquant peut faire en sorte que l'application affiche tous les produits de n'importe quelle cat\u00e9gorie, y compris des cat\u00e9gories qu'il ne conna\u00eet pas : 1 https://insecure-website.com/products?category=Gifts'+OR+1=1-- Cela se traduit par la requ\u00eate SQL : 1 SELECT * FROM products WHERE category = 'Gifts' OR 1 = 1 --' AND released = 1 La requ\u00eate modifi\u00e9e renverra tous les \u00e9l\u00e9ments dont la category est Gifts ou 1 est \u00e9gal \u00e0 1 . Comme 1=1 est toujours vrai, la requ\u00eate renverra tous les \u00e9l\u00e9ments.","title":"R\u00e9cup\u00e9rer des donn\u00e9es cach\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#subversion-de-la-logique-applicative","text":"Consid\u00e9rez une application qui permet aux utilisateurs de se connecter avec un nom d'utilisateur et un mot de passe. Si un utilisateur soumet le nom d'utilisateur wieneret le mot de passe bluecheese , l'application v\u00e9rifie les informations d'identification en effectuant la requ\u00eate SQL suivante : 1 SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese' Si la requ\u00eate renvoie les d\u00e9tails d'un utilisateur, la connexion est r\u00e9ussie. Sinon, il est rejet\u00e9. Ici, un attaquant peut se connecter en tant qu'utilisateur sans mot de passe simplement en utilisant la s\u00e9quence de commentaires SQL -- pour supprimer la v\u00e9rification du mot de passe de la clause WHERE de la requ\u00eate. Par exemple, la soumission du nom d'utilisateur administrator'-- et d'un mot de passe vide g\u00e9n\u00e8re la requ\u00eate suivante : 1 SELECT * FROM users WHERE username = 'administrator' --' AND password = '' Cette requ\u00eate renvoie l'utilisateur dont le nom est administrator et connecte avec succ\u00e8s l'attaquant en tant qu'utilisateur.","title":"Subversion de la logique applicative"},{"location":"bts-sio-2/cybersecurite/sql_injection/#recuperer-des-donnees-a-partir-dautres-tables-de-base-de-donnees","text":"Dans les cas o\u00f9 les r\u00e9sultats d'une requ\u00eate SQL sont renvoy\u00e9s dans les r\u00e9ponses de l'application, un attaquant peut exploiter une vuln\u00e9rabilit\u00e9 d'injection SQL pour r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de la base de donn\u00e9es. Cela se fait \u00e0 l'aide du UNION mot-cl\u00e9, qui vous permet d'ex\u00e9cuter un SELECT suppl\u00e9mentaire et d'ajouter les r\u00e9sultats \u00e0 la requ\u00eate d'origine. Par exemple, si une application ex\u00e9cute la requ\u00eate suivante contenant l'entr\u00e9e utilisateur \u00ab Gifts \u00bb : 1 SELECT name , description FROM products WHERE category = 'Gifts' alors un attaquant peut soumettre l'entr\u00e9e : 1 ' UNION SELECT username , password FROM users -- Cela obligera l'application \u00e0 renvoyer tous les noms d'utilisateur et mots de passe ainsi que les noms et descriptions des produits.","title":"R\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de base de donn\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#attaques-union-par-injection-sql","text":"Lorsqu'une application est vuln\u00e9rable \u00e0 l'injection SQL et que les r\u00e9sultats de la requ\u00eate sont renvoy\u00e9s dans les r\u00e9ponses de l'application, le mot-cl\u00e9 UNION peut \u00eatre utilis\u00e9 pour r\u00e9cup\u00e9rer des donn\u00e9es \u00e0 partir d'autres tables de la base de donn\u00e9es. Cela entra\u00eene une attaque UNION par injection SQL . Le mot-cl\u00e9 UNION vous permet d'ex\u00e9cuter une ou plusieurs requ\u00eates SELECT suppl\u00e9mentaires et d'ajouter les r\u00e9sultats \u00e0 la requ\u00eate d'origine. Par exemple: 1 SELECT a , b FROM table1 UNION SELECT c , d FROM table2 Cette requ\u00eate SQL renverra un seul jeu de r\u00e9sultats avec deux colonnes, contenant les valeurs des colonnes a et b dans table1 et des colonnes c et d dans table2 . Pour qu'une requ\u00eate UNION fonctionne, deux exigences cl\u00e9s doivent \u00eatre remplies : Les requ\u00eates individuelles doivent renvoyer le m\u00eame nombre de colonnes. Les types de donn\u00e9es dans chaque colonne doivent \u00eatre compatibles entre les requ\u00eates individuelles. Pour effectuer une attaque UNION par injection SQL , vous devez vous assurer que votre attaque r\u00e9pond \u00e0 ces deux exigences. Il s'agit g\u00e9n\u00e9ralement de d\u00e9terminer : * Combien de colonnes sont renvoy\u00e9es \u00e0 partir de la requ\u00eate d'origine ? * Quelles colonnes renvoy\u00e9es par la requ\u00eate d'origine sont d'un type de donn\u00e9es appropri\u00e9 pour contenir les r\u00e9sultats de la requ\u00eate inject\u00e9e ?","title":"Attaques UNION par injection SQL"},{"location":"bts-sio-2/cybersecurite/sql_injection/#determination-du-nombre-de-colonnes-requises-dans-une-attaque-union-par-injection-sql","text":"Lors de l'ex\u00e9cution d'une attaque UNION par injection SQL , il existe deux m\u00e9thodes efficaces pour d\u00e9terminer le nombre de colonnes renvoy\u00e9es par la requ\u00eate d'origine. La premi\u00e8re m\u00e9thode consiste \u00e0 injecter une s\u00e9rie de ORDER BY clauses et \u00e0 incr\u00e9menter l'index de colonne sp\u00e9cifi\u00e9 jusqu'\u00e0 ce qu'une erreur se produise. Par exemple, en supposant que le point d'injection est une cha\u00eene entre guillemets dans la WHERE clause de la requ\u00eate d'origine, vous devez soumettre : 1 2 3 4 ' ORDER BY 1-- ' ORDER BY 2-- ' ORDER BY 3-- etc. Cette s\u00e9rie d'instructions modifie la requ\u00eate d'origine pour ordonner les r\u00e9sultats par diff\u00e9rentes colonnes dans l'ensemble de r\u00e9sultats. La colonne d'un ORDER BY clause peut \u00eatre sp\u00e9cifi\u00e9e par son index, vous n'avez donc pas besoin \u00e0 conna\u00eetre le nom des colonnes. Lorsque l'index de colonne sp\u00e9cifi\u00e9 d\u00e9passe le nombre de colonnes r\u00e9elles dans le jeu de r\u00e9sultats, la base de donn\u00e9es renvoie une erreur, telle que : 1 The ` ORDER BY ` position number 3 is out of range of the number of items in the select list . L'application peut en fait renvoyer l'erreur de base de donn\u00e9es dans sa r\u00e9ponse HTTP , ou elle peut renvoyer une erreur g\u00e9n\u00e9rique, ou simplement ne renvoyer aucun r\u00e9sultat. \u00c0 condition que vous puissiez d\u00e9tecter une diff\u00e9rence dans la r\u00e9ponse de l'application, vous pouvez d\u00e9duire le nombre de colonnes renvoy\u00e9es \u00e0 partir de la requ\u00eate. La deuxi\u00e8me m\u00e9thode consiste \u00e0 soumettre une s\u00e9rie de UNION SELECT sp\u00e9cifiant un nombre diff\u00e9rent de valeurs nulles : 1 2 3 4 ' UNION SELECT NULL-- ' UNION SELECT NULL,NULL-- ' UNION SELECT NULL,NULL,NULL-- etc. Si le nombre de valeurs NULL ne correspond pas au nombre de colonnes, la base de donn\u00e9es renvoie une erreur, telle que : 1 All queries combined using a UNION , INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists . Encore une fois, l'application peut en fait renvoyer ce message d'erreur, ou peut simplement renvoyer une erreur g\u00e9n\u00e9rique ou aucun r\u00e9sultat. Lorsque le nombre de valeurs NULL correspond au nombre de colonnes, la base de donn\u00e9es renvoie une ligne suppl\u00e9mentaire dans le jeu de r\u00e9sultats, contenant des valeurs NULL dans chaque colonne. L'effet sur la r\u00e9ponse HTTP r\u00e9sultante d\u00e9pend du code de l'application. Si vous avez de la chance, vous verrez du contenu suppl\u00e9mentaire dans la r\u00e9ponse, comme une ligne suppl\u00e9mentaire sur un tableau HTML . Sinon, les valeurs nulles pourraient d\u00e9clencher une erreur diff\u00e9rente, telle qu'une exception de type NullPointerException . Dans le pire des cas, la r\u00e9ponse peut \u00eatre impossible \u00e0 distinguer de celle qui est provoqu\u00e9e par un nombre incorrect de valeurs NULL , rendant cette m\u00e9thode de d\u00e9termination du nombre de colonnes inefficace. Note La raison de l'utilisation NULL des valeurs renvoy\u00e9es par la requ\u00eate SELECT inject\u00e9e est que les types de donn\u00e9es dans chaque colonne doivent \u00eatre compatibles entre les requ\u00eates d'origine et inject\u00e9es. \u00c9tant donn\u00e9 que NULL est convertible en tous les types de donn\u00e9es couramment utilis\u00e9s, l'utilisation de NULL maximise les chances que l'injectione r\u00e9ussisse lorsque le nombre de colonnes est correct. Sur Oracle , chaque requ\u00eate SELECT doit utiliser le mot-cl\u00e9 FROM et sp\u00e9cifier une table valide. Il existe une table int\u00e9gr\u00e9e sur Oracle appel\u00e9e DUAL qui peut \u00eatre utilis\u00e9e \u00e0 cette fin. Ainsi, les requ\u00eates inject\u00e9es sur Oracle devraient ressembler \u00e0 : ' UNION SELECT NULL FROM DUAL-- . Les injections d\u00e9crites utilisent la s\u00e9quence -- de commentaires \u00e0 double tiret pour commenter le reste de la requ\u00eate d'origine apr\u00e8s le point d'injection. Sur MySQL , la s\u00e9quence de double tiret doit \u00eatre suivie d'un espace. Alternativement, le caract\u00e8re di\u00e8se # peut \u00eatre utilis\u00e9 pour identifier un commentaire. Recherche de colonnes avec un type de donn\u00e9es utile dans une attaque UNION par injection SQL La raison d'effectuer une attaque UNION par injection SQL est de pouvoir r\u00e9cup\u00e9rer les r\u00e9sultats d'une requ\u00eate inject\u00e9e. En r\u00e8gle g\u00e9n\u00e9rale, les donn\u00e9es int\u00e9ressantes que vous souhaitez r\u00e9cup\u00e9rer seront sous forme de cha\u00eene, vous devez donc rechercher une ou plusieurs colonnes dans les r\u00e9sultats de la requ\u00eate d'origine dont le type de donn\u00e9es est ou est compatible avec les donn\u00e9es de cha\u00eene. Apr\u00e8s avoir d\u00e9j\u00e0 d\u00e9termin\u00e9 le nombre de colonnes requises, vous pouvez sonder chaque colonne pour tester si elle peut contenir des donn\u00e9es de cha\u00eene en soumettant une s\u00e9rie de UNION SELECT qui placent une valeur de cha\u00eene dans chaque colonne \u00e0 tour de r\u00f4le. Par exemple, si la requ\u00eate renvoie quatre colonnes, vous devez soumettre : 1 2 3 4 ' UNION SELECT 'a', NULL, NULL, NULL-- ' UNION SELECT NULL, 'a', NULL, NULL-- ' UNION SELECT NULL, NULL, 'a', NULL-- ' UNION SELECT NULL, NULL, NULL, 'a' -- Si le type de donn\u00e9es d'une colonne n'est pas compatible avec les donn\u00e9es de cha\u00eene, la requ\u00eate inject\u00e9e provoquera une erreur de base de donn\u00e9es, telle que : 1 Conversion failed when converting the varchar value 'a' to data type int . Si aucune erreur ne se produit et que la r\u00e9ponse de l'application contient du contenu suppl\u00e9mentaire, y compris la valeur de cha\u00eene inject\u00e9e, la colonne appropri\u00e9e convient pour r\u00e9cup\u00e9rer les donn\u00e9es de cha\u00eene.","title":"D\u00e9termination du nombre de colonnes requises dans une attaque UNION par injection SQL"},{"location":"bts-sio-2/cybersecurite/sql_injection/#utiliser-une-attaque-union-par-injection-sql-pour-recuperer-des-donnees-interessantes","text":"Lorsque vous avez d\u00e9termin\u00e9 le nombre de colonnes renvoy\u00e9es par la requ\u00eate d'origine et trouv\u00e9 quelles colonnes peuvent contenir des donn\u00e9es de cha\u00eene, vous \u00eates en mesure de r\u00e9cup\u00e9rer des donn\u00e9es int\u00e9ressantes. Supposer que: La requ\u00eate d'origine renvoie deux colonnes, qui peuvent toutes deux contenir des donn\u00e9es de cha\u00eene. Le point d'injection est une cha\u00eene entre guillemets dans la WHEREclause. La base de donn\u00e9es contient une table appel\u00e9e usersavec les colonnes usernameet password. Dans cette situation, vous pouvez r\u00e9cup\u00e9rer le contenu de la userstable en soumettant l'entr\u00e9e : 1 ' UNION SELECT username , password FROM users -- Bien s\u00fbr, l'information cruciale n\u00e9cessaire pour effectuer cette attaque est qu'il existe une table appel\u00e9e users avec deux colonnes appel\u00e9es username et password . Sans ces informations, vous seriez oblig\u00e9 de deviner les noms des tables et des colonnes. En fait, toutes les bases de donn\u00e9es modernes offrent des moyens d'examiner la structure de la base de donn\u00e9es, afin de d\u00e9terminer quelles tables et colonnes elle contient.","title":"Utiliser une attaque UNION par injection SQL pour r\u00e9cup\u00e9rer des donn\u00e9es int\u00e9ressantes"},{"location":"bts-sio-2/cybersecurite/sql_injection/#examen-de-la-base-de-donnees-dans-les-attaques-par-injection-sql","text":"Lors de l'exploitation des vuln\u00e9rabilit\u00e9s d' injection SQL , il est souvent n\u00e9cessaire de collecter des informations sur la base de donn\u00e9es elle-m\u00eame. Cela inclut le type et la version du logiciel de base de donn\u00e9es, ainsi que le contenu de la base de donn\u00e9es en termes de tables et de colonnes qu'elle contient.","title":"Examen de la base de donn\u00e9es dans les attaques par injection SQL"},{"location":"bts-sio-2/cybersecurite/sql_injection/#interrogation-du-type-et-de-la-version-de-la-base-de-donnees","text":"Diff\u00e9rentes bases de donn\u00e9es offrent diff\u00e9rentes mani\u00e8res d'interroger leur version. Vous devez souvent essayer diff\u00e9rentes requ\u00eates pour en trouver une qui fonctionne, vous permettant de d\u00e9terminer \u00e0 la fois le type et la version du logiciel de base de donn\u00e9es. Les requ\u00eates pour d\u00e9terminer la version de la base de donn\u00e9es pour certains types de base de donn\u00e9es courants sont les suivantes : Type de base de donn\u00e9es Mettre en doute \u001b Microsoft, MySQL SELECT @@version Oracle SELECT * FROM v$version PostgreSQL SELECT version() Par exemple, vous pouvez utiliser une UNIONattaque avec l'entr\u00e9e suivante : 1 ' UNION SELECT @@ version -- Cela peut renvoyer une sortie comme celle-ci, confirmant que la base de donn\u00e9es est Microsoft SQL Server et la version utilis\u00e9e : 1 2 3 4 Microsoft SQL Server 2016 (SP2) (KB4052908) - 13.0.5026.0 (X64) Mar 18 2018 09:11:49 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows Server 2016 Standard 10.0 <X64> (Build 14393: ) (Hypervisor)","title":"Interrogation du type et de la version de la base de donn\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#lister-le-contenu-de-la-base-de-donnees","text":"La plupart des types de bases de donn\u00e9es (\u00e0 l'exception notable d' Oracle ) ont un ensemble de vues appel\u00e9 sch\u00e9ma d'informations qui fournissent des informations sur la base de donn\u00e9es. Vous pouvez interroger information_schema.tablespour r\u00e9pertorier les tables de la base de donn\u00e9es : 1 SELECT * FROM information_schema . tables Cela renvoie une sortie comme suit : 1 2 3 4 5 TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE ===================================================== MyDatabase dbo Products BASE TABLE MyDatabase dbo Users BASE TABLE MyDatabase dbo Feedback BASE TABLE Cette sortie indique qu'il existe trois tables, appel\u00e9es Products , Users , et Feedback . Vous pouvez ensuite interroger information_schema.columns pour r\u00e9pertorier les colonnes dans des tables individuelles : 1 SELECT * FROM information_schema . columns WHERE table_name = 'Users' Cela renvoie une sortie comme suit : 1 2 3 4 5 TABLE_CATALOG TABLE_SCHEMA TABLE_NAME COLUMN_NAME DATA_TYPE ================================================================= MyDatabase dbo Users UserId int MyDatabase dbo Users Username varchar MyDatabase dbo Users Password varchar Cette sortie affiche les colonnes de la table sp\u00e9cifi\u00e9e et le type de donn\u00e9es de chaque colonne. \u00c9quivalent au sch\u00e9ma d'information sur Oracle Sur Oracle , vous pouvez obtenir les m\u00eames informations avec des requ\u00eates l\u00e9g\u00e8rement diff\u00e9rentes. Vous pouvez lister les tables en interrogeant all_tables: 1 SELECT * FROM all_tables Et vous pouvez lister les colonnes en interrogeant all_tab_columns : 1 SELECT * FROM all_tab_columns WHERE table_name = 'USERS'","title":"Lister le contenu de la base de donn\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#recuperer-plusieurs-valeurs-dans-une-seule-colonne","text":"Dans l'exemple pr\u00e9c\u00e9dent, supposons plut\u00f4t que la requ\u00eate ne renvoie qu'une seule colonne. Vous pouvez facilement r\u00e9cup\u00e9rer plusieurs valeurs ensemble dans cette seule colonne en concat\u00e9nant les valeurs ensemble, en incluant id\u00e9alement un s\u00e9parateur appropri\u00e9 pour vous permettre de distinguer les valeurs combin\u00e9es. Par exemple, sur Oracle , vous pouvez soumettre l'entr\u00e9e : 1 ' UNION SELECT username || ' ~ ' || password FROM users -- Cela utilise la s\u00e9quence \u00e0 double tube ||qui est un op\u00e9rateur de concat\u00e9nation de cha\u00eenes sur Oracle. La requ\u00eate inject\u00e9e concat\u00e8ne les valeurs des champs usernameet password, s\u00e9par\u00e9es par le ~caract\u00e8re. Les r\u00e9sultats de la requ\u00eate vous permettront de lire tous les noms d'utilisateur et mots de passe, par exemple : 1 2 3 4 5 ... administrator~s3cure wiener~peter carlos~montoya ... Notez que diff\u00e9rentes bases de donn\u00e9es utilisent une syntaxe diff\u00e9rente pour effectuer la concat\u00e9nation de cha\u00eenes. Pour plus de d\u00e9tails, consultez l' aide-m\u00e9moire sur l'injection SQL .","title":"R\u00e9cup\u00e9rer plusieurs valeurs dans une seule colonne"},{"location":"bts-sio-2/cybersecurite/sql_injection/#examen-de-la-base-de-donnees","text":"Suite \u00e0 l'identification initiale d'une vuln\u00e9rabilit\u00e9 d'injection SQL, il est g\u00e9n\u00e9ralement utile d'obtenir des informations sur la base de donn\u00e9es elle-m\u00eame. Ces informations peuvent souvent ouvrir la voie \u00e0 une exploitation ult\u00e9rieure. Vous pouvez interroger les d\u00e9tails de la version de la base de donn\u00e9es. La fa\u00e7on dont cela est fait d\u00e9pend du type de base de donn\u00e9es, vous pouvez donc d\u00e9duire le type de base de donn\u00e9es \u00e0 partir de la technique qui fonctionne. Par exemple, sur Oracle, vous pouvez ex\u00e9cuter : 1 SELECT * FROM v$version Vous pouvez \u00e9galement d\u00e9terminer quelles tables de base de donn\u00e9es existent et quelles colonnes elles contiennent. Par exemple, sur la plupart des bases de donn\u00e9es, vous pouvez ex\u00e9cuter la requ\u00eate suivante pour r\u00e9pertorier les tables : 1 SELECT * FROM information_schema . tables","title":"Examen de la base de donn\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#vulnerabilites-dinjection-sql-aveugle","text":"De nombreuses instances d'injection SQL sont des vuln\u00e9rabilit\u00e9s aveugles. Cela signifie que l'application ne renvoie pas les r\u00e9sultats de la requ\u00eate SQL ou les d\u00e9tails des erreurs de base de donn\u00e9es dans ses r\u00e9ponses. Des vuln\u00e9rabilit\u00e9s aveugles peuvent toujours \u00eatre exploit\u00e9es pour acc\u00e9der \u00e0 des donn\u00e9es non autoris\u00e9es, mais les techniques impliqu\u00e9es sont g\u00e9n\u00e9ralement plus compliqu\u00e9es et difficiles \u00e0 mettre en \u0153uvre. Selon la nature de la vuln\u00e9rabilit\u00e9 et la base de donn\u00e9es impliqu\u00e9e, les techniques suivantes peuvent \u00eatre utilis\u00e9es pour exploiter les vuln\u00e9rabilit\u00e9s d'injection SQL aveugle : Vous pouvez modifier la logique de la requ\u00eate pour d\u00e9clencher une diff\u00e9rence d\u00e9tectable dans la r\u00e9ponse de l'application en fonction de la v\u00e9racit\u00e9 d'une seule condition. Cela peut impliquer l'injection d'une nouvelle condition dans une logique bool\u00e9enne ou le d\u00e9clenchement conditionnel d'une erreur telle qu'une division par z\u00e9ro. Vous pouvez d\u00e9clencher de mani\u00e8re conditionnelle un d\u00e9lai dans le traitement de la requ\u00eate, ce qui vous permet de d\u00e9duire la v\u00e9racit\u00e9 de la condition en fonction du temps que met l'application pour r\u00e9pondre. Vous pouvez d\u00e9clencher une interaction r\u00e9seau hors bande \u00e0 l'aide des techniques OAST . Cette technique est extr\u00eamement puissante et fonctionne dans des situations o\u00f9 les autres techniques ne le font pas. Souvent, vous pouvez directement exfiltrer les donn\u00e9es via le canal hors bande, par exemple en pla\u00e7ant les donn\u00e9es dans une recherche DNS pour un domaine que vous contr\u00f4lez. Out-of-band application security testing (OAST) utilise des serveurs externes pour voir des vuln\u00e9rabilit\u00e9s autrement invisibles. Il a \u00e9t\u00e9 introduit pour am\u00e9liorer encore le mod\u00e8le DAST (dynamic application security testing).","title":"Vuln\u00e9rabilit\u00e9s d'injection SQL aveugle"},{"location":"bts-sio-2/cybersecurite/sql_injection/#comment-detecter-les-vulnerabilites-dinjection-sql","text":"La majorit\u00e9 des vuln\u00e9rabilit\u00e9s d'injection SQL peuvent \u00eatre trouv\u00e9es rapidement et de mani\u00e8re fiable \u00e0 l'aide du scanner de vuln\u00e9rabilit\u00e9s Web de Burp Suite . L'injection SQL peut \u00eatre d\u00e9tect\u00e9e manuellement en utilisant un ensemble syst\u00e9matique de tests sur chaque point d'entr\u00e9e de l'application. Cela implique g\u00e9n\u00e9ralement : Soumettre le caract\u00e8re guillemet simple ' et rechercher des erreurs ou d'autres anomalies. Soumettre une syntaxe sp\u00e9cifique \u00e0 SQL qui \u00e9value la valeur de base (d'origine) du point d'entr\u00e9e et une valeur diff\u00e9rente, et rechercher des diff\u00e9rences syst\u00e9matiques dans les r\u00e9ponses d'application r\u00e9sultantes. Soumettre des conditions bool\u00e9ennes telles que OR 1=1 et OR 1=2 , et rechercher des diff\u00e9rences dans les r\u00e9ponses de l'application. Soumettre des charges utiles con\u00e7ues pour d\u00e9clencher des retards lorsqu'elles sont ex\u00e9cut\u00e9es dans une requ\u00eate SQL et rechercher des diff\u00e9rences dans le temps n\u00e9cessaire pour r\u00e9pondre. Soumettre des charges utiles OAST con\u00e7ues pour d\u00e9clencher une interaction r\u00e9seau hors bande lorsqu'elles sont ex\u00e9cut\u00e9es dans une requ\u00eate SQL , et surveiller les interactions r\u00e9sultantes.","title":"Comment d\u00e9tecter les vuln\u00e9rabilit\u00e9s d'injection SQL"},{"location":"bts-sio-2/cybersecurite/sql_injection/#injection-sql-dans-differentes-parties-de-la-requete","text":"La plupart des vuln\u00e9rabilit\u00e9s d'injection SQL surviennent dans la WHEREclause d'une SELECTrequ\u00eate. Ce type d'injection SQL est g\u00e9n\u00e9ralement bien compris par les testeurs exp\u00e9riment\u00e9s. Mais les vuln\u00e9rabilit\u00e9s d'injection SQL peuvent en principe se produire \u00e0 n'importe quel endroit de la requ\u00eate et au sein de diff\u00e9rents types de requ\u00eates. Les autres emplacements les plus courants o\u00f9 l'injection SQL se produit sont : Dans les instructions UPDATE , dans les valeurs mises \u00e0 jour ou la clause WHERE. Dans les instructions INSERT , dans les valeurs ins\u00e9r\u00e9es. Dans les instructions SELECT , dans le nom de la table ou de la colonne. Dans les d\u00e9clarations SELECT , dans la clause ORDER BY .","title":"Injection SQL dans diff\u00e9rentes parties de la requ\u00eate"},{"location":"bts-sio-2/cybersecurite/sql_injection/#injection-sql-de-second-ordre","text":"L'injection SQL de premier ordre se produit lorsque l'application prend l'entr\u00e9e de l'utilisateur \u00e0 partir d'une requ\u00eate HTTP et, au cours du traitement de cette requ\u00eate, incorpore l'entr\u00e9e dans une requ\u00eate SQL d'une mani\u00e8re dangereuse. Dans l'injection SQL de second ordre (\u00e9galement appel\u00e9e injection SQL stock\u00e9e), l'application prend l'entr\u00e9e de l'utilisateur \u00e0 partir d'une requ\u00eate HTTP et la stocke pour une utilisation future. Cela se fait g\u00e9n\u00e9ralement en pla\u00e7ant l'entr\u00e9e dans une base de donn\u00e9es, mais aucune vuln\u00e9rabilit\u00e9 ne survient au point o\u00f9 les donn\u00e9es sont stock\u00e9es. Plus tard, lors du traitement d'une requ\u00eate HTTP diff\u00e9rente, l'application r\u00e9cup\u00e8re les donn\u00e9es stock\u00e9es et les int\u00e8gre dans une requ\u00eate SQL de mani\u00e8re non s\u00e9curis\u00e9e. L'injection SQL de second ordre se produit souvent dans des situations o\u00f9 les d\u00e9veloppeurs sont conscients des vuln\u00e9rabilit\u00e9s de l'injection SQL et g\u00e8rent ainsi en toute s\u00e9curit\u00e9 le placement initial de l'entr\u00e9e dans la base de donn\u00e9es. Lorsque les donn\u00e9es sont trait\u00e9es ult\u00e9rieurement, elles sont consid\u00e9r\u00e9es comme s\u00fbres, car elles ont \u00e9t\u00e9 pr\u00e9c\u00e9demment plac\u00e9es dans la base de donn\u00e9es en toute s\u00e9curit\u00e9. \u00c0 ce stade, les donn\u00e9es sont trait\u00e9es de mani\u00e8re dangereuse, car le d\u00e9veloppeur les consid\u00e8re \u00e0 tort comme dignes de confiance.","title":"Injection SQL de second ordre"},{"location":"bts-sio-2/cybersecurite/sql_injection/#facteurs-specifiques-a-la-base-de-donnees","text":"Certaines fonctionnalit\u00e9s de base du langage SQL sont impl\u00e9ment\u00e9es de la m\u00eame mani\u00e8re sur les plates-formes de bases de donn\u00e9es courantes, et de nombreuses fa\u00e7ons de d\u00e9tecter et d'exploiter les vuln\u00e9rabilit\u00e9s d'injection SQL fonctionnent de mani\u00e8re identique sur diff\u00e9rents types de bases de donn\u00e9es. Cependant, il existe \u00e9galement de nombreuses diff\u00e9rences entre les bases de donn\u00e9es communes. Cela signifie que certaines techniques de d\u00e9tection et d'exploitation de l'injection SQL fonctionnent diff\u00e9remment sur diff\u00e9rentes plates-formes. Par exemple: Syntaxe pour la concat\u00e9nation de cha\u00eenes. Commentaires. Requ\u00eates group\u00e9es (ou empil\u00e9es). API sp\u00e9cifiques \u00e0 la plate-forme. Messages d'erreur.","title":"Facteurs sp\u00e9cifiques \u00e0 la base de donn\u00e9es"},{"location":"bts-sio-2/cybersecurite/sql_injection/#comment-empecher-linjection-sql","text":"La plupart des instances d'injection SQL peuvent \u00eatre \u00e9vit\u00e9es en utilisant des requ\u00eates param\u00e9tr\u00e9es (\u00e9galement appel\u00e9es instructions pr\u00e9par\u00e9es) au lieu de la concat\u00e9nation de cha\u00eenes dans la requ\u00eate. Le code suivant est vuln\u00e9rable \u00e0 l'injection SQL car l'entr\u00e9e utilisateur est concat\u00e9n\u00e9e directement dans la requ\u00eate : 1 String query = \"SELECT * FROM products WHERE category = '\" + input + \"'\" ; 1 2 Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(query); Ce code peut \u00eatre facilement r\u00e9\u00e9crit d'une mani\u00e8re qui emp\u00eache l'entr\u00e9e de l'utilisateur d'interf\u00e9rer avec la structure de la requ\u00eate : 1 2 3 PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM products WHERE category = ?\"); statement.setString(1, input); ResultSet resultSet = statement.executeQuery(); Les requ\u00eates param\u00e9tr\u00e9es peuvent \u00eatre utilis\u00e9es pour toute situation o\u00f9 une entr\u00e9e non fiable appara\u00eet sous forme de donn\u00e9es dans la requ\u00eate, y compris la WHERE clause et les valeurs d'une instruction INSERT ou UPDATE . Ils ne peuvent pas \u00eatre utilis\u00e9s pour g\u00e9rer des entr\u00e9es non fiables dans d'autres parties de la requ\u00eate, telles que les noms de table ou de colonne, ou la ORDER BY clause. La fonctionnalit\u00e9 d'application qui place des donn\u00e9es non fiables dans ces parties de la requ\u00eate devra adopter une approche diff\u00e9rente, telle que la mise en liste blanche des valeurs d'entr\u00e9e autoris\u00e9es, ou l'utilisation d'une logique diff\u00e9rente pour fournir le comportement requis. Pour qu'une requ\u00eate param\u00e9tr\u00e9e emp\u00eache efficacement l'injection SQL , la cha\u00eene utilis\u00e9e dans la requ\u00eate doit toujours \u00eatre une constante cod\u00e9e en dur et ne doit jamais contenir de donn\u00e9es variables de quelque origine que ce soit. Ne soyez pas tent\u00e9 de d\u00e9cider au cas par cas si un \u00e9l\u00e9ment de donn\u00e9es est fiable et continuez \u00e0 utiliser la concat\u00e9nation de cha\u00eenes dans la requ\u00eate pour les cas consid\u00e9r\u00e9s comme s\u00fbrs. Il est trop facile de faire des erreurs sur l'origine possible des donn\u00e9es, ou que des modifications dans d'autres codes violent les hypoth\u00e8ses sur les donn\u00e9es qui sont entach\u00e9es.","title":"Comment emp\u00eacher l'injection SQL"},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/","text":"Software tool requirements To complete this recipe, you will need the following: Oracle Java ( https://www.java.com/en/download/ ) Burp Proxy Community or Professional ( https://portswigger.net/burp/ ) Firefox Browser ( https://www.mozilla.org/en-US/firefox/new/ ) Comment proc\u00e9der... Apr\u00e8s avoir choisi l'\u00e9dition dont vous avez besoin, vous avez deux options d'installation, \u00e0 savoir un ex\u00e9cutable ou un simple fichier JAR . L'ex\u00e9cutable est uniquement disponible sous Windows et est propos\u00e9 en 32 ou 64 bits. Le fichier JAR simple est disponible pour Windows, macOS et Linux . L'ex\u00e9cutable Windows est autonome et cr\u00e9e des ic\u00f4nes dans la liste de vos programmes. Toutefois, le fichier JAR brut n\u00e9cessite que Java ( https://www.java.com/fr/download/ ) soit pr\u00e9install\u00e9 sur votre plate-forme. Vous pouvez choisir la version actuelle de Java ( JRE ou JDK ), alors n'h\u00e9sitez pas \u00e0 choisir la derni\u00e8re version : Mise en place d'un \"web app pentesting lab\" Le projet Broken Web Application (BWA) est un projet de l' OWASP qui fournit une VM autonome contenant une vari\u00e9t\u00e9 d'applications pr\u00e9sentant des vuln\u00e9rabilit\u00e9s connues. Les applications de cette VM permettent aux \u00e9tudiants de se familiariser avec la s\u00e9curit\u00e9 des applications Web, de pratiquer et d'observer des attaques Web et d'utiliser des outils de p\u00e9n\u00e9tration tels que Burp . Pour suivre les recipes , nous utiliserons la VM BWA de l' OWASP ( https://sourceforge.net/ projects/owaspbwa/files/ ). Outil logiciel requis Pour r\u00e9aliser cette recipe , vous aurez besoin des \u00e9l\u00e9ments suivants : Oracle VirtualBox ( https://www.virtualbox.org/wiki/Downloads ) Choisissez un ex\u00e9cutable sp\u00e9cifique \u00e0 votre plateforme Navigateur Mozilla Firefox ( https://www.mozilla.org/en-US/firefox/new/ ) Archiveur de fichiers 7-Zip ( https://www.7-zip.org/download.html ) OWASP BWA VM ( https://sourceforge.net/projects/owaspbwa/files/ ) Burp Proxy Community ou Professional ( https://portswigger.net/burp/ ) Oracle Java ( https://www.java.com/en/download/ ) How to do it ... Pour cette recipe , vous devez t\u00e9l\u00e9charger la VM OWASP BWA et l'installer en effectuant les \u00e9tapes suivantes : 1. Cliquez sur Download Latest Version \u00e0 partir du lien OWASP BWA VM fourni pr\u00e9c\u00e9demment et d\u00e9compressez le fichier OWASP_Broken_Web_Apps_VM_1.2.7z . 2. Vous obtiendrez la liste de fichiers suivante : 3. Toutes les extensions de fichiers indiqu\u00e9es indiquent que la VM peut \u00eatre import\u00e9e dans Oracle VirtualBox ou VMware Player/Workstation . Pour la mise en place du laboratoire de pentesting d'applications Web , nous utiliserons Oracle VirtualBox . 4. Prenez note du fichier OWASP Broken Web Apps-cl1.vmdk . Ouvrez le VirtualBox Manager (c'est-\u00e0-dire le programme Oracle VM VirtualBox ). 5. Dans l'\u00e9cran VirtualBox Manager , s\u00e9lectionnez Machine | New dans le menu sup\u00e9rieur et tapez un nom pour la machine, OWASP BWA . 6. D\u00e9finissez le type sur Linux et la version sur Ubuntu (64 bits) , puis cliquez sur Suivant, comme suit : 7. L'\u00e9cran suivant vous permet d'ajuster la RAM ou de la laisser telle quelle. Cliquez sur Suivant. 8. Sur l'\u00e9cran suivant, choisissez Utiliser un fichier de disque dur virtuel existant. 9. Utilisez l'ic\u00f4ne de dossier sur la droite pour s\u00e9lectionner le fichier OWASP Broken Web Apps-cl1.vmdk dans la liste extraite et cliquez sur Cr\u00e9er, comme suit : 10. Votre VM est maintenant charg\u00e9e dans le gestionnaire VirtualBox . Faisons quelques ajustements mineurs. Mettez en \u00e9vidence l'entr\u00e9e OWASP BWA et s\u00e9lectionnez Settings dans le menu sup\u00e9rieur. 11. S\u00e9lectionnez la section Network (R\u00e9seau) dans le volet de gauche et changez pour Host-only Adapter (Adaptateur h\u00f4te uniquement). Cliquez sur OK . 12. Maintenant, d\u00e9marrons la machine virtuelle. Cliquez avec le bouton droit de la souris et choisissez start | Normal Start . 13. Attendez que le syst\u00e8me Linux soit compl\u00e8tement d\u00e9marr\u00e9, ce qui peut prendre quelques minutes. Une fois le processus de d\u00e9marrage termin\u00e9, vous devriez voir l'\u00e9cran suivant. Cependant, l'adresse IP affich\u00e9e sera diff\u00e9rente pour votre machine : 14. Les informations pr\u00e9sent\u00e9es sur cet \u00e9cran identifient l' URL \u00e0 partir de laquelle vous pouvez acc\u00e9der aux applications Web vuln\u00e9rables ex\u00e9cut\u00e9es sur la VM . Par exemple, dans la capture d'\u00e9cran pr\u00e9c\u00e9dente, l' URL est http://192.168.56.101/ . Vous \u00eates invit\u00e9 \u00e0 administrer la VM , mais il n'est pas n\u00e9cessaire de vous connecter pour le moment. 15. Ouvrez le navigateur Firefox sur votre syst\u00e8me h\u00f4te, et non dans la VM . En utilisant le navigateur Firefox sur votre machine h\u00f4te, entrez l' URL fournie (par exemple, http://192.168.56.101/ ), o\u00f9 l'adresse IP est sp\u00e9cifique \u00e0 votre machine. 16. Dans votre navigateur, une page d'index contenant des liens vers des applications web vuln\u00e9rables vous est pr\u00e9sent\u00e9e. Ces applications seront utilis\u00e9es comme cibles : Comment cela fonctionne En utilisant une machine virtuelle personnalis\u00e9e cr\u00e9\u00e9e par l'OWASP, nous pouvons rapidement mettre en place un laboratoire de pentesting d'applications Web contenant des applications volontairement vuln\u00e9rables, que nous pouvons utiliser comme cibles l\u00e9gales pour nos exercices tout au long de ce livre. D\u00e9marrage de Burp \u00e0 partir d'une ligne de commande ou en tant qu'ex\u00e9cutable Pour les utilisateurs non-Windows ou les utilisateurs Windows qui ont choisi l'option du fichier JAR simple, vous lancerez Burp \u00e0 partir d'une ligne de commande chaque fois qu'ils souhaiteront l'ex\u00e9cuter. En tant que tel, vous aurez besoin d'une commande Java particuli\u00e8re pour le faire. Dans certaines circonstances, telles que les scripts automatis\u00e9s, vous pouvez souhaiter invoquer Burp \u00e0 la ligne de commande comme un \u00e9l\u00e9ment de ligne dans votre script shell. En outre, vous pouvez souhaiter ex\u00e9cuter Burp sans interface utilisateur graphique (GUI), ce qui est appel\u00e9 le mode sans t\u00eate. Cette section d\u00e9crit comment effectuer ces t\u00e2ches. Comment faire... Nous allons passer en revue les commandes et les actions requises pour d\u00e9marrer le produit Burp Suite : 1. D\u00e9marrez Burp sous Windows, apr\u00e8s avoir ex\u00e9cut\u00e9 le programme d'installation \u00e0 partir du fichier .exe t\u00e9l\u00e9charg\u00e9, en double-cliquant sur l'ic\u00f4ne sur le bureau ou en le s\u00e9lectionnant dans la liste des programmes : Lorsque vous utilisez le fichier JAR simple, l'ex\u00e9cutable java est suivi de l'option -jar, puis du nom du fichier JAR \u00e0 t\u00e9l\u00e9charger. 2. D\u00e9marrez Burp \u00e0 la ligne de commande (minimale) avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Si vous pr\u00e9f\u00e9rez contr\u00f4ler davantage les param\u00e8tres de la taille du tas (c'est-\u00e0-dire la quantit\u00e9 de m\u00e9moire allou\u00e9e au programme), vous pouvez modifier la commande java. L'ex\u00e9cutable java est suivi du -jar, suivi de l'allocation de m\u00e9moire. Dans ce cas, 2 Go (c'est-\u00e0-dire 2g) sont allou\u00e9s \u00e0 la m\u00e9moire vive (RAM), suivis du nom du fichier JAR. Si vous obtenez une erreur indiquant que vous ne pouvez pas allouer autant de m\u00e9moire, r\u00e9duisez simplement la quantit\u00e9 \u00e0 quelque chose comme 1 024 Mo (c'est-\u00e0-dire 1024m). D\u00e9marrez Burp en ligne de commande (optimize) avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Il est possible de lancer Burp \u00e0 partir de la ligne de commande et de l'ex\u00e9cuter en mode sans t\u00eate. Le mode sans t\u00eate signifie ex\u00e9cuter Burp sans l'interface graphique. Pour les besoins de ce livre, nous ne lancerons pas Burp en mode headless, puisque nous apprenons \u00e0 travers l'interface graphique. Cependant, vous pourrez avoir besoin de cette information dans le futur, c'est pourquoi elle est pr\u00e9sent\u00e9e ici. D\u00e9marrez Burp \u00e0 la ligne de commande pour l'ex\u00e9cuter en mode sans t\u00eate avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Notez le placement du param\u00e8tre -Djava.awt.headless=true imm\u00e9diatement apr\u00e8s l'option -jar et avant le nom du fichier JAR. En cas de succ\u00e8s, vous devriez voir ce qui suit : Appuyez sur Ctrl + C ou Ctrl + Z pour arr\u00eater le processus. Il est possible de fournir un fichier de configuration \u00e0 la commande mode sans t\u00eate pour personnaliser le num\u00e9ro de port et l'adresse IP o\u00f9 se trouve l'auditeur proxy. Veuillez consulter les pages de support de PortSwigger pour plus d'informations sur ce sujet : https://support.portswigger.net/customer/portal/questions/ 16805563-burp-command-line.9. Dans chaque sc\u00e9nario de d\u00e9marrage d\u00e9crit, vous devriez \u00eatre pr\u00e9sent\u00e9 avec un \u00e9cran de d\u00e9marrage. Le libell\u00e9 de l'\u00e9cran d'accueil correspondra \u00e0 l'\u00e9dition que vous avez d\u00e9cid\u00e9 de t\u00e9l\u00e9charger, soit Professional ou Community. 10. Vous pouvez \u00eatre invit\u00e9 \u00e0 mettre \u00e0 jour la version ; n'h\u00e9sitez pas \u00e0 le faire, si vous le souhaitez. De nouvelles fonctionnalit\u00e9s sont constamment ajout\u00e9es \u00e0 Burp pour vous aider \u00e0 trouver des vuln\u00e9rabilit\u00e9s, la mise \u00e0 jour de l'application est donc une bonne id\u00e9e. Choisissez Mettre \u00e0 jour maintenant, le cas \u00e9ch\u00e9ant. 11. Ensuite, une bo\u00eete de dialogue vous demandant les fichiers et les configurations du projet vous est pr\u00e9sent\u00e9e : Si vous utilisez l'\u00e9dition Community, vous ne pourrez cr\u00e9er qu'un projet temporaire. Si vous utilisez l'\u00e9dition Professional, cr\u00e9ez un nouveau projet sur le disque, en l'enregistrant \u00e0 un endroit appropri\u00e9 que vous pourrez retrouver. Cliquez sur Suivant. L'\u00e9cran d'accueil suivant vous demande quelles sont les configurations que vous souhaitez utiliser. A ce stade, nous n'en avons pas encore, donc choisissez Use Burp defaults. Au fur et \u00e0 mesure que vous progresserez dans ce livre, vous souhaiterez peut-\u00eatre enregistrer les param\u00e8tres de configuration et les charger \u00e0 partir de cet \u00e9cran de d\u00e9marrage \u00e0 l'avenir, comme suit : Comment \u00e7a marche... En utilisant le fichier JAR ou l'ex\u00e9cutable Windows, vous pouvez lancer Burp pour d\u00e9marrer l'\u00e9couteur Proxy afin de capturer le trafic HTTP. Burp propose des fichiers de projet temporaires ou permanents pour sauvegarder les activit\u00e9s effectu\u00e9es dans la suite. \u00c9couter le trafic HTTP, en utilisant Burp Burp est d\u00e9crit comme un proxy d'interception. Cela signifie que Burp se situe entre le navigateur Web de l'utilisateur et le serveur Web de l'application et intercepte ou capture tout le trafic circulant entre eux. Ce type de comportement est commun\u00e9ment appel\u00e9 \"service proxy\". Les testeurs de p\u00e9n\u00e9tration utilisent des proxys d'interception pour capturer le trafic circulant entre un navigateur Web et une application Web \u00e0 des fins d'analyse et de manipulation. Par exemple, un testeur peut mettre en pause n'importe quelle requ\u00eate HTTP, ce qui permet de modifier les param\u00e8tres avant d'envoyer la requ\u00eate au serveur Web. Les proxys d'interception, tels que Burp, permettent aux testeurs d'intercepter \u00e0 la fois les requ\u00eates et les r\u00e9ponses HTTP. Cela permet au testeur d'observer le comportement de l'application web dans diff\u00e9rentes conditions. Et, comme nous le verrons, parfois, les comportements ne correspondent pas \u00e0 ce que le d\u00e9veloppeur initial attendait. Pour voir la suite Burp en action, nous devons configurer les param\u00e8tres r\u00e9seau de notre navigateur Firefox pour pointer vers notre instance de Burp en cours d'ex\u00e9cution. Cela permet \u00e0 Burp de capturer tout le trafic HTTP qui circule entre votre navigateur et l'application web cible. Pr\u00e9paration Nous allons configurer le navigateur Firefox pour permettre \u00e0 Burp d'\u00e9couter tout le trafic HTTP circulant entre le navigateur et la OWASP BWA VM. Cela permettra au service proxy de Burp de capturer le trafic \u00e0 des fins de test. Les instructions sont disponibles sur PortSwigger \u00e0 (https://support.portswigger.net/ customer/portal/articles/1783066-configuring-firefox-to-work-with-burp) et nous allons \u00e9galement suivre le processus dans la recette suivante. Comment proc\u00e9der... Voici les \u00e9tapes que vous pouvez suivre pour \u00e9couter tout le trafic HTTP en utilisant Burp : 1. Ouvrez le navigateur Firefox et allez dans Options. 2. Dans l'onglet G\u00e9n\u00e9ral, faites d\u00e9filer jusqu'\u00e0 la section Proxy r\u00e9seau, puis cliquez sur Param\u00e8tres. 3. Dans les Param\u00e8tres de connexion, s\u00e9lectionnez Configuration manuelle du proxy et saisissez l'adresse IP de 127.0.0.1 avec le port 8080. Cochez la case Utiliser ce serveur proxy pour tous les protocoles : Assurez-vous que la zone de texte No proxy for the textbox est vide, comme indiqu\u00e9 dans la capture d'\u00e9cran suivante, puis cliquez sur OK : Avec la VM OWASP BWA fonctionnant en arri\u00e8re-plan et en utilisant Firefox pour naviguer vers l'URL sp\u00e9cifique \u00e0 votre machine (c'est-\u00e0-dire l'adresse IP affich\u00e9e sur la VM Linux dans VirtualBox), cliquez sur le bouton de rechargement (la fl\u00e8che dans un cercle) pour voir le trafic captur\u00e9 dans Burp. Si vous ne voyez pas de trafic, v\u00e9rifiez si Proxy Intercept bloque la demande. Si le bouton intitul\u00e9 Intercept is on est enfonc\u00e9, comme le montre la capture d'\u00e9cran suivante, cliquez \u00e0 nouveau sur ce bouton pour d\u00e9sactiver l'interception. Apr\u00e8s avoir fait cela, le trafic devrait s'\u00e9couler librement dans Burp, comme suit : Dans l'exemple suivant, le bouton Proxy | Intercept est d\u00e9sactiv\u00e9 : Si tout fonctionne correctement, vous verrez sur votre onglet Cible | Plan du site un trafic similaire \u00e0 celui illustr\u00e9 dans la capture d'\u00e9cran suivante. Votre adresse IP sera diff\u00e9rente, bien s\u00fbr, et vous aurez peut-\u00eatre plus d'\u00e9l\u00e9ments affich\u00e9s dans votre plan du site. F\u00e9licitations ! Burp est maintenant \u00e0 l'\u00e9coute de tout le trafic de votre navigateur ! Comment cela fonctionne... Le service Burp Proxy \u00e9coute sur 127.0.0.1 port 8080. L'un ou l'autre de ces param\u00e8tres peut \u00eatre modifi\u00e9 pour \u00e9couter sur une autre adresse IP ou un autre num\u00e9ro de port. Toutefois, pour les besoins de l'apprentissage, nous utiliserons les param\u00e8tres par d\u00e9faut. Getting to Know the Burp Su2ite of Tools In this chapter, we will cover the following recipes: Setting the Target Site Map Understanding Message Editor Repeating with Repeater Decoding with Decoder Intruding with Intruder Introduction This chapter provides overviews of the most commonly used tools within Burp Suite. The chapter begins by establishing the Target scope within the Target Site Map. This is followed by an introduction to the Message Editor. Then, there will be some hands-on recipes using OWASP Mutillidae II to get acquainted with Proxy, Repeater, Decoder, and Intruder. Getting to Know the Burp Suite of Tools Chapter 2 Software tool requirements To complete the recipes in this chapter, you will need the following: Burp Proxy Community or Professional (https:/\u200b/\u200bportswigger.\u200bnet/\u200bburp/\u200b) The Firefox browser configured to allow Burp to proxy traffic (https:/\u200b/\u200bwww. mozilla.\u200borg/\u200ben-\u200bUS/\u200bfirefox/\u200bnew/\u200b) Setting the Target Site Map Now that we have traffic flowing between your browser, Burp, and the OWASP BWA virtual machine, we can begin setting the scope of our test. For this recipe, we will use the OWASP Mutillidae II link (http:// /mutillidae/) available in the OWASP BWA VM as our target application. Looking more closely at the Target tab, you will notice there are two subtabs available: Site map and Scope. From the initial proxy setup between your browser, Burp, and the web server, you should now have some URLs, folders, and files shown in the Target | Site map tab. You may find the amount of information overwhelming, but setting the scope for our project will help to focus our attention better. Getting ready Using the Target | Site map and Target | Scope tab, we will assign the URL for mutillidae (http:// /mutillidae/) as the scope. [ 26 ] Getting to Know the Burp Suite of Tools Chapter 2 How to do it... Execute the following steps to set the Target Site Map: 1. Search for the folder mutillidae and right-click on Add to scope. Notice the brief highlighting of the Target | Scope subtab, as follows: Apr\u00e8s avoir ajout\u00e9 le dossier mutillidae \u00e0 votre champ d'application, une bo\u00eete de dialogue de journalisation de l'historique du proxy peut s'afficher, comme suit. Vous pouvez choisir d'\u00e9viter de collecter les messages hors de votre chape en cliquant sur Oui. Ou vous pouvez choisir de continuer \u00e0 faire en sorte que la table d'historique HTTP du proxy collecte tous les messages passant par Burp, m\u00eame si ces messages sortent de la port\u00e9e que vous avez identifi\u00e9e. Pour nos besoins, nous choisirons Oui : 3. En retournant l'onglet Target | Scope, vous devriez maintenant voir l'URL compl\u00e8te de l'OWASP Mutillidae II, indiqu\u00e9e dans le tableau Include in scope, comme suit : [ 28 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment \u00e7a marche... L'\u00e9diteur de messages affiche des informations d\u00e9taill\u00e9es sur tout message HTTP passant par l'\u00e9couteur Proxy. Apr\u00e8s avoir configur\u00e9 le Proxy pour capturer le trafic HTTP, comme vous pouvez le voir dans l'onglet Cible | Plan du site et Burp Proxy | Historique HTTP, vous pouvez s\u00e9lectionner un seul message pour faire appara\u00eetre l'\u00e9diteur de messages. Chaque \u00e9diteur contient les c\u00f4t\u00e9s demande et r\u00e9ponse du message, \u00e0 condition que le message soit correctement proxi\u00e9 par Burp. [ 29 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comprendre l'\u00e9diteur de message Sur presque tous les outils et onglets de la suite Burp qui affichent un message HTTP, vous verrez un \u00e9diteur identifiant la demande et la r\u00e9ponse. C'est ce qu'on appelle commun\u00e9ment l'\u00e9diteur de messages. L'\u00e9diteur de messages permet de visualiser et de modifier les demandes et les r\u00e9ponses HTTP avec des sp\u00e9cialit\u00e9s. L'\u00e9diteur de messages comporte plusieurs sous-onglets. Les sous-onglets d'un message de demande comprennent au minimum les \u00e9l\u00e9ments suivants : En-t\u00eates bruts Hex Les sous-onglets d'un message de r\u00e9ponse comprennent les \u00e9l\u00e9ments suivants : Brut En-t\u00eates bruts Hex HTML (parfois) Rendu (parfois) L'onglet Raw vous donne le message sous sa forme HTTP brute. L'onglet En-t\u00eates affiche les param\u00e8tres des en-t\u00eates HTTP sous forme de tableau. Les param\u00e8tres sont \u00e9ditables, et des colonnes peuvent \u00eatre ajout\u00e9es, supprim\u00e9es ou modifi\u00e9es dans le tableau dans des outils tels que Proxy et Repeater. Pour les requ\u00eates contenant des param\u00e8tres ou des cookies, l'onglet Params est pr\u00e9sent. Les param\u00e8tres sont \u00e9ditables, et des colonnes peuvent \u00eatre ajout\u00e9es, supprim\u00e9es ou modifi\u00e9es dans le tableau au sein d'outils tels que Proxy et Repeater. Enfin, il y a l'onglet Hex, qui pr\u00e9sente le message au format hexad\u00e9cimal ; il s'agit, en fait, d'un \u00e9diteur hexad\u00e9cimal. Vous \u00eates autoris\u00e9 \u00e0 modifier des octets individuels dans des outils tels que Proxy et Repeater, mais ces valeurs doivent \u00eatre indiqu\u00e9es sous forme hexad\u00e9cimale \u00e0 deux chiffres, de 00 \u00e0 FF. [ 30 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Se pr\u00e9parer Explorons les multiples onglets disponibles dans l'\u00e9diteur de messages pour chaque requ\u00eate et r\u00e9ponse captur\u00e9e dans Burp. Comment faire... Assurez-vous que le trafic circule entre votre navigateur, Burp, et la machine virtuelle OWASP BWA. 1. En regardant l'onglet Target | Site map, remarquez la section Message Editor : [ 31 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 2. Lorsque vous visualisez une requ\u00eate, notez que les sous-onglets disponibles comprennent Raw, Headers et Hex, au minimum. Cependant, dans le cas d'une requ\u00eate contenant des param\u00e8tres ou des cookies, le sous-onglet Params est \u00e9galement disponible : 3. De l'autre c\u00f4t\u00e9 du message se trouve l'onglet Response, qui contient les sous-onglets Raw, Headers, Hex, et parfois HTML et Render. Il s'agit des diff\u00e9rents formats fournis pour la r\u00e9ponse HTTP \u00e0 la demande. Si le contenu est en HTML, alors l'onglet appara\u00eetra. De m\u00eame, l'onglet Render permet d'afficher le HTML tel qu'il serait pr\u00e9sent\u00e9 dans un navigateur mais sans qu'aucun JavaScript ne soit ex\u00e9cut\u00e9 : [ 32 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 R\u00e9p\u00e9tition avec Repeater Repeater permet d'apporter de l\u00e9g\u00e8res modifications ou ajustements \u00e0 la demande, et celle-ci est affich\u00e9e dans la fen\u00eatre de gauche. Un bouton Go permet de r\u00e9\u00e9mettre la requ\u00eate, et la r\u00e9ponse s'affiche dans la fen\u00eatre de droite. Les d\u00e9tails relatifs \u00e0 votre requ\u00eate HTTP comprennent les d\u00e9tails standard de l'\u00e9diteur de messages tels que Raw, Params (pour les requ\u00eates avec param\u00e8tres ou cookies), Headers et Hex. Les d\u00e9tails relatifs \u00e0 la r\u00e9ponse HTTP comprennent les d\u00e9tails standard de l'\u00e9diteur de messages, notamment Raw, Headers, Hex et, parfois, HTML et Render. En bas de chaque panneau se trouve un champ de recherche, permettant au testeur de trouver rapidement une valeur pr\u00e9sente dans un message. Se pr\u00e9parer Repeater vous permet de modifier manuellement puis de r\u00e9\u00e9mettre une requ\u00eate HTTP individuelle, en analysant la r\u00e9ponse que vous recevez. [ 33 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment faire... 1. Dans les onglets Cible | Plan du site ou Proxy | Historique HTTP (illustr\u00e9s dans la capture d'\u00e9cran suivante), cliquez avec le bouton droit de la souris sur un message et s\u00e9lectionnez Envoyer au r\u00e9p\u00e9teur : 2. Passez \u00e0 l'onglet R\u00e9p\u00e9teur. Notez que la requ\u00eate HTTP est pr\u00eate pour que le testeur modifie les param\u00e8tres, puis envoie la requ\u00eate \u00e0 l'application via le bouton Go. le bouton Go. [ 34 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Notez les bo\u00eetes de recherche au bas de chaque panneau : Nous utiliserons Repeater assez souvent tout au long de ce livre. Ce chapitre est juste une introduction au Repeater et \u00e0 la compr\u00e9hension de son but. D\u00e9codage avec Decoder Burp Decoder est un outil Traduit avec www.DeepL.com/Translator (version gratuite) Notez les bo\u00eetes de recherche au bas de chaque panneau : Nous utiliserons Repeater assez souvent tout au long de ce livre. Ce chapitre est juste une introduction au Repeater et \u00e0 la compr\u00e9hension de son but. D\u00e9codage avec Decoder Burp Decoder est un outil qui permet au testeur de convertir des donn\u00e9es brutes en donn\u00e9es cod\u00e9es ou de prendre des donn\u00e9es cod\u00e9es et de les reconvertir en texte brut. Decoder prend en charge plusieurs formats, notamment le codage URL, le codage HTML, le codage Base64, le code binaire, les donn\u00e9es hach\u00e9es, etc. Decoder comprend \u00e9galement un \u00e9diteur hexad\u00e9cimal int\u00e9gr\u00e9. Se pr\u00e9parer Au fur et \u00e0 mesure de l'avancement d'un test de p\u00e9n\u00e9tration du Web, un testeur peut tomber sur une valeur encod\u00e9e. Burp facilite le processus de d\u00e9codage en permettant au testeur d'envoyer la valeur cod\u00e9e au Decoder et d'essayer les diff\u00e9rentes fonctions de d\u00e9codage disponibles. [ 35 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment faire... Essayons de d\u00e9coder la valeur du jeton de session PHPSESSID trouv\u00e9 dans l'application OWASP Mutillidae II. Lorsqu'un utilisateur navigue initialement sur l'URL (http:// /mutillidae/), un cookie PHPSESSID lui est attribu\u00e9. La valeur PHPSESSID semble \u00eatre crypt\u00e9e, puis envelopp\u00e9e dans un codage de base 64. En utilisant le Decoder, nous pouvons d\u00e9baller la valeur. 1. Acc\u00e9dez \u00e0 l'application http:// /mutillidae/. 2. Trouvez la requ\u00eate HTTP que vous venez de g\u00e9n\u00e9rer \u00e0 partir de votre navigation dans l'onglet Proxy | Historique HTTP (illustr\u00e9 dans la capture d'\u00e9cran suivante). Mettez en surbrillance la valeur PHPSESSID, et non le nom du param\u00e8tre, faites un clic droit, et s\u00e9lectionnez Send to Decoder : [ 36 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 3. Dans l'onglet Decoder, dans la liste d\u00e9roulante Decode as... comme suit, s\u00e9lectionnez Base 64. Notez que les r\u00e9sultats sont visualis\u00e9s dans l'\u00e9diteur Hex et sont chiffr\u00e9s : Dans cet exemple, nous ne pouvons pas aller plus loin. Nous pouvons confirmer que la valeur \u00e9tait, en effet, envelopp\u00e9e en Base 64. Cependant, la valeur qui est d\u00e9ball\u00e9e est crypt\u00e9e. Le but de cette recette est de vous montrer comment vous pouvez utiliser Decoder pour manipuler des valeurs cod\u00e9es. Intrusion avec Intruder L'Intruder de Burp permet \u00e0 un testeur de forcer brutalement ou de fuzzer des portions sp\u00e9cifiques d'un message HTTP, en utilisant des charges utiles personnalis\u00e9es. [ 37 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Pour configurer correctement des attaques personnalis\u00e9es dans Intruder, un testeur devra utiliser les param\u00e8tres disponibles dans les quatre sous-onglets d'Intruder : Se pr\u00e9parer Un testeur peut souhaiter fuzzer ou forcer brutalement des valeurs de param\u00e8tres dans un message. Burp Intruder facilite ce processus en fournissant diff\u00e9rents styles d'attaques, charges utiles et options. Comment proc\u00e9der... 1. Acc\u00e9dez \u00e0 l'\u00e9cran de connexion de Mutillidae et essayez de vous connecter \u00e0 l'application. Par exemple, saisissez le nom d'utilisateur admin et le mot de passe adminpass. 2. Trouvez la tentative de connexion dans l'onglet Proxy | Historique HTTP. Le num\u00e9ro de votre demande (c'est-\u00e0-dire le signe # sur le c\u00f4t\u00e9 gauche) sera diff\u00e9rent de celui qui est indiqu\u00e9 ci-dessous. S\u00e9lectionnez le message qui a captur\u00e9 votre tentative de connexion. [ 38 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 3. Lorsque le message de tentative de connexion est mis en \u00e9vidence dans le tableau de l'historique HTTP, cliquez avec le bouton droit de la souris sur l'onglet Request, et s\u00e9lectionnez Send to Intruder : [ 39 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Cible L'onglet Cible de l'intrus d\u00e9finit votre application Web cibl\u00e9e. Ces param\u00e8tres sont pr\u00e9-remplis pour vous par Burp : Positions L'onglet Positions identifie l'endroit o\u00f9 les marqueurs de charge utile doivent \u00eatre d\u00e9finis dans la section Payload | Positions. Pour nos besoins, cliquez sur le \u00a7 Clear (c'est-\u00e0-dire les marqueurs de charge utile) dans le menu lat\u00e9ral droit. S\u00e9lectionnez manuellement le champ du mot de passe en le mettant en surbrillance avec votre curseur. Cliquez maintenant sur le bouton Ajouter \u00a7 dans le menu lat\u00e9ral de droite. Les marqueurs de charge utile devraient entourer le champ du mot de passe comme suit : [ 40 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Charges utiles Apr\u00e8s l'onglet Positions se trouve l'onglet Charges utiles. L'onglet Payloads identifie les valeurs des listes de mots ou les nombres que vous souhaitez ins\u00e9rer dans les positions que vous avez identifi\u00e9es dans l'onglet pr\u00e9c\u00e9dent. L'onglet Payloads comporte plusieurs sections, dont Payload Sets, Payload Options, Payload Processing et Payload Encoding. Jeux de donn\u00e9es utiles La section Payload Sets permet de d\u00e9finir le nombre de charges utiles ainsi que leur type. Pour nos besoins, nous utiliserons les param\u00e8tres par d\u00e9faut pour Sniper, ce qui nous permettra d'utiliser une charge utile avec un type de charge utile de type Liste simple : Options de la charge utile Dans la section Payload Options, un testeur peut configurer une charge utile personnalis\u00e9e ou en charger une pr\u00e9configur\u00e9e depuis un fichier. [ 41 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Pour nos besoins, nous allons ajouter une valeur \u00e0 notre charge utile. Dans la zone de texte, tapez admin, puis cliquez sur le bouton Add pour cr\u00e9er notre charge utile personnalis\u00e9e : Traitement des donn\u00e9es utiles Le traitement des charges utiles est utile pour configurer des r\u00e8gles sp\u00e9ciales \u00e0 utiliser lorsqu'Intruder substitue des charges utiles aux positions des marqueurs de charges utiles. Pour cette recette, nous n'avons pas besoin de r\u00e8gles sp\u00e9ciales de traitement des charges utiles : [ 42 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Encodage de la charge utile Traduit avec www.DeepL.com/Translator (version gratuite)","title":"Activite 2"},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/#software-tool-requirements","text":"To complete this recipe, you will need the following: Oracle Java ( https://www.java.com/en/download/ ) Burp Proxy Community or Professional ( https://portswigger.net/burp/ ) Firefox Browser ( https://www.mozilla.org/en-US/firefox/new/ )","title":"Software tool requirements"},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/#comment-proceder","text":"Apr\u00e8s avoir choisi l'\u00e9dition dont vous avez besoin, vous avez deux options d'installation, \u00e0 savoir un ex\u00e9cutable ou un simple fichier JAR . L'ex\u00e9cutable est uniquement disponible sous Windows et est propos\u00e9 en 32 ou 64 bits. Le fichier JAR simple est disponible pour Windows, macOS et Linux . L'ex\u00e9cutable Windows est autonome et cr\u00e9e des ic\u00f4nes dans la liste de vos programmes. Toutefois, le fichier JAR brut n\u00e9cessite que Java ( https://www.java.com/fr/download/ ) soit pr\u00e9install\u00e9 sur votre plate-forme. Vous pouvez choisir la version actuelle de Java ( JRE ou JDK ), alors n'h\u00e9sitez pas \u00e0 choisir la derni\u00e8re version :","title":"Comment proc\u00e9der..."},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/#mise-en-place-dun-web-app-pentesting-lab","text":"Le projet Broken Web Application (BWA) est un projet de l' OWASP qui fournit une VM autonome contenant une vari\u00e9t\u00e9 d'applications pr\u00e9sentant des vuln\u00e9rabilit\u00e9s connues. Les applications de cette VM permettent aux \u00e9tudiants de se familiariser avec la s\u00e9curit\u00e9 des applications Web, de pratiquer et d'observer des attaques Web et d'utiliser des outils de p\u00e9n\u00e9tration tels que Burp . Pour suivre les recipes , nous utiliserons la VM BWA de l' OWASP ( https://sourceforge.net/ projects/owaspbwa/files/ ).","title":"Mise en place d'un \"web app pentesting lab\""},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/#outil-logiciel-requis","text":"Pour r\u00e9aliser cette recipe , vous aurez besoin des \u00e9l\u00e9ments suivants : Oracle VirtualBox ( https://www.virtualbox.org/wiki/Downloads ) Choisissez un ex\u00e9cutable sp\u00e9cifique \u00e0 votre plateforme Navigateur Mozilla Firefox ( https://www.mozilla.org/en-US/firefox/new/ ) Archiveur de fichiers 7-Zip ( https://www.7-zip.org/download.html ) OWASP BWA VM ( https://sourceforge.net/projects/owaspbwa/files/ ) Burp Proxy Community ou Professional ( https://portswigger.net/burp/ ) Oracle Java ( https://www.java.com/en/download/ )","title":"Outil logiciel requis"},{"location":"bts-sio-2/cybersecurite/activite_2/Activite_2/#how-to-do-it","text":"Pour cette recipe , vous devez t\u00e9l\u00e9charger la VM OWASP BWA et l'installer en effectuant les \u00e9tapes suivantes : 1. Cliquez sur Download Latest Version \u00e0 partir du lien OWASP BWA VM fourni pr\u00e9c\u00e9demment et d\u00e9compressez le fichier OWASP_Broken_Web_Apps_VM_1.2.7z . 2. Vous obtiendrez la liste de fichiers suivante : 3. Toutes les extensions de fichiers indiqu\u00e9es indiquent que la VM peut \u00eatre import\u00e9e dans Oracle VirtualBox ou VMware Player/Workstation . Pour la mise en place du laboratoire de pentesting d'applications Web , nous utiliserons Oracle VirtualBox . 4. Prenez note du fichier OWASP Broken Web Apps-cl1.vmdk . Ouvrez le VirtualBox Manager (c'est-\u00e0-dire le programme Oracle VM VirtualBox ). 5. Dans l'\u00e9cran VirtualBox Manager , s\u00e9lectionnez Machine | New dans le menu sup\u00e9rieur et tapez un nom pour la machine, OWASP BWA . 6. D\u00e9finissez le type sur Linux et la version sur Ubuntu (64 bits) , puis cliquez sur Suivant, comme suit : 7. L'\u00e9cran suivant vous permet d'ajuster la RAM ou de la laisser telle quelle. Cliquez sur Suivant. 8. Sur l'\u00e9cran suivant, choisissez Utiliser un fichier de disque dur virtuel existant. 9. Utilisez l'ic\u00f4ne de dossier sur la droite pour s\u00e9lectionner le fichier OWASP Broken Web Apps-cl1.vmdk dans la liste extraite et cliquez sur Cr\u00e9er, comme suit : 10. Votre VM est maintenant charg\u00e9e dans le gestionnaire VirtualBox . Faisons quelques ajustements mineurs. Mettez en \u00e9vidence l'entr\u00e9e OWASP BWA et s\u00e9lectionnez Settings dans le menu sup\u00e9rieur. 11. S\u00e9lectionnez la section Network (R\u00e9seau) dans le volet de gauche et changez pour Host-only Adapter (Adaptateur h\u00f4te uniquement). Cliquez sur OK . 12. Maintenant, d\u00e9marrons la machine virtuelle. Cliquez avec le bouton droit de la souris et choisissez start | Normal Start . 13. Attendez que le syst\u00e8me Linux soit compl\u00e8tement d\u00e9marr\u00e9, ce qui peut prendre quelques minutes. Une fois le processus de d\u00e9marrage termin\u00e9, vous devriez voir l'\u00e9cran suivant. Cependant, l'adresse IP affich\u00e9e sera diff\u00e9rente pour votre machine : 14. Les informations pr\u00e9sent\u00e9es sur cet \u00e9cran identifient l' URL \u00e0 partir de laquelle vous pouvez acc\u00e9der aux applications Web vuln\u00e9rables ex\u00e9cut\u00e9es sur la VM . Par exemple, dans la capture d'\u00e9cran pr\u00e9c\u00e9dente, l' URL est http://192.168.56.101/ . Vous \u00eates invit\u00e9 \u00e0 administrer la VM , mais il n'est pas n\u00e9cessaire de vous connecter pour le moment. 15. Ouvrez le navigateur Firefox sur votre syst\u00e8me h\u00f4te, et non dans la VM . En utilisant le navigateur Firefox sur votre machine h\u00f4te, entrez l' URL fournie (par exemple, http://192.168.56.101/ ), o\u00f9 l'adresse IP est sp\u00e9cifique \u00e0 votre machine. 16. Dans votre navigateur, une page d'index contenant des liens vers des applications web vuln\u00e9rables vous est pr\u00e9sent\u00e9e. Ces applications seront utilis\u00e9es comme cibles : Comment cela fonctionne En utilisant une machine virtuelle personnalis\u00e9e cr\u00e9\u00e9e par l'OWASP, nous pouvons rapidement mettre en place un laboratoire de pentesting d'applications Web contenant des applications volontairement vuln\u00e9rables, que nous pouvons utiliser comme cibles l\u00e9gales pour nos exercices tout au long de ce livre. D\u00e9marrage de Burp \u00e0 partir d'une ligne de commande ou en tant qu'ex\u00e9cutable Pour les utilisateurs non-Windows ou les utilisateurs Windows qui ont choisi l'option du fichier JAR simple, vous lancerez Burp \u00e0 partir d'une ligne de commande chaque fois qu'ils souhaiteront l'ex\u00e9cuter. En tant que tel, vous aurez besoin d'une commande Java particuli\u00e8re pour le faire. Dans certaines circonstances, telles que les scripts automatis\u00e9s, vous pouvez souhaiter invoquer Burp \u00e0 la ligne de commande comme un \u00e9l\u00e9ment de ligne dans votre script shell. En outre, vous pouvez souhaiter ex\u00e9cuter Burp sans interface utilisateur graphique (GUI), ce qui est appel\u00e9 le mode sans t\u00eate. Cette section d\u00e9crit comment effectuer ces t\u00e2ches. Comment faire... Nous allons passer en revue les commandes et les actions requises pour d\u00e9marrer le produit Burp Suite : 1. D\u00e9marrez Burp sous Windows, apr\u00e8s avoir ex\u00e9cut\u00e9 le programme d'installation \u00e0 partir du fichier .exe t\u00e9l\u00e9charg\u00e9, en double-cliquant sur l'ic\u00f4ne sur le bureau ou en le s\u00e9lectionnant dans la liste des programmes : Lorsque vous utilisez le fichier JAR simple, l'ex\u00e9cutable java est suivi de l'option -jar, puis du nom du fichier JAR \u00e0 t\u00e9l\u00e9charger. 2. D\u00e9marrez Burp \u00e0 la ligne de commande (minimale) avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Si vous pr\u00e9f\u00e9rez contr\u00f4ler davantage les param\u00e8tres de la taille du tas (c'est-\u00e0-dire la quantit\u00e9 de m\u00e9moire allou\u00e9e au programme), vous pouvez modifier la commande java. L'ex\u00e9cutable java est suivi du -jar, suivi de l'allocation de m\u00e9moire. Dans ce cas, 2 Go (c'est-\u00e0-dire 2g) sont allou\u00e9s \u00e0 la m\u00e9moire vive (RAM), suivis du nom du fichier JAR. Si vous obtenez une erreur indiquant que vous ne pouvez pas allouer autant de m\u00e9moire, r\u00e9duisez simplement la quantit\u00e9 \u00e0 quelque chose comme 1 024 Mo (c'est-\u00e0-dire 1024m). D\u00e9marrez Burp en ligne de commande (optimize) avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Il est possible de lancer Burp \u00e0 partir de la ligne de commande et de l'ex\u00e9cuter en mode sans t\u00eate. Le mode sans t\u00eate signifie ex\u00e9cuter Burp sans l'interface graphique. Pour les besoins de ce livre, nous ne lancerons pas Burp en mode headless, puisque nous apprenons \u00e0 travers l'interface graphique. Cependant, vous pourrez avoir besoin de cette information dans le futur, c'est pourquoi elle est pr\u00e9sent\u00e9e ici. D\u00e9marrez Burp \u00e0 la ligne de commande pour l'ex\u00e9cuter en mode sans t\u00eate avec le fichier JAR simple (Java doit \u00eatre install\u00e9 en premier) : Notez le placement du param\u00e8tre -Djava.awt.headless=true imm\u00e9diatement apr\u00e8s l'option -jar et avant le nom du fichier JAR. En cas de succ\u00e8s, vous devriez voir ce qui suit : Appuyez sur Ctrl + C ou Ctrl + Z pour arr\u00eater le processus. Il est possible de fournir un fichier de configuration \u00e0 la commande mode sans t\u00eate pour personnaliser le num\u00e9ro de port et l'adresse IP o\u00f9 se trouve l'auditeur proxy. Veuillez consulter les pages de support de PortSwigger pour plus d'informations sur ce sujet : https://support.portswigger.net/customer/portal/questions/ 16805563-burp-command-line.9. Dans chaque sc\u00e9nario de d\u00e9marrage d\u00e9crit, vous devriez \u00eatre pr\u00e9sent\u00e9 avec un \u00e9cran de d\u00e9marrage. Le libell\u00e9 de l'\u00e9cran d'accueil correspondra \u00e0 l'\u00e9dition que vous avez d\u00e9cid\u00e9 de t\u00e9l\u00e9charger, soit Professional ou Community. 10. Vous pouvez \u00eatre invit\u00e9 \u00e0 mettre \u00e0 jour la version ; n'h\u00e9sitez pas \u00e0 le faire, si vous le souhaitez. De nouvelles fonctionnalit\u00e9s sont constamment ajout\u00e9es \u00e0 Burp pour vous aider \u00e0 trouver des vuln\u00e9rabilit\u00e9s, la mise \u00e0 jour de l'application est donc une bonne id\u00e9e. Choisissez Mettre \u00e0 jour maintenant, le cas \u00e9ch\u00e9ant. 11. Ensuite, une bo\u00eete de dialogue vous demandant les fichiers et les configurations du projet vous est pr\u00e9sent\u00e9e : Si vous utilisez l'\u00e9dition Community, vous ne pourrez cr\u00e9er qu'un projet temporaire. Si vous utilisez l'\u00e9dition Professional, cr\u00e9ez un nouveau projet sur le disque, en l'enregistrant \u00e0 un endroit appropri\u00e9 que vous pourrez retrouver. Cliquez sur Suivant. L'\u00e9cran d'accueil suivant vous demande quelles sont les configurations que vous souhaitez utiliser. A ce stade, nous n'en avons pas encore, donc choisissez Use Burp defaults. Au fur et \u00e0 mesure que vous progresserez dans ce livre, vous souhaiterez peut-\u00eatre enregistrer les param\u00e8tres de configuration et les charger \u00e0 partir de cet \u00e9cran de d\u00e9marrage \u00e0 l'avenir, comme suit : Comment \u00e7a marche... En utilisant le fichier JAR ou l'ex\u00e9cutable Windows, vous pouvez lancer Burp pour d\u00e9marrer l'\u00e9couteur Proxy afin de capturer le trafic HTTP. Burp propose des fichiers de projet temporaires ou permanents pour sauvegarder les activit\u00e9s effectu\u00e9es dans la suite. \u00c9couter le trafic HTTP, en utilisant Burp Burp est d\u00e9crit comme un proxy d'interception. Cela signifie que Burp se situe entre le navigateur Web de l'utilisateur et le serveur Web de l'application et intercepte ou capture tout le trafic circulant entre eux. Ce type de comportement est commun\u00e9ment appel\u00e9 \"service proxy\". Les testeurs de p\u00e9n\u00e9tration utilisent des proxys d'interception pour capturer le trafic circulant entre un navigateur Web et une application Web \u00e0 des fins d'analyse et de manipulation. Par exemple, un testeur peut mettre en pause n'importe quelle requ\u00eate HTTP, ce qui permet de modifier les param\u00e8tres avant d'envoyer la requ\u00eate au serveur Web. Les proxys d'interception, tels que Burp, permettent aux testeurs d'intercepter \u00e0 la fois les requ\u00eates et les r\u00e9ponses HTTP. Cela permet au testeur d'observer le comportement de l'application web dans diff\u00e9rentes conditions. Et, comme nous le verrons, parfois, les comportements ne correspondent pas \u00e0 ce que le d\u00e9veloppeur initial attendait. Pour voir la suite Burp en action, nous devons configurer les param\u00e8tres r\u00e9seau de notre navigateur Firefox pour pointer vers notre instance de Burp en cours d'ex\u00e9cution. Cela permet \u00e0 Burp de capturer tout le trafic HTTP qui circule entre votre navigateur et l'application web cible. Pr\u00e9paration Nous allons configurer le navigateur Firefox pour permettre \u00e0 Burp d'\u00e9couter tout le trafic HTTP circulant entre le navigateur et la OWASP BWA VM. Cela permettra au service proxy de Burp de capturer le trafic \u00e0 des fins de test. Les instructions sont disponibles sur PortSwigger \u00e0 (https://support.portswigger.net/ customer/portal/articles/1783066-configuring-firefox-to-work-with-burp) et nous allons \u00e9galement suivre le processus dans la recette suivante. Comment proc\u00e9der... Voici les \u00e9tapes que vous pouvez suivre pour \u00e9couter tout le trafic HTTP en utilisant Burp : 1. Ouvrez le navigateur Firefox et allez dans Options. 2. Dans l'onglet G\u00e9n\u00e9ral, faites d\u00e9filer jusqu'\u00e0 la section Proxy r\u00e9seau, puis cliquez sur Param\u00e8tres. 3. Dans les Param\u00e8tres de connexion, s\u00e9lectionnez Configuration manuelle du proxy et saisissez l'adresse IP de 127.0.0.1 avec le port 8080. Cochez la case Utiliser ce serveur proxy pour tous les protocoles : Assurez-vous que la zone de texte No proxy for the textbox est vide, comme indiqu\u00e9 dans la capture d'\u00e9cran suivante, puis cliquez sur OK : Avec la VM OWASP BWA fonctionnant en arri\u00e8re-plan et en utilisant Firefox pour naviguer vers l'URL sp\u00e9cifique \u00e0 votre machine (c'est-\u00e0-dire l'adresse IP affich\u00e9e sur la VM Linux dans VirtualBox), cliquez sur le bouton de rechargement (la fl\u00e8che dans un cercle) pour voir le trafic captur\u00e9 dans Burp. Si vous ne voyez pas de trafic, v\u00e9rifiez si Proxy Intercept bloque la demande. Si le bouton intitul\u00e9 Intercept is on est enfonc\u00e9, comme le montre la capture d'\u00e9cran suivante, cliquez \u00e0 nouveau sur ce bouton pour d\u00e9sactiver l'interception. Apr\u00e8s avoir fait cela, le trafic devrait s'\u00e9couler librement dans Burp, comme suit : Dans l'exemple suivant, le bouton Proxy | Intercept est d\u00e9sactiv\u00e9 : Si tout fonctionne correctement, vous verrez sur votre onglet Cible | Plan du site un trafic similaire \u00e0 celui illustr\u00e9 dans la capture d'\u00e9cran suivante. Votre adresse IP sera diff\u00e9rente, bien s\u00fbr, et vous aurez peut-\u00eatre plus d'\u00e9l\u00e9ments affich\u00e9s dans votre plan du site. F\u00e9licitations ! Burp est maintenant \u00e0 l'\u00e9coute de tout le trafic de votre navigateur ! Comment cela fonctionne... Le service Burp Proxy \u00e9coute sur 127.0.0.1 port 8080. L'un ou l'autre de ces param\u00e8tres peut \u00eatre modifi\u00e9 pour \u00e9couter sur une autre adresse IP ou un autre num\u00e9ro de port. Toutefois, pour les besoins de l'apprentissage, nous utiliserons les param\u00e8tres par d\u00e9faut. Getting to Know the Burp Su2ite of Tools In this chapter, we will cover the following recipes: Setting the Target Site Map Understanding Message Editor Repeating with Repeater Decoding with Decoder Intruding with Intruder Introduction This chapter provides overviews of the most commonly used tools within Burp Suite. The chapter begins by establishing the Target scope within the Target Site Map. This is followed by an introduction to the Message Editor. Then, there will be some hands-on recipes using OWASP Mutillidae II to get acquainted with Proxy, Repeater, Decoder, and Intruder. Getting to Know the Burp Suite of Tools Chapter 2 Software tool requirements To complete the recipes in this chapter, you will need the following: Burp Proxy Community or Professional (https:/\u200b/\u200bportswigger.\u200bnet/\u200bburp/\u200b) The Firefox browser configured to allow Burp to proxy traffic (https:/\u200b/\u200bwww. mozilla.\u200borg/\u200ben-\u200bUS/\u200bfirefox/\u200bnew/\u200b) Setting the Target Site Map Now that we have traffic flowing between your browser, Burp, and the OWASP BWA virtual machine, we can begin setting the scope of our test. For this recipe, we will use the OWASP Mutillidae II link (http:// /mutillidae/) available in the OWASP BWA VM as our target application. Looking more closely at the Target tab, you will notice there are two subtabs available: Site map and Scope. From the initial proxy setup between your browser, Burp, and the web server, you should now have some URLs, folders, and files shown in the Target | Site map tab. You may find the amount of information overwhelming, but setting the scope for our project will help to focus our attention better. Getting ready Using the Target | Site map and Target | Scope tab, we will assign the URL for mutillidae (http:// /mutillidae/) as the scope. [ 26 ] Getting to Know the Burp Suite of Tools Chapter 2 How to do it... Execute the following steps to set the Target Site Map: 1. Search for the folder mutillidae and right-click on Add to scope. Notice the brief highlighting of the Target | Scope subtab, as follows: Apr\u00e8s avoir ajout\u00e9 le dossier mutillidae \u00e0 votre champ d'application, une bo\u00eete de dialogue de journalisation de l'historique du proxy peut s'afficher, comme suit. Vous pouvez choisir d'\u00e9viter de collecter les messages hors de votre chape en cliquant sur Oui. Ou vous pouvez choisir de continuer \u00e0 faire en sorte que la table d'historique HTTP du proxy collecte tous les messages passant par Burp, m\u00eame si ces messages sortent de la port\u00e9e que vous avez identifi\u00e9e. Pour nos besoins, nous choisirons Oui : 3. En retournant l'onglet Target | Scope, vous devriez maintenant voir l'URL compl\u00e8te de l'OWASP Mutillidae II, indiqu\u00e9e dans le tableau Include in scope, comme suit : [ 28 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment \u00e7a marche... L'\u00e9diteur de messages affiche des informations d\u00e9taill\u00e9es sur tout message HTTP passant par l'\u00e9couteur Proxy. Apr\u00e8s avoir configur\u00e9 le Proxy pour capturer le trafic HTTP, comme vous pouvez le voir dans l'onglet Cible | Plan du site et Burp Proxy | Historique HTTP, vous pouvez s\u00e9lectionner un seul message pour faire appara\u00eetre l'\u00e9diteur de messages. Chaque \u00e9diteur contient les c\u00f4t\u00e9s demande et r\u00e9ponse du message, \u00e0 condition que le message soit correctement proxi\u00e9 par Burp. [ 29 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comprendre l'\u00e9diteur de message Sur presque tous les outils et onglets de la suite Burp qui affichent un message HTTP, vous verrez un \u00e9diteur identifiant la demande et la r\u00e9ponse. C'est ce qu'on appelle commun\u00e9ment l'\u00e9diteur de messages. L'\u00e9diteur de messages permet de visualiser et de modifier les demandes et les r\u00e9ponses HTTP avec des sp\u00e9cialit\u00e9s. L'\u00e9diteur de messages comporte plusieurs sous-onglets. Les sous-onglets d'un message de demande comprennent au minimum les \u00e9l\u00e9ments suivants : En-t\u00eates bruts Hex Les sous-onglets d'un message de r\u00e9ponse comprennent les \u00e9l\u00e9ments suivants : Brut En-t\u00eates bruts Hex HTML (parfois) Rendu (parfois) L'onglet Raw vous donne le message sous sa forme HTTP brute. L'onglet En-t\u00eates affiche les param\u00e8tres des en-t\u00eates HTTP sous forme de tableau. Les param\u00e8tres sont \u00e9ditables, et des colonnes peuvent \u00eatre ajout\u00e9es, supprim\u00e9es ou modifi\u00e9es dans le tableau dans des outils tels que Proxy et Repeater. Pour les requ\u00eates contenant des param\u00e8tres ou des cookies, l'onglet Params est pr\u00e9sent. Les param\u00e8tres sont \u00e9ditables, et des colonnes peuvent \u00eatre ajout\u00e9es, supprim\u00e9es ou modifi\u00e9es dans le tableau au sein d'outils tels que Proxy et Repeater. Enfin, il y a l'onglet Hex, qui pr\u00e9sente le message au format hexad\u00e9cimal ; il s'agit, en fait, d'un \u00e9diteur hexad\u00e9cimal. Vous \u00eates autoris\u00e9 \u00e0 modifier des octets individuels dans des outils tels que Proxy et Repeater, mais ces valeurs doivent \u00eatre indiqu\u00e9es sous forme hexad\u00e9cimale \u00e0 deux chiffres, de 00 \u00e0 FF. [ 30 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Se pr\u00e9parer Explorons les multiples onglets disponibles dans l'\u00e9diteur de messages pour chaque requ\u00eate et r\u00e9ponse captur\u00e9e dans Burp. Comment faire... Assurez-vous que le trafic circule entre votre navigateur, Burp, et la machine virtuelle OWASP BWA. 1. En regardant l'onglet Target | Site map, remarquez la section Message Editor : [ 31 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 2. Lorsque vous visualisez une requ\u00eate, notez que les sous-onglets disponibles comprennent Raw, Headers et Hex, au minimum. Cependant, dans le cas d'une requ\u00eate contenant des param\u00e8tres ou des cookies, le sous-onglet Params est \u00e9galement disponible : 3. De l'autre c\u00f4t\u00e9 du message se trouve l'onglet Response, qui contient les sous-onglets Raw, Headers, Hex, et parfois HTML et Render. Il s'agit des diff\u00e9rents formats fournis pour la r\u00e9ponse HTTP \u00e0 la demande. Si le contenu est en HTML, alors l'onglet appara\u00eetra. De m\u00eame, l'onglet Render permet d'afficher le HTML tel qu'il serait pr\u00e9sent\u00e9 dans un navigateur mais sans qu'aucun JavaScript ne soit ex\u00e9cut\u00e9 : [ 32 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 R\u00e9p\u00e9tition avec Repeater Repeater permet d'apporter de l\u00e9g\u00e8res modifications ou ajustements \u00e0 la demande, et celle-ci est affich\u00e9e dans la fen\u00eatre de gauche. Un bouton Go permet de r\u00e9\u00e9mettre la requ\u00eate, et la r\u00e9ponse s'affiche dans la fen\u00eatre de droite. Les d\u00e9tails relatifs \u00e0 votre requ\u00eate HTTP comprennent les d\u00e9tails standard de l'\u00e9diteur de messages tels que Raw, Params (pour les requ\u00eates avec param\u00e8tres ou cookies), Headers et Hex. Les d\u00e9tails relatifs \u00e0 la r\u00e9ponse HTTP comprennent les d\u00e9tails standard de l'\u00e9diteur de messages, notamment Raw, Headers, Hex et, parfois, HTML et Render. En bas de chaque panneau se trouve un champ de recherche, permettant au testeur de trouver rapidement une valeur pr\u00e9sente dans un message. Se pr\u00e9parer Repeater vous permet de modifier manuellement puis de r\u00e9\u00e9mettre une requ\u00eate HTTP individuelle, en analysant la r\u00e9ponse que vous recevez. [ 33 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment faire... 1. Dans les onglets Cible | Plan du site ou Proxy | Historique HTTP (illustr\u00e9s dans la capture d'\u00e9cran suivante), cliquez avec le bouton droit de la souris sur un message et s\u00e9lectionnez Envoyer au r\u00e9p\u00e9teur : 2. Passez \u00e0 l'onglet R\u00e9p\u00e9teur. Notez que la requ\u00eate HTTP est pr\u00eate pour que le testeur modifie les param\u00e8tres, puis envoie la requ\u00eate \u00e0 l'application via le bouton Go. le bouton Go. [ 34 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Notez les bo\u00eetes de recherche au bas de chaque panneau : Nous utiliserons Repeater assez souvent tout au long de ce livre. Ce chapitre est juste une introduction au Repeater et \u00e0 la compr\u00e9hension de son but. D\u00e9codage avec Decoder Burp Decoder est un outil Traduit avec www.DeepL.com/Translator (version gratuite) Notez les bo\u00eetes de recherche au bas de chaque panneau : Nous utiliserons Repeater assez souvent tout au long de ce livre. Ce chapitre est juste une introduction au Repeater et \u00e0 la compr\u00e9hension de son but. D\u00e9codage avec Decoder Burp Decoder est un outil qui permet au testeur de convertir des donn\u00e9es brutes en donn\u00e9es cod\u00e9es ou de prendre des donn\u00e9es cod\u00e9es et de les reconvertir en texte brut. Decoder prend en charge plusieurs formats, notamment le codage URL, le codage HTML, le codage Base64, le code binaire, les donn\u00e9es hach\u00e9es, etc. Decoder comprend \u00e9galement un \u00e9diteur hexad\u00e9cimal int\u00e9gr\u00e9. Se pr\u00e9parer Au fur et \u00e0 mesure de l'avancement d'un test de p\u00e9n\u00e9tration du Web, un testeur peut tomber sur une valeur encod\u00e9e. Burp facilite le processus de d\u00e9codage en permettant au testeur d'envoyer la valeur cod\u00e9e au Decoder et d'essayer les diff\u00e9rentes fonctions de d\u00e9codage disponibles. [ 35 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Comment faire... Essayons de d\u00e9coder la valeur du jeton de session PHPSESSID trouv\u00e9 dans l'application OWASP Mutillidae II. Lorsqu'un utilisateur navigue initialement sur l'URL (http:// /mutillidae/), un cookie PHPSESSID lui est attribu\u00e9. La valeur PHPSESSID semble \u00eatre crypt\u00e9e, puis envelopp\u00e9e dans un codage de base 64. En utilisant le Decoder, nous pouvons d\u00e9baller la valeur. 1. Acc\u00e9dez \u00e0 l'application http:// /mutillidae/. 2. Trouvez la requ\u00eate HTTP que vous venez de g\u00e9n\u00e9rer \u00e0 partir de votre navigation dans l'onglet Proxy | Historique HTTP (illustr\u00e9 dans la capture d'\u00e9cran suivante). Mettez en surbrillance la valeur PHPSESSID, et non le nom du param\u00e8tre, faites un clic droit, et s\u00e9lectionnez Send to Decoder : [ 36 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 3. Dans l'onglet Decoder, dans la liste d\u00e9roulante Decode as... comme suit, s\u00e9lectionnez Base 64. Notez que les r\u00e9sultats sont visualis\u00e9s dans l'\u00e9diteur Hex et sont chiffr\u00e9s : Dans cet exemple, nous ne pouvons pas aller plus loin. Nous pouvons confirmer que la valeur \u00e9tait, en effet, envelopp\u00e9e en Base 64. Cependant, la valeur qui est d\u00e9ball\u00e9e est crypt\u00e9e. Le but de cette recette est de vous montrer comment vous pouvez utiliser Decoder pour manipuler des valeurs cod\u00e9es. Intrusion avec Intruder L'Intruder de Burp permet \u00e0 un testeur de forcer brutalement ou de fuzzer des portions sp\u00e9cifiques d'un message HTTP, en utilisant des charges utiles personnalis\u00e9es. [ 37 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Pour configurer correctement des attaques personnalis\u00e9es dans Intruder, un testeur devra utiliser les param\u00e8tres disponibles dans les quatre sous-onglets d'Intruder : Se pr\u00e9parer Un testeur peut souhaiter fuzzer ou forcer brutalement des valeurs de param\u00e8tres dans un message. Burp Intruder facilite ce processus en fournissant diff\u00e9rents styles d'attaques, charges utiles et options. Comment proc\u00e9der... 1. Acc\u00e9dez \u00e0 l'\u00e9cran de connexion de Mutillidae et essayez de vous connecter \u00e0 l'application. Par exemple, saisissez le nom d'utilisateur admin et le mot de passe adminpass. 2. Trouvez la tentative de connexion dans l'onglet Proxy | Historique HTTP. Le num\u00e9ro de votre demande (c'est-\u00e0-dire le signe # sur le c\u00f4t\u00e9 gauche) sera diff\u00e9rent de celui qui est indiqu\u00e9 ci-dessous. S\u00e9lectionnez le message qui a captur\u00e9 votre tentative de connexion. [ 38 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 3. Lorsque le message de tentative de connexion est mis en \u00e9vidence dans le tableau de l'historique HTTP, cliquez avec le bouton droit de la souris sur l'onglet Request, et s\u00e9lectionnez Send to Intruder : [ 39 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Cible L'onglet Cible de l'intrus d\u00e9finit votre application Web cibl\u00e9e. Ces param\u00e8tres sont pr\u00e9-remplis pour vous par Burp : Positions L'onglet Positions identifie l'endroit o\u00f9 les marqueurs de charge utile doivent \u00eatre d\u00e9finis dans la section Payload | Positions. Pour nos besoins, cliquez sur le \u00a7 Clear (c'est-\u00e0-dire les marqueurs de charge utile) dans le menu lat\u00e9ral droit. S\u00e9lectionnez manuellement le champ du mot de passe en le mettant en surbrillance avec votre curseur. Cliquez maintenant sur le bouton Ajouter \u00a7 dans le menu lat\u00e9ral de droite. Les marqueurs de charge utile devraient entourer le champ du mot de passe comme suit : [ 40 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Charges utiles Apr\u00e8s l'onglet Positions se trouve l'onglet Charges utiles. L'onglet Payloads identifie les valeurs des listes de mots ou les nombres que vous souhaitez ins\u00e9rer dans les positions que vous avez identifi\u00e9es dans l'onglet pr\u00e9c\u00e9dent. L'onglet Payloads comporte plusieurs sections, dont Payload Sets, Payload Options, Payload Processing et Payload Encoding. Jeux de donn\u00e9es utiles La section Payload Sets permet de d\u00e9finir le nombre de charges utiles ainsi que leur type. Pour nos besoins, nous utiliserons les param\u00e8tres par d\u00e9faut pour Sniper, ce qui nous permettra d'utiliser une charge utile avec un type de charge utile de type Liste simple : Options de la charge utile Dans la section Payload Options, un testeur peut configurer une charge utile personnalis\u00e9e ou en charger une pr\u00e9configur\u00e9e depuis un fichier. [ 41 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Pour nos besoins, nous allons ajouter une valeur \u00e0 notre charge utile. Dans la zone de texte, tapez admin, puis cliquez sur le bouton Add pour cr\u00e9er notre charge utile personnalis\u00e9e : Traitement des donn\u00e9es utiles Le traitement des charges utiles est utile pour configurer des r\u00e8gles sp\u00e9ciales \u00e0 utiliser lorsqu'Intruder substitue des charges utiles aux positions des marqueurs de charges utiles. Pour cette recette, nous n'avons pas besoin de r\u00e8gles sp\u00e9ciales de traitement des charges utiles : [ 42 ] Apprendre \u00e0 conna\u00eetre la suite d'outils Burp Chapitre 2 Encodage de la charge utile Traduit avec www.DeepL.com/Translator (version gratuite)","title":"How to do it ..."}]}